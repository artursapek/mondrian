// Generated by CoffeeScript 1.6.3
/*
Mondrian vector editor
http://mondrian.io

This software is available under the MIT License. Have fun with it.
Contact: me@artur.co
*/


/*

  Built-in prototype extensions
*/


(function() {
  var AntlerPoint, Antlers, ArbitraryShapeTool, AttrEvent, Bounds, CONSTANTS, Circle, Color, Control, CubicBezier, CurvePoint, CurveTo, DEBUGGING, DropboxFile, Dropdown, DropdownOption, Ellipse, Event, ExistenceEvent, File, Font, FontFaceOption, HorizTo, HoverTarget, Line, LineSegment, LineTo, LocalFile, MapEvent, Menu, MenuItem, Monsvg, MoveTo, NumberBox, PNG, Path, PermalinkFile, Point, PointExistenceEvent, PointsList, PointsSegment, Polygon, Polyline, Polynomial, Posn, Range, Ray, Rect, RotateTransformation, SETTINGS, SVG, ScaleTransformation, Service, Set, Slider, SmoothTo, Swatch, SwatchDuo, Text, TextBox, TextEditable, Tool, Transformations, TranslateTransformation, Tspan, UIState, Utility, VertiTo, ZIndexEvent, allowsHotkeys, annotations, appLoaded, async, cleanUpNumber, cloneObject, demoFiles, dom, float, fontFace, grid, int, io, isBezierControlHandle, isDefaultQuarantined, isHandle, isHoverTarget, isOnTopUI, isPointHandle, isSVGElement, isSVGElementInMain, isSwatch, isTextInput, isTransformerHandle, isUtilityWindow, lab, mixins, noop, objectValues, oots, pathfinder, print, q, qa, queryElemByUUID, queryElemByZIndex, secondRoundSetup, setup, sortNumbers, trackEvent, url, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Math.lerp = function(a, b, c) {
    return b + a * (c - b);
  };

  Math.KAPPA = 0.5522847498307936;

  String.prototype.toFloat = function() {
    return parseFloat(this.valueOf().match(/[\d\.]/g).join(''));
  };

  String.prototype.mentions = function(phrase) {
    var p, _i, _len;
    if (typeof phrase === 'string') {
      return this.indexOf(phrase) > -1;
    } else if (phrase instanceof Array) {
      for (_i = 0, _len = phrase.length; _i < _len; _i++) {
        p = phrase[_i];
        if (this.mentions(p)) {
          return true;
        }
      }
      return false;
    }
  };

  SVGAnimatedString.prototype.mentions = function(phrase) {
    return this.baseVal.mentions(phrase);
  };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.camelCase = function() {
    return this.split(/[^a-z]/gi).map(function(x, ind) {
      if (ind === 0) {
        return x;
      } else {
        return x.capitalize();
      }
    }).join('');
  };

  String.prototype.strip = function() {
    return this.replace(/(^\s*)|(\s+$)|\n/g, '');
  };

  Number.prototype.px = function() {
    return "" + (this.toPrecision()) + "px";
  };

  Number.prototype.invert = function() {
    return this * -1;
  };

  Number.prototype.within = function(tolerance, other) {
    var d;
    d = this - other;
    return d < tolerance && d > -tolerance;
  };

  Number.prototype.roundIfWithin = function(tolerance) {
    if ((Math.ceil(this) - this) < tolerance) {
      return Math.ceil(this);
    } else if ((this - Math.floor(this)) < tolerance) {
      return Math.floor(this);
    } else {
      return this.valueOf();
    }
  };

  Number.prototype.ensureRealNumber = function() {
    var fuckedUp, val;
    val = this.valueOf();
    fuckedUp = val === Infinity || val === -Infinity || isNaN(val);
    if (fuckedUp) {
      return 1;
    } else {
      return val;
    }
  };

  Number.prototype.toNearest = function(n, tolerance) {
    var add, inverse, offset, val;
    add = false;
    val = this.valueOf();
    if (val < 0) {
      inverse = true;
      val *= -1;
    }
    offset = val % n;
    if (offset > n / 2) {
      offset = n - offset;
      add = true;
    }
    if ((tolerance != null) && offset > tolerance) {
      return val;
    }
    if (offset < n / 2) {
      if (add) {
        val = val + offset;
      } else {
        val = val - offset;
      }
    } else {
      if (add) {
        val = val - (n - offset);
      } else {
        val = val + (n - offset);
      }
    }
    if (inverse) {
      val *= -1;
    }
    return val;
  };

  Array.prototype.remove = function(el) {
    if (el instanceof RegExp) {
      return this.filter(function(a) {
        return !el.test(a);
      });
    } else {
      if (el instanceof Array) {
        return this.filter(function(a) {
          return !el.has(a);
        });
      } else {
        return this.filter(function(a) {
          return el !== a;
        });
      }
    }
  };

  Array.prototype.has = function(el) {
    if (el instanceof Function) {
      return this.filter(el).length > 0;
    } else {
      return this.indexOf(el) > -1;
    }
  };

  Array.prototype.find = function(func) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (func(this[i])) {
        return this[i];
      }
    }
  };

  Array.prototype.ensure = function(el) {
    if (this.indexOf(el) === -1) {
      return this.push(el);
    }
  };

  Array.prototype.first = function() {
    return this[0];
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  Array.prototype.sortByZIndex = function() {
    return this.sort(function(a, b) {
      if (a.zIndex() < b.zIndex()) {
        return -1;
      } else {
        return 1;
      }
    });
  };

  Array.prototype.replace = function(r, w) {
    var ind;
    ind = this.indexOf(r);
    if (ind === -1) {
      return this;
    } else {
      return this.slice(0, ind).concat(w instanceof Array ? w : [w]).concat(this.slice(ind + 1));
    }
  };

  Array.prototype.cannibalize = function() {
    this.push(this[0]);
    return this.slice(1);
  };

  Array.prototype.cannibalizeUntil = function(elem) {
    var head, placesAway;
    placesAway = this.indexOf(elem);
    head = this.splice(placesAway);
    return head.concat(this);
  };

  Array.prototype.without = function(elem) {
    return this.filter(function(x) {
      return x !== elem;
    });
  };

  Element.prototype.remove = function() {
    if (this.parentElement !== null) {
      return this.parentElement.removeChild(this);
    }
  };

  Element.prototype.removeChildren = function() {
    var _results;
    _results = [];
    while (this.childNodes.length > 0) {
      _results.push(this.childNodes[0].remove());
    }
    return _results;
  };

  Element.prototype.toString = function() {
    return new XMLSerializer.serializeToString(this);
  };

  Number.prototype.places = function(x) {
    return parseFloat(this.toFixed(x));
  };

  Set = (function(_super) {
    __extends(Set, _super);

    function Set(array) {
      var elem, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        elem = array[_i];
        if (!this.has(elem)) {
          this.push(elem);
        }
      }
      Set.__super__.constructor.apply(this, arguments);
    }

    Set.prototype.push = function(elem) {
      if (this.has(elem)) {
        return;
      }
      return Set.__super__.push.call(this, elem);
    };

    return Set;

  })(Array);

  window.Set = Set;

  /*
  
    Settings
  
    Production/development-dependent settings
  
    Meowset is Mondrian's backend server.
  */


  SETTINGS = {};

  SETTINGS.PRODUCTION = /mondrian/.test(document.location.host);

  SETTINGS.MEOWSET = {
    AVAILABLE: true,
    ENDPOINT: SETTINGS.PRODUCTION ? "http://meowset.mondrian.io" : "http://localhost:8000"
  };

  SETTINGS.BONITA = {
    ENDPOINT: SETTINGS.PRODUCTION ? "http://bonita.mondrian.io" : "http://localhost:8080"
  };

  SETTINGS.EMBED = {
    AVAILABLE: true,
    ENDPOINT: SETTINGS.PRODUCTION ? "http://embed.mondrian.io" : "http://localhost:8000"
  };

  SETTINGS.MATH = {
    POINT_DECIMAL_PLACES: 5,
    POINT_ROUND_DGAF: 1e-5
  };

  SETTINGS.DOUBLE_CLICK_THRESHOLD = 600;

  SETTINGS.DRAG_THRESHOLD = 3;

  CONSTANTS = {
    MATCHERS: {
      POINT: /[MLCSHV][\-\de\.\,\-\s]+/gi
    },
    SVG_NAMESPACE: "http://www.w3.org/2000/svg"
  };

  /*
  
    Setup
  
    Bind $(document).ready
    Global exports
  */


  appLoaded = false;

  setup = [];

  secondRoundSetup = [];

  $(document).ajaxSend(function() {
    return ui.logo.animate();
  });

  $(document).ajaxComplete(function() {
    return ui.logo.stopAnimating();
  });

  $(document).ready(function() {
    var procedure, _i, _j, _len, _len1;
    for (_i = 0, _len = setup.length; _i < _len; _i++) {
      procedure = setup[_i];
      procedure();
    }
    appLoaded = true;
    for (_j = 0, _len1 = secondRoundSetup.length; _j < _len1; _j++) {
      procedure = secondRoundSetup[_j];
      procedure();
    }
    return setTimeout(function() {
      return window.scrollTo(0, 0);
    }, 500);
  });

  /*
  
    Utils
  
    Random little snippets to make things easier.
    Default prototype extensions for String, Array, Math... everything
  
    Add miscellaneous helpers that can be useful in more than one file here, since
    this gets compiled before everything else.
  
           _____
          /__    \
          ___) E| -_
         \_____  -_  -_
                   -_  -_
                     -_  -_
                       -_ o |
                         -_ /     This is a wrench ok?
  */


  print = function() {
    return console.log.apply(console, arguments);
  };

  async = function(fun) {
    return setTimeout(fun, 1);
  };

  q = function(query) {
    return document.querySelector.call(document, query);
  };

  qa = function(query) {
    return document.querySelectorAll.call(document, query);
  };

  window.uuid = function(len) {
    var chars, i, id, _i;
    if (len == null) {
      len = 20;
    }
    id = '';
    chars = ('abcdefghijklmnopqrstuvwxyz' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '1234567890').split('');
    for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
      id += chars[parseInt(Math.random() * 62, 10)];
    }
    return id;
  };

  isSVGElement = function(target) {
    return target.namespaceURI === 'http://www.w3.org/2000/svg';
  };

  isSVGElementInMain = function(target) {
    return target.namespaceURI === 'http://www.w3.org/2000/svg' && $(target).closest("#main").length > 0 && target.id !== 'main';
  };

  isPointHandle = function(target) {
    return target.className === 'transform handle point';
  };

  isBezierControlHandle = function(target) {
    return target.className === 'transform handle point bz-ctrl';
  };

  isTransformerHandle = function(target) {
    return target.className.mentions('transform handle');
  };

  isHoverTarget = function(target) {
    var _ref;
    return ((_ref = target.parentNode) != null ? _ref.id : void 0) === 'hover-targets';
  };

  isHandle = function(target) {
    if (target.nodeName.toLowerCase() === 'div') {
      return target.className.mentions('handle');
    }
    return false;
  };

  isTextInput = function(target) {
    return target.nodeName.toLowerCase() === "input" && target.getAttribute("type") === "text";
  };

  isUtilityWindow = function(target) {
    return target.className.mentions("utility-window") || $(target).closest('.utility-window').length > 0;
  };

  isSwatch = function(target) {
    return target.className.mentions("swatch");
  };

  isOnTopUI = function(target) {
    var cl;
    if (typeof target.className === "string") {
      cl = target.className.split(" ");
      if (cl.has("disabled")) {
        return false;
      }
      if (cl.has("tool-button")) {
        return "tb";
      } else if (cl.has("menu")) {
        return "menu";
      } else if (cl.has("menu-item")) {
        return "menu-item";
      } else if (cl.has("menu-dropdown")) {
        return "dui";
      }
    }
    if (target.hasAttribute("buttontext")) {
      return true;
    }
    if (target.nodeName.toLowerCase() === "a") {
      return true;
    }
    if (target.id === "hd-file-loader") {
      return "file-loader";
    } else if (isTextInput(target)) {
      return "text-input";
    } else if (isUtilityWindow(target)) {
      return "utility-window";
    } else if (isSwatch(target)) {
      return "swatch";
    }
    return false;
  };

  allowsHotkeys = function(target) {
    return $(target).closest("[h]").length > 0;
  };

  isDefaultQuarantined = function(target) {
    if (target.hasAttribute("quarantine")) {
      return true;
    } else if ($(target).closest("[quarantine]").length > 0) {
      return true;
    } else {
      return false;
    }
  };

  queryElemByUUID = function(uuid) {
    return ui.queryElement(q('#main [uuid="' + uuid + '"]'));
  };

  queryElemByZIndex = function(zi) {
    return ui.queryElement(dom.$main.children()[zi]);
  };

  cleanUpNumber = function(n) {
    n = n.roundIfWithin(SETTINGS.MATH.POINT_ROUND_DGAF);
    n = n.places(SETTINGS.MATH.POINT_DECIMAL_PLACES);
    return n;
  };

  int = function(n) {
    return parseInt(n, 10);
  };

  float = function(n) {
    return parseFloat(n);
  };

  oots = Object.prototype.toString;

  Object.prototype.toString = function() {
    var e;
    if (this instanceof $) {
      return "$('" + this.selector + "') object";
    } else {
      try {
        return JSON.stringify(this);
      } catch (_error) {
        e = _error;
        return oots.call(this);
      }
    }
  };

  objectValues = function(obj) {
    var key, val, vals;
    vals = [];
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      vals.push(val);
    }
    return vals;
  };

  cloneObject = function(obj) {
    var key, newo, val;
    newo = new Object();
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      newo[key] = val;
    }
    return newo;
  };

  sortNumbers = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else if (a === b) {
      return 0;
    }
  };

  /*
  
    jQuery plugins
    Baw baw baw. Let's use these with moderation.
  */


  $.fn.hotkeys = function(hotkeys) {
    var self;
    self = this;
    return $(this).attr("h", "").focus(function() {
      ui.hotkeys.enable();
      return ui.hotkeys.using = {
        context: self,
        ignoreAllOthers: false,
        down: hotkeys.down,
        up: hotkeys.up,
        always: hotkeys.always
      };
    }).blur(function() {});
  };

  $.fn.nudge = function(x, y, min, max) {
    var $self, left, minmax, top;
    if (min == null) {
      min = {
        x: -1 / 0,
        y: -1 / 0
      };
    }
    if (max == null) {
      max = {
        x: 1 / 0,
        y: 1 / 0
      };
    }
    $self = $(this);
    left = $self.css("left");
    top = $self.css("top");
    if ($self.attr("drag-x")) {
      minmax = $self.attr("drag-x").split(" ").map(function(x) {
        return parseInt(x, 10);
      });
      min.x = minmax[0];
      max.x = minmax[1];
    }
    if ($self.attr("drag-y")) {
      minmax = $self.attr("drag-y").split(" ").map(function(x) {
        return parseInt(x, 10);
      });
      min.y = minmax[0];
      max.y = minmax[1];
    }
    $self.css({
      left: Math.max(min.x, Math.min(max.x, parseFloat(left) + x)).px(),
      top: Math.max(min.y, Math.min(max.y, parseFloat(top) + y)).px()
    });
    return $self.trigger("nudge");
  };

  $.fn.fitToVal = function(add) {
    var $self, resizeAction;
    if (add == null) {
      add = 0;
    }
    $self = $(this);
    resizeAction = function(e) {
      var $ghost, val;
      val = $self.val();
      $ghost = $("<div id=\"ghost\">" + val + "</div>").appendTo(dom.$body);
      $self.css({
        width: "" + ($ghost.width() + add) + "px"
      });
      return $ghost.remove();
    };
    $self.unbind('keyup.fitToVal').on('keyup.fitToVal', resizeAction);
    return resizeAction();
  };

  $.fn.disable = function() {
    var $self;
    $self = $(this);
    return $self.attr("disabled", "");
  };

  $.fn.enable = function() {
    var $self;
    $self = $(this);
    return $self.removeAttr("disabled");
  };

  $.fn.error = function(msg) {
    var $err, $self;
    $self = $(this);
    $err = $self.siblings('.error-display').show();
    $err.find('.lifespan').removeClass('empty');
    $err.find('.msg').text(msg);
    async(function() {
      return $err.find('.lifespan').addClass('empty');
    });
    return setTimeout(function() {
      return $err.hide();
    }, 5 * 1000);
  };

  $.fn.pending = function(html) {
    var $self, oghtml;
    $self = $(this);
    oghtml = $self.html();
    $self.addClass("pending");
    $self.html(html);
    return function() {
      $self.html(oghtml);
      return $self.removeClass("pending");
    };
  };

  /*
  
    Google Analytics tracking.
  */


  trackEvent = function(category, event, lbl) {
    var label;
    label = "" + ui.account;
    if (lbl != null) {
      label += ": " + lbl;
    }
    if (SETTINGS.PRODUCTION) {
      return _gaq.push(['_trackEvent', category, event, label]);
    } else {

    }
  };

  /*
  
    Common object mixins. To use a mixin,
  
      $.extend(myObject, mixins.desiredMixin)
  */


  mixins = {};

  /*
  
    Standard event system
  */


  mixins.events = {
    _handlers: {},
    on: function(event, handler) {
      var _base;
      if ((_base = this._handlers)[event] == null) {
        _base[event] = [];
      }
      return this._handlers[event].push(handler);
    },
    off: function(event) {
      return delete this._handlers[event];
    },
    trigger: function() {
      var _ref;
      return (_ref = this._handlers[arguments[0]]) != null ? _ref.forEach(function(handler) {
        var args;
        args = Array.prototype.slice.call(arguments, 1);
        return handler.apply(this, args);
      }) : void 0;
    }
  };

  /*
  
    io
  
    The goal of this is an IO that can take anything that could
    conceivably be SVG and convert it to Monsvg.
  */


  io = {
    parse: function(input, makeNew) {
      var $svg, bounds, parsed, svg, viewbox;
      if (makeNew == null) {
        makeNew = true;
      }
      $svg = this.findSVGRoot(input);
      svg = $svg[0];
      bounds = this.getBounds($svg);
      if (bounds.width == null) {
        bounds.width = 1000;
      }
      if (bounds.height == null) {
        bounds.height = 1000;
      }
      if (makeNew) {
        ui["new"](bounds.width, bounds.height);
      }
      parsed = this.recParse($svg);
      viewbox = svg.getAttribute("viewBox");
      if (viewbox) {
        viewbox = viewbox.split(" ");
        viewbox = new Bounds(viewbox[0], viewbox[1], viewbox[2], viewbox[3]);
      }
      return parsed;
    },
    getBounds: function(input) {
      var $svg, height, svg, viewbox, width;
      $svg = this.findSVGRoot(input);
      svg = $svg[0];
      width = svg.getAttribute("width");
      height = svg.getAttribute("height");
      viewbox = svg.getAttribute("viewBox");
      if (width == null) {
        if (viewbox != null) {
          width = viewbox.split(" ")[2];
        } else {
          console.warn("No width, defaulting to 1000");
          width = 1000;
        }
      }
      if (height == null) {
        if (viewbox != null) {
          height = viewbox.split(" ")[3];
        } else {
          console.warn("No height, defaulting to 1000");
          height = 1000;
        }
      }
      width = parseFloat(width);
      height = parseFloat(height);
      if (isNaN(width)) {
        console.warn("Width is NaN, defaulting to 1000");
        width = 1000;
      }
      if (isNaN(height)) {
        console.warn("Width is NaN, defaulting to 1000");
        height = 1000;
      }
      return new Bounds(0, 0, parseFloat(width), parseFloat(height));
    },
    recParse: function(container) {
      var elem, inside, monsvgs, parsed, parsedChildren, results, _i, _len, _ref;
      results = [];
      _ref = container.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (elem.nodeName === "defs") {
          continue;
          inside = this.recParse($(elem));
          results = results.concat(inside);
        } else if (elem.nodeName === "g") {
          parsedChildren = this.recParse($(elem));
          results = results.concat(parsedChildren);
          console.warn("Group element not implemented yet. Ungrouping " + parsedChildren.length + " elements.");
        } else {
          parsed = this.parseElement(elem);
          if (parsed === false) {
            continue;
          }
          if (parsed instanceof Monsvg) {
            results.push(parsed);
          } else if (parsed instanceof Object && (parsed["xlink:href"] != null)) {
            parsed.reference = true;
            results.push(parsed);
          }
        }
      }
      monsvgs = results.filter(function(e) {
        return e instanceof Monsvg;
      });
      return results;
    },
    findSVGRoot: function(input) {
      var $svg;
      if (input instanceof Array) {
        return input[0].$rep.closest("svg");
      } else if (input instanceof $) {
        input = input.filter('svg');
        if (input.is("svg")) {
          return input;
        } else {
          $svg = input.find("svg");
          if ($svg.length === 0) {
            throw new Error("io: No svg node found.");
          } else {
            return $svg[0];
          }
        }
      } else {
        return this.findSVGRoot($(input));
      }
    },
    parseElement: function(elem) {
      var $elem, attr, attrs, classes, data, key, result, transform, type, virgin, virgins;
      classes = {
        'path': Path,
        'text': Text
      };
      virgins = {
        'rect': Rect,
        'ellipse': Ellipse,
        'polygon': Polygon,
        'polyline': Polyline
      };
      if (elem instanceof $) {
        $elem = elem;
        elem = elem[0];
      }
      attrs = elem.attributes;
      transform = null;
      for (key in attrs) {
        if (!__hasProp.call(attrs, key)) continue;
        attr = attrs[key];
        if (attr.name === "transform") {
          transform = attr.value;
        }
      }
      data = this.makeData(elem);
      type = elem.nodeName.toLowerCase();
      if ((classes[type] != null) || (virgins[type] != null)) {
        result = null;
        if (classes[type] != null) {
          result = new classes[elem.nodeName.toLowerCase()](data);
          if (type === "text") {
            result.setContent(elem.textContent);
          }
        } else if (virgins[type] != null) {
          virgin = new virgins[elem.nodeName.toLowerCase()](data);
          result = virgin.convertToPath();
          result.virgin = virgin;
        }
        if (transform && elem.nodeName.toLowerCase() !== "text") {
          result.carryOutTransformations(transform);
          delete result.data.transform;
          result.rep.removeAttribute("transform");
          result.commit();
        }
        return result;
      } else if (type === "use") {
        return false;
      } else {
        return null;
      }
    },
    makeData: function(elem) {
      var attrs, blacklist, blacklistCheck, data, key, val;
      blacklist = ["inkscape", "sodipodi", "uuid"];
      blacklistCheck = function(key) {
        var x, _i, _len;
        for (_i = 0, _len = blacklist.length; _i < _len; _i++) {
          x = blacklist[_i];
          if (key.indexOf(x) > -1) {
            return false;
          }
        }
        return true;
      };
      attrs = elem.attributes;
      data = {};
      for (key in attrs) {
        val = attrs[key];
        key = val.name;
        val = val.value;
        if (key === "") {
          continue;
        }
        if (key === "style" && elem.nodeName !== "text") {
          data = this.applyStyles(data, val);
        } else if ((val != null) && blacklistCheck(key)) {
          if (/^\d+$/.test(val)) {
            val = float(val);
          }
          data[key] = val;
        }
      }
      return data;
    },
    applyStyles: function(data, styles) {
      var blacklist, key, style, val, _i, _len;
      blacklist = ["display", "transform"];
      styles = styles.split(";");
      for (_i = 0, _len = styles.length; _i < _len; _i++) {
        style = styles[_i];
        style = style.split(":");
        key = style[0];
        val = style[1];
        if (blacklist.has(key)) {
          continue;
        }
        data[key] = val;
      }
      return data;
    },
    parseAndAppend: function(input, makeNew) {
      var parsed;
      parsed = this.parse(input, makeNew);
      parsed.map(function(elem) {
        return elem.appendTo('#main');
      });
      ui.refreshAfterZoom();
      return parsed;
    },
    prepareForExport: function() {
      var elem, _i, _len, _ref, _results;
      _ref = ui.elements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (elem.type === "path") {
          if (elem.virgin != null) {
            elem.virginMode();
          }
        }
        _results.push(typeof elem.cleanUpPoints === "function" ? elem.cleanUpPoints() : void 0);
      }
      return _results;
    },
    cleanUpAfterExport: function() {
      var elem, _i, _len, _ref, _results;
      _ref = ui.elements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (elem.type === "path") {
          if (elem.virgin != null) {
            _results.push(elem.editMode());
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    makeFile: function() {
      var attr, blacklist, main, _i, _len;
      this.prepareForExport();
      main = new XMLSerializer().serializeToString(dom.main);
      this.cleanUpAfterExport();
      main = main.replace(/>/gi, ">\n");
      blacklist = ["uuid"];
      for (_i = 0, _len = blacklist.length; _i < _len; _i++) {
        attr = blacklist[_i];
        main = main.replace(new RegExp(attr + '\\=\\"\[\\d\\w\]*\\"', 'gi'), '');
      }
      return "<!-- Made in Mondrian.io -->\n" + main;
    },
    makeBase64: function() {
      return btoa(this.makeFile());
    },
    makeBase64URI: function() {
      return "data:image/svg+xml;charset=utf-8;base64," + (this.makeBase64());
    },
    makePNGURI: function(elements, maxDimen) {
      var bounds, context, elem, s, sandbox, _i, _len;
      if (elements == null) {
        elements = ui.elements;
      }
      if (maxDimen == null) {
        maxDimen = void 0;
      }
      sandbox = dom.pngSandbox;
      context = sandbox.getContext("2d");
      if (elements.length) {
        bounds = this.getBounds(elements);
      } else {
        bounds = this.getBounds(dom.main);
      }
      sandbox.setAttribute("width", bounds.width);
      sandbox.setAttribute("height", bounds.height);
      if (maxDimen != null) {
        s = Math.max(context.canvas.width, context.canvas.height) / maxDimen;
        context.canvas.width /= s;
        context.canvas.height /= s;
        context.scale(1 / s, 1 / s);
      }
      if (typeof elements === "string") {
        elements = this.parse(elements, false);
      }
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        elem = elements[_i];
        elem.drawToCanvas(context);
      }
      return sandbox.toDataURL("png");
    }
  };

  window.io = io;

  /*
  
    SVG representation class/API
  */


  SVG = (function() {
    function SVG(contents) {
      this._ensureDoc(contents);
      if (this._svgRoot == null) {
        this._svgRoot = this.doc.querySelector('svg');
      }
      if (this._svgRoot == null) {
        throw new Error('No svg element found');
      }
      this._buildMetadata();
      if (this.elements == null) {
        this._buildElements();
      }
      this._assignMondrianNamespace();
    }

    SVG.prototype._ensureDoc = function(contents) {
      var _this = this;
      if (typeof contents === 'string') {
        return this.doc = new DOMParser().parseFromString(contents, this.MIMETYPE);
      } else if (contents.documentURI != null) {
        return this.doc = contents;
      } else if (contents instanceof Array) {
        this.elements = contents;
        this.doc = document.implementation.createDocument(CONSTANTS.SVG_NAMESPACE, 'svg');
        this.doc.removeChild(this.doc.childNodes[0]);
        this._svgRoot = this.doc.createElementNS(CONSTANTS.SVG_NAMESPACE, "svg");
        this.doc.appendChild(this._svgRoot);
        this.elements.forEach(function(elem) {
          return _this._svgRoot.appendChild(elem.rep);
        });
        return this._deriveBoundsFromElements();
      } else {
        throw new Error('Bad input');
      }
    };

    SVG.prototype._buildMetadata = function() {
      this.metadata = {};
      this.metadata.width = parseInt(this._svgAttr('width', 10));
      this.metadata.height = parseInt(this._svgAttr('height', 10));
      if (this._bounds == null) {
        return this._bounds = new Bounds(0, 0, this.metadata.width, this.metadata.height);
      }
    };

    SVG.prototype._buildElements = function() {
      return this.elements = io.parse(this.toString(), false);
    };

    SVG.prototype._assignMondrianNamespace = function() {
      return this._svgRoot.setAttribute('xmlns:mondrian', 'http://mondrian.io/xml');
    };

    SVG.prototype._deriveBoundsFromElements = function() {
      var height, width;
      this._bounds = this._elementsBounds();
      width = this._bounds.width + this._bounds.x;
      height = this._bounds.height + this._bounds.y;
      return this._applyBounds();
    };

    SVG.prototype._applyBounds = function() {
      this._svgRoot.setAttribute('width', this._bounds.width);
      return this._svgRoot.setAttribute('height', this._bounds.height);
    };

    SVG.prototype._elementsBounds = function() {
      return new Bounds(this.elements.map(function(elem) {
        return elem.bounds();
      }));
    };

    SVG.prototype.trim = function() {
      var bounds;
      this._normalizeRotations();
      bounds = this._elementsBounds();
      this.elements.forEach(function(elem) {
        return elem.nudge(bounds.x.invert(), bounds.y);
      });
      this._bounds.width = bounds.width;
      this._bounds.height = bounds.height;
      return this._applyBounds();
    };

    SVG.prototype._normalizeRotations = function() {
      var angle,
        _this = this;
      angle = ui.transformer.angle;
      return this.elements.forEach(function(elem) {
        return elem.rotate(360 - angle, _this.center());
      });
    };

    SVG.prototype._svgAttr = function(attr) {
      return this._svgRoot.getAttribute(attr);
    };

    SVG.prototype.toString = function() {
      return new XMLSerializer().serializeToString(this.doc);
    };

    SVG.prototype.toBase64 = function() {
      return "data:" + this.MIMETYPE + ";charset=" + this.CHARSET + ";base64," + (this.toString());
    };

    SVG.prototype.appendTo = function(selector) {
      return q(selector).appendChild(this._svgRoot);
    };

    SVG.prototype.center = function() {
      return new Posn(this.metadata.width / 2, this.metadata.height / 2);
    };

    SVG.prototype.MIMETYPE = 'image/svg+xml';

    SVG.prototype.CHARSET = 'utf-8';

    return SVG;

  })();

  /*
  
    Pseudo-PNG class that just draws to
    an off-screen canvas and exports that
  */


  PNG = (function() {
    function PNG(elements) {
      this._parseInput(elements);
      this._buildRep();
    }

    PNG.prototype.maxDimension = function(dimen) {
      var bounds, boundsScale, context, scale;
      context = this.context();
      scale = Math.max(this.width, this.height) / dimen;
      this.setDimensions(this.width / scale, this.height / scale);
      bounds = this.svg._bounds;
      boundsScale = Math.max(bounds.width, bounds.height) / dimen;
      context.scale(1 / boundsScale, 1 / boundsScale);
      return this;
    };

    PNG.prototype["export"] = function() {
      return atob(this.exportAsBase64());
    };

    PNG.prototype.exportAsBase64 = function() {
      return this.exportAsDataURI().replace(/^.*\,/, '');
    };

    PNG.prototype.exportAsDataURI = function() {
      this._draw();
      return this.rep.toDataURL('png');
    };

    PNG.prototype.destroy = function() {
      this.elements = null;
      this.rep.remove();
      this.rep = null;
      return this;
    };

    PNG.prototype.clear = function() {
      return this.context().clearRect(0, 0, this.width, this.height);
    };

    PNG._setScale = function(x, y) {
      this.context().scale(x / this._contextScaleX, y / this._contextScaleY);
      this._contextScaleX = x;
      return this._contextScaleY = y;
    };

    PNG.prototype._draw = function() {
      var context,
        _this = this;
      this.clear();
      context = this.context();
      return this.elements.forEach(function(element) {
        return element.drawToCanvas(context);
      });
    };

    PNG.prototype._parseInput = function(elements) {
      if (typeof elements === 'string') {
        this.svg = new SVG(elements);
        return this.elements = this.svg.elements;
      } else if (elements instanceof SVG) {
        this.svg = elements;
        return this.elements = this.svg.elements;
      } else if (elements instanceof Array) {
        this.elements = elements;
        return this.svg = new SVG(this.elements);
      }
    };

    PNG.prototype._buildRep = function() {
      this.rep = document.createElement('canvas');
      this.rep.classList.add('offscreen-throwaway');
      this.setDimensions(this.svg.metadata.width, this.svg.metadata.height);
      this._contextScaleX = 1.0;
      this._contextScaleY = 1.0;
      return q('body').appendChild(this.rep);
    };

    PNG.prototype.attr = function(attr, val) {
      return this.rep.setAttribute(attr, val);
    };

    PNG.prototype.setDimensions = function(width, height) {
      this.width = width;
      this.height = height;
      this.attr('width', this.width);
      return this.attr('height', this.height);
    };

    PNG.prototype.context = function() {
      return this._context != null ? this._context : this._context = this.rep.getContext('2d');
    };

    return PNG;

  })();

  /*
  
    Management class for fontfaces
  */


  Font = (function() {
    function Font(name) {
      this.name = name;
    }

    Font.prototype.toListItem = function() {
      return $("<div class=\"dropdown-item\" style=\"font-family: '" + this.name + "'\">\n  " + this.name + "\n</div>");
    };

    return Font;

  })();

  /*
  
    Color
  
    A nice lil' class for representing and manipulating colors.
  */


  Color = (function() {
    function Color(r, g, b, a) {
      var rgb, vals;
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a != null ? a : 1.0;
      if (this.r instanceof Color) {
        return this.r;
      }
      if (this.r === null) {
        this.hex = "none";
      } else if (this.r === "none") {
        this.hex = "none";
        this.r = null;
        this.g = null;
        this.b = null;
      } else {
        if (typeof this.r === "string") {
          if (this.r.charAt(0) === "#" || this.r.length === 6) {
            this.hex = this.r.toUpperCase().replace("#", "");
            rgb = this.hexToRGB(this.hex);
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
          } else if (this.r.match(/rgba?\(.*\)/gi) != null) {
            vals = this.r.match(/[\d\.]+/gi);
            this.r = vals[0];
            this.g = vals[1];
            this.b = vals[2];
            if (vals[3] != null) {
              this.a = parseFloat(vals[3]);
            }
            this.hex = this.rgbToHex(this.r, this.g, this.b);
          }
        } else {
          if ((this.g == null) && (this.b == null)) {
            this.g = this.r;
            this.b = this.r;
          }
          this.hex = this.rgbToHex(this.r, this.g, this.b);
        }
        this.r = Math.min(this.r, 255);
        this.g = Math.min(this.g, 255);
        this.b = Math.min(this.b, 255);
        this.r = Math.max(this.r, 0);
        this.g = Math.max(this.g, 0);
        this.b = Math.max(this.b, 0);
      }
      if (isNaN(this.r || isNaN(this.g || isNaN(this.b)))) {
        if (isNaN(this.r)) {
          this.r = 0;
        }
        if (isNaN(this.g)) {
          this.g = 0;
        }
        if (isNaN(this.b)) {
          this.b = 0;
        }
        debugger;
        this.updateHex();
      }
    }

    Color.prototype.clone = function() {
      return new Color(this.r, this.g, this.b);
    };

    Color.prototype.absorb = function(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      this.a = color.a;
      this.hex = color.hex;
      if (typeof this.refresh === "function") {
        this.refresh();
      }
      return this;
    };

    Color.prototype.min = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[0];
    };

    Color.prototype.mid = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[1];
    };

    Color.prototype.max = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[2];
    };

    Color.prototype.midpoint = function() {
      return this.max() / 2;
    };

    Color.prototype.valToHex = function(val) {
      var chars;
      chars = '0123456789ABCDEF';
      return chars.charAt((val - val % 16) / 16) + chars.charAt(val % 16);
    };

    Color.prototype.hexToVal = function(hex) {
      var chars;
      chars = '0123456789ABCDEF';
      return chars.indexOf(hex.charAt(0)) * 16 + chars.indexOf(hex.charAt(1));
    };

    Color.prototype.rgbToHex = function(r, g, b) {
      return "" + (this.valToHex(r)) + (this.valToHex(g)) + (this.valToHex(b));
    };

    Color.prototype.hexToRGB = function(hex) {
      var b, g, r;
      r = this.hexToVal(hex.substring(0, 2));
      g = this.hexToVal(hex.substring(2, 4));
      b = this.hexToVal(hex.substring(4, 6));
      return {
        r: r,
        g: g,
        b: b
      };
    };

    Color.prototype.recalculateHex = function() {
      return this.hex = this.rgbToHex(this.r, this.g, this.b);
    };

    Color.prototype.darken = function(amt) {
      var macro;
      macro = function(val) {
        return val / amt;
      };
      return new Color(macro(this.r), macro(this.g), macro(this.b));
    };

    Color.prototype.lightness = function() {
      return ((this.min() + this.max()) / 2) / 255;
    };

    Color.prototype.saturation = function() {
      var d, max, min, sat;
      max = this.max();
      min = this.min();
      d = max - min;
      sat = this.lightness() >= 0.5 ? d / (510 - max - min) : d / (max + min);
      if (isNaN(sat)) {
        sat = 1.0;
      }
      return sat;
    };

    Color.prototype.desaturate = function(amt) {
      var mpt;
      if (amt == null) {
        amt = 1.0;
      }
      mpt = this.midpoint();
      this.r -= (this.r - mpt) * amt;
      this.g -= (this.g - mpt) * amt;
      this.b -= (this.b - mpt) * amt;
      this.hex = this.rgbToHex(this.r, this.g, this.b);
      return this;
    };

    Color.prototype.lighten = function(amt) {
      if (amt == null) {
        amt = 0.5;
      }
      amt *= 255;
      this.r = Math.min(255, this.r + amt);
      this.g = Math.min(255, this.g + amt);
      this.b = Math.min(255, this.b + amt);
      this.hex = this.rgbToHex(this.r, this.g, this.b);
      return this;
    };

    Color.prototype.toRGBString = function() {
      if (this.r === null) {
        return "none";
      } else {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")";
      }
    };

    Color.prototype.toHexString = function() {
      return "#" + this.hex;
    };

    Color.prototype.toString = function() {
      this.removeNaNs();
      return this.toRGBString();
    };

    Color.prototype.removeNaNs = function() {
      if (isNaN(this.r)) {
        this.r = 0;
      }
      if (isNaN(this.g)) {
        this.g = 0;
      }
      if (isNaN(this.b)) {
        return this.b = 0;
      }
    };

    Color.prototype.equal = function(c) {
      return this.toHexString() === c.toHexString();
    };

    Color.prototype.updateHex = function() {
      return this.hex = this.rgbToHex(this.r, this.g, this.b);
    };

    return Color;

  })();

  window.Color = Color;

  /*
  
    Lab
  
    Geometry conversions, operations, helpers
  
        ___
        | |
        | |
        | |
        | |
       -   -
      -   - -
     /    -  \
    |     -   |
    |    -    |
    |_________|
  */


  lab = {};

  lab.analysis = {
    intersections: function(a, b) {
      return a.lineSegmentIntersections(b);
    }
  };

  lab.conversions = {
    pathSegment: function(a, b) {
      if (b == null) {
        b = a.succ;
      }
      if (b instanceof LineTo || b instanceof MoveTo || b instanceof HorizTo || b instanceof VertiTo) {
        return new LineSegment(new Posn(a.x, a.y), new Posn(b.x, b.y), b);
      } else if (b instanceof CurveTo) {
        return new CubicBezier(new Posn(a.x, a.y), new Posn(b.x2, b.y2), new Posn(b.x3, b.y3), new Posn(b.x, b.y), b);
      } else if (b instanceof SmoothTo) {
        return new CubicBezier(new Posn(a.x, a.y), new Posn(b.x2, b.y2), new Posn(b.x3, b.y3), new Posn(b.x, b.y), b);
      }
    },
    nextSubstantialPathSegment: function(point) {
      while (point.within(1e-6, point.succ)) {
        point = point.succ;
      }
      return this.pathSegment(point, point.succ);
    },
    previousSubstantialPathSegment: function(point) {
      while (point.within(1e-6, point.prec)) {
        point = point.prec;
      }
      return this.pathSegment(point, point.prec);
    },
    stringToAlop: function(string, owner) {
      var all_matches, p, point, previous, results, _i, _len;
      results = [];
      previous = void 0;
      all_matches = string.match(CONSTANTS.MATCHERS.POINT);
      for (_i = 0, _len = all_matches.length; _i < _len; _i++) {
        point = all_matches[_i];
        p = new Point(point, owner, previous);
        if (p instanceof Point) {
          if (previous != null) {
            p.setPrec(previous);
          }
          previous = p;
          if ((p instanceof SmoothTo) && (owner instanceof Point)) {
            p.setPrec(owner);
          }
          results.push(p);
        } else if (p instanceof Array) {
          if (previous != null) {
            p[0].setPrec(previous);
            p.reduce(function(a, b) {
              return b.setPrec(a);
            });
          }
          results = results.concat(p);
        }
      }
      return results;
    },
    posn: {
      clientToCanvas: function(p) {
        p = p.clone();
        p.x -= ui.canvas.normal.x;
        p.y -= ui.canvas.normal.y;
        return p;
      },
      canvasToClient: function(p) {
        p = p.clone();
        p.x += ui.canvas.normal.x;
        p.y += ui.canvas.normal.y;
        return p;
      },
      canvasZoomedToClient: function(p) {
        p = p.multiplyBy(ui.canvas.zoom);
        return this.canvasToClient(p);
      },
      clientToCanvasZoomed: function(p) {
        return this.clientToCanvas(p).multiplyBy(1 / ui.canvas.zoom);
      }
    }
  };

  Transformations = (function() {
    function Transformations(owner, transformations) {
      var transform,
        _this = this;
      this.owner = owner;
      this.transformations = transformations;
      transform = this.owner.rep.getAttribute("transform");
      this.transformations.map(function(t) {
        return t.family = _this;
      });
      if (transform != null) {
        this.parseExisting(transform);
      }
    }

    Transformations.prototype.commit = function() {
      return this.owner.data.transform = this.toAttr();
    };

    Transformations.prototype.toAttr = function() {
      return this.transformations.map(function(t) {
        return t.toAttr();
      }).join(" ");
    };

    Transformations.prototype.toCSS = function() {
      return this.transformations.map(function(t) {
        return t.toCSS();
      }).join(" ");
    };

    Transformations.prototype.get = function(key) {
      var f;
      f = this.transformations.filter(function(t) {
        return t.key === key;
      });
      if (f.length > 0) {
        return f[0];
      }
    };

    Transformations.prototype.parseExisting = function(transform) {
      var alreadyDefined, keyword, newlyDefined, op, operations, representative, _i, _len, _results;
      operations = transform.match(/\w+\([^\)]*\)/g);
      _results = [];
      for (_i = 0, _len = operations.length; _i < _len; _i++) {
        op = operations[_i];
        keyword = op.match(/^\w+/g)[0];
        alreadyDefined = this.get(keyword);
        if (alreadyDefined != null) {
          _results.push(alreadyDefined.parse(op));
        } else {
          representative = {
            rotate: RotateTransformation,
            scale: ScaleTransformation
          }[keyword];
          if (representative != null) {
            newlyDefined = new representative().parse(op);
            newlyDefined.family = this;
            _results.push(this.transformations.push(newlyDefined));
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    Transformations.prototype.applyAsCSS = function(rep) {
      var og, tr;
      og = "-" + this.owner.origin.x + " -" + this.owner.origin.y;
      tr = this.toCSS();
      rep.style.transformOrigin = og;
      rep.style.webkitTransformOrigin = og;
      rep.style.mozTransformOrigin = og;
      rep.style.transform = tr;
      rep.style.webkitTransformOrigin = og;
      rep.style.webkitTransform = tr;
      rep.style.mozTransformOrigin = og;
      return rep.style.mozTransform = tr;
    };

    return Transformations;

  })();

  RotateTransformation = (function() {
    function RotateTransformation(deg, family) {
      this.deg = deg;
      this.family = family;
    }

    RotateTransformation.prototype.key = "rotate";

    RotateTransformation.prototype.toAttr = function() {
      return "rotate(" + (this.deg.places(3)) + " " + (this.family.owner.center().x.places(3)) + " " + (this.family.owner.center().y.places(3)) + ")";
    };

    RotateTransformation.prototype.toCSS = function() {
      return "rotate(" + (this.deg.places(3)) + "deg)";
    };

    RotateTransformation.prototype.rotate = function(a) {
      this.deg += a;
      this.deg %= 360;
      return this;
    };

    RotateTransformation.prototype.parse = function(op) {
      var x, y, _ref;
      return _ref = op.match(/[\d\.]+/g).map(parseFloat), this.deg = _ref[0], x = _ref[1], y = _ref[2], _ref;
    };

    return RotateTransformation;

  })();

  ScaleTransformation = (function() {
    function ScaleTransformation(x, y) {
      this.x = x != null ? x : 1;
      this.y = y != null ? y : 1;
    }

    ScaleTransformation.prototype.key = "scale";

    ScaleTransformation.prototype.toAttr = function() {
      return "scale(" + this.x + " " + this.y + ")";
    };

    ScaleTransformation.prototype.toCSS = function() {
      return "scale(" + this.x + ", " + this.y + ")";
    };

    ScaleTransformation.prototype.parse = function(op) {
      var _ref;
      return _ref = op.match(/[\d\.]+/g).map(parseFloat), this.x = _ref[0], this.y = _ref[1], _ref;
    };

    ScaleTransformation.prototype.scale = function(x, y) {
      if (x == null) {
        x = 1;
      }
      if (y == null) {
        y = 1;
      }
      this.x *= x;
      return this.y *= y;
    };

    return ScaleTransformation;

  })();

  TranslateTransformation = (function() {
    function TranslateTransformation(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 1;
    }

    TranslateTransformation.prototype.key = "translate";

    TranslateTransformation.prototype.toAttr = function() {
      return "translate(" + this.x + " " + this.y + ")";
    };

    TranslateTransformation.prototype.toCSS = function() {
      return "translate(" + this.x + "px, " + this.y + "px)";
    };

    TranslateTransformation.prototype.parse = function(op) {
      var _ref;
      return _ref = op.match(/[\-\d\.]+/g).map(parseFloat), this.x = _ref[0], this.y = _ref[1], _ref;
    };

    TranslateTransformation.prototype.nudge = function(x, y) {
      console.log(x, y);
      this.x += x;
      return this.y -= y;
    };

    return TranslateTransformation;

  })();

  /*
  
    Posn
  
      â€¢
        (x, y)
  
  
    Lowest-level geometry class.
  
    Consists of x, y coordinates. Provides methods for manipulating or representing
    the point in two-dimensional space.
  
    Superclass: Point
  */


  Posn = (function() {
    function Posn(x, y, zoomLevel) {
      var split;
      this.x = x;
      this.y = y;
      this.zoomLevel = zoomLevel != null ? zoomLevel : 1.0;
      if (this.x instanceof Object) {
        if ((this.x.clientX != null) && (this.x.clientY != null)) {
          this.y = this.x.clientY;
          this.x = this.x.clientX;
        } else if ((this.x.left != null) && (this.x.top != null)) {
          this.y = this.x.top;
          this.x = this.x.left;
        } else if ((this.x.x != null) && (this.x.y != null)) {
          this.y = this.x.y;
          this.x = this.x.x;
        }
      } else if ((typeof this.x === "string") && (this.x.mentions(","))) {
        split = this.x.split(",").map(parseFloat);
        x = split[0];
        y = split[1];
        this.x = x;
        this.y = y;
      }
      this;
    }

    Posn.prototype.cleanUp = function() {
      return;
      this.x = cleanUpNumber(this.x);
      return this.y = cleanUpNumber(this.y);
    };

    Posn.prototype.zoomed = function(level) {
      if (level == null) {
        level = ui.canvas.zoom;
      }
      if (this.zoomLevel === level) {
        return this;
      }
      this.unzoomed();
      this.alterValues(function(val) {
        return val *= level;
      });
      this.zoomLevel = level;
      return this;
    };

    Posn.prototype.unzoomed = function() {
      var _this = this;
      if (this.zoomLevel === 1.0) {
        return this;
      }
      this.alterValues(function(val) {
        return val /= _this.zoomLevel;
      });
      this.zoomLevel = 1.0;
      return this;
    };

    Posn.prototype.setZoom = function(zoomLevel) {
      this.zoomLevel = zoomLevel;
      this.x /= this.zoomLevel;
      this.y /= this.zoomLevel;
      return this;
    };

    Posn.prototype.zoomedc = function() {
      return this.clone().zoomed();
    };

    Posn.prototype.unzoomedc = function() {
      return this.clone.unzoomed();
    };

    Posn.prototype.alterValues = function(fun) {
      var a, _i, _len, _ref;
      _ref = ["x", "y", "x2", "y2", "x3", "y3"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        this[a] = this[a] != null ? fun(this[a]) : this[a];
      }
      return this;
    };

    Posn.prototype.toString = function() {
      return "" + this.x + "," + this.y;
    };

    Posn.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y
      };
    };

    Posn.prototype.toConstructorString = function() {
      return "new Posn(" + this.x + "," + this.y + ")";
    };

    Posn.prototype.nudge = function(x, y) {
      this.x += x;
      this.y -= y;
      return this;
    };

    Posn.prototype.lerp = function(b, factor) {
      return new Posn(this.x + (b.x - this.x) * factor, this.y + (b.y - this.y) * factor);
    };

    Posn.prototype.gte = function(p) {
      return this.x >= p.x && this.y >= p.y;
    };

    Posn.prototype.lte = function(p) {
      return this.x <= p.x && this.y <= p.y;
    };

    Posn.prototype.directionRelativeTo = function(p) {
      return "" + (this.y < p.y ? "t" : (this.y > p.y ? "b" : "")) + (this.x < p.x ? "l" : (this.x > p.x ? "r" : ""));
    };

    Posn.prototype.squareUpAgainst = function(p) {
      var direction, xDiff, yDiff;
      xDiff = Math.abs(this.x - p.x);
      yDiff = Math.abs(this.y - p.y);
      direction = this.directionRelativeTo(p);
      if ((xDiff === 0) && (yDiff === 0)) {
        return p;
      }
      switch (direction) {
        case "tl":
          if (xDiff < yDiff) {
            this.nudge(xDiff - yDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, xDiff - yDiff, 0);
          }
          break;
        case "tr":
          if (xDiff < yDiff) {
            this.nudge(yDiff - xDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, xDiff - yDiff);
          }
          break;
        case "br":
          if (xDiff < yDiff) {
            this.nudge(yDiff - xDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, yDiff - xDiff);
          }
          break;
        case "bl":
          if (xDiff < yDiff) {
            this.nudge(xDiff - yDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, yDiff - xDiff);
          }
          break;
        case "t":
        case "b":
          this.nudge(yDiff, 0);
          break;
        case "r":
        case "l":
          this.nudge(0, xDiff);
      }
      return this;
    };

    Posn.prototype.equal = function(p) {
      return this.x === p.x && this.y === p.y;
    };

    Posn.prototype.min = function(p) {
      return new Posn(Math.min(this.x, p.x), Math.min(this.y, p.y));
    };

    Posn.prototype.max = function(p) {
      return new Posn(Math.max(this.x, p.x), Math.max(this.y, p.y));
    };

    Posn.prototype.angle360 = function(base) {
      var a;
      a = 90 - new LineSegment(base, this).angle;
      return a + (this.x < base.x ? 180 : 0);
    };

    Posn.prototype.rotate = function(angle, origin) {
      var x, y;
      if (origin == null) {
        origin = new Posn(0, 0);
      }
      if (origin.equal(this)) {
        return this;
      }
      angle *= Math.PI / 180;
      this.x -= origin.x;
      this.y -= origin.y;
      x = (this.x * (Math.cos(angle))) - (this.y * Math.sin(angle));
      y = (this.x * (Math.sin(angle))) + (this.y * Math.cos(angle));
      this.x = x + origin.x;
      this.y = y + origin.y;
      return this;
    };

    Posn.prototype.scale = function(x, y, origin) {
      if (origin == null) {
        origin = new Posn(0, 0);
      }
      this.x += (this.x - origin.x) * (x - 1);
      this.y += (this.y - origin.y) * (y - 1);
      return this;
    };

    Posn.prototype.copy = function(p) {
      this.x = p.x;
      return this.y = p.y;
    };

    Posn.prototype.clone = function() {
      return new Posn(this.x, this.y, this.zoomLevel);
    };

    Posn.prototype.snap = function(to, threshold) {
      var perpLine;
      if (threshold == null) {
        threshold = Math.INFINITY;
      }
      perpLine = this.verti(10000);
      perpLine.rotate(to.angle360() + 90, this);
      return perpLine.intersection(to);
    };

    Posn.prototype.reflect = function(posn) {
      /*
      
        Reflect the point over an x and/or y axis
      
        I/P:
          posn: Posn
      */

      var x, y;
      x = posn.x;
      y = posn.y;
      return new Posn(x + (x - this.x), y + (y - this.y));
    };

    Posn.prototype.distanceFrom = function(p) {
      return new LineSegment(this, p).length;
    };

    Posn.prototype.perpendicularDistanceFrom = function(ls) {
      var inter, len, ray;
      ray = this.verti(1e5);
      ray.rotate(ls.angle360() + 90, this);
      inter = ray.intersection(ls);
      if (inter != null) {
        ls = new LineSegment(this, inter);
        len = ls.length;
        return [len, inter, ls];
      } else {
        return null;
      }
    };

    Posn.prototype.multiplyBy = function(s) {
      var np;
      switch (typeof s) {
        case 'number':
          np = this.clone();
          np.x *= s;
          np.y *= s;
          return np;
        case 'object':
          np = this.clone();
          np.x *= s.x;
          np.y *= s.y;
          return np;
      }
    };

    Posn.prototype.multiplyByMutable = function(s) {
      this.x *= s;
      this.y *= s;
      if (this.x2 != null) {
        this.x2 *= s;
        this.y2 *= s;
      }
      if (this.x3 != null) {
        this.x3 *= s;
        return this.y3 *= s;
      }
    };

    Posn.prototype.add = function(s) {
      switch (typeof s) {
        case 'number':
          return new Posn(this.x + s, this.y + s);
        case 'object':
          return new Posn(this.x + s.x, this.y + s.y);
      }
    };

    Posn.prototype.subtract = function(s) {
      switch (typeof s) {
        case 'number':
          return new Posn(this.x - s, this.y - s);
        case 'object':
          return new Posn(this.x - s.x, this.y - s.y);
      }
    };

    Posn.prototype.setPrec = function(prec) {
      this.prec = prec;
    };

    Posn.prototype.setSucc = function(succ) {
      this.succ = succ;
    };

    /*
        I love you artur
        hackerkate nows the sick code
    */


    Posn.prototype.inRanges = function(xr, yr) {
      return xr.contains(this.x && yr.contains(this.y));
    };

    Posn.prototype.inRangesInclusive = function(xr, yr) {
      return xr.containsInclusive(this.x) && yr.containsInclusive(this.y);
    };

    Posn.prototype.verti = function(ln) {
      return new LineSegment(this.clone().nudge(0, -ln), this.clone().nudge(0, ln));
    };

    Posn.prototype.insideOf = function(shape) {
      var counter, ray;
      if (shape instanceof Polygon || shape instanceof Path) {
        ray = new LineSegment(this, new Posn(this.x + 1e+20, this.y));
        counter = 0;
        shape.lineSegments().map(function(a) {
          var inter;
          inter = a.intersection(ray);
          if (inter instanceof Posn) {
            return ++counter;
          } else if (inter instanceof Array) {
            return counter += inter.length;
          }
        });
        return counter % 2 === 1;
      }
      if (shape instanceof Rect) {
        return shape.contains(this);
      }
    };

    Posn.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Posn.prototype.within = function(tolerance, posn) {
      return Math.abs(this.x - posn.x) < tolerance && Math.abs(this.y - posn.y) < tolerance;
    };

    Posn.prototype.parseInt = function() {
      this.x = parseInt(this.x, 10);
      return this.y = parseInt(this.y, 10);
    };

    return Posn;

  })();

  Posn.fromJSON = function(json) {
    return new Posn(json.x, json.y);
  };

  /*
  
    Point
  
  
  
       o -----------
      /
     /
    /
  
    Tangible body for posn.
    Stored in PointsList for every shape.
    Comes in many flavors for a Path:
      MoveTo
      LineTo
      HorizTo
      VertiTo
      CurvePoint
        CurveTo
        SmoothTo
  
    This is the most heavily sub-classed class, even heavier than Monsvg.
    It's also the most heavily used, since all shapes are made of many of these.
  
    Needless to say, this is a very important class.
    Its efficiency basically decides the entire application's speed.
    (Not sure it's as good as it could be right now)
  */


  Point = (function(_super) {
    __extends(Point, _super);

    function Point(x, y, owner) {
      var p, prec;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.constructArgs = arguments;
      if ((this.x == null) && (this.y == null)) {
        return;
      }
      if (this.x instanceof Posn) {
        this.owner = this.y;
        this.y = this.x.y;
        this.x = this.x.x;
      } else if (this.x instanceof Object) {
        this.owner = this.y;
        if (this.x.clientX != null) {
          this.y = this.x.clientY;
          this.x = this.x.clientX;
        } else if ((this.x.x != null) && (this.x.y != null)) {
          this.y = this.x.y;
          this.x = this.x.x;
        }
      } else if (typeof this.x === "string") {
        if (this.owner != null) {
          prec = this.owner;
        }
        if (this.y != null) {
          this.owner = this.y;
        }
        p = this.fromString(this.x, prec);
        return p;
      }
      if (isNaN(this.x)) {
        console.warn('NaN x');
      }
      if (isNaN(this.y)) {
        console.warn('NaN y');
      }
      this._flags = [];
      this.makeAntlers();
      Point.__super__.constructor.call(this, this.x, this.y);
    }

    Point.prototype.fromString = function(point, prec) {
      var classes, clen, constructed, coords, elen, i, key, lengths, matched, pairs, patterns, points, relative, set, sliceAt, val, values, _i, _ref;
      patterns = {
        moveTo: /M[^A-Za-z]+/gi,
        lineTo: /L[^A-Za-z]+/gi,
        curveTo: /C[^A-Za-z]+/gi,
        smoothTo: /S[^A-Za-z]+/gi,
        horizTo: /H[^A-Za-z]+/gi,
        vertiTo: /V[^A-Za-z]+/gi
      };
      classes = {
        moveTo: MoveTo,
        lineTo: LineTo,
        curveTo: CurveTo,
        smoothTo: SmoothTo,
        horizTo: HorizTo,
        vertiTo: VertiTo
      };
      lengths = {
        moveTo: 2,
        lineTo: 2,
        curveTo: 6,
        smoothTo: 4,
        horizTo: 1,
        vertiTo: 1
      };
      pairs = /[-+]?\d*\.?\d*(e\-)?\d*/g;
      points = [];
      for (key in patterns) {
        val = patterns[key];
        matched = point.match(val);
        if (matched !== null) {
          coords = (point.match(pairs)).filter(function(p) {
            return p.length > 0;
          }).map(parseFloat);
          relative = point.substring(0, 1).match(/[mlcshv]/) !== null;
          clen = coords.length;
          elen = lengths[key];
          if (clen % elen === 0) {
            sliceAt = 0;
            for (i = _i = 0, _ref = (clen / elen) - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              set = coords.slice(sliceAt, sliceAt + elen);
              if (i > 0) {
                if (key === "moveTo") {
                  key = "lineTo";
                }
              }
              values = [null].concat(set);
              values.push(this.owner);
              values.push(prec);
              values.push(relative);
              if (values.join(' ').mentions("NaN")) {
                debugger;
              }
              constructed = new (Function.prototype.bind.apply(classes[key], values));
              points.push(constructed);
              sliceAt += elen;
            }
          } else {
            throw new Error("Wrong amount of coordinates: " + point + ". Expected " + elen + " and got " + clen + ".");
          }
          break;
        }
      }
      if (points.length === 0) {
        throw new Error("Unreadable path value: " + point);
      }
      if (points.length === 1) {
        return points[0];
      } else {
        return points;
      }
    };

    Point.prototype.select = function() {
      this.show();
      this.showHandles();
      this.antlers.refresh();
      this.baseHandle.setAttribute('selected', '');
      return this;
    };

    Point.prototype.deselect = function() {
      this.baseHandle.removeAttribute('selected');
      if (typeof this.hideHandles === "function") {
        this.hideHandles();
      }
      this.hide();
      return this;
    };

    Point.prototype.draw = function() {
      var _ref;
      this.$baseHandle = $('<div class="transform handle point"></div>');
      this.baseHandle = this.$baseHandle[0];
      if (this.at === void 0) {
        if (!(this instanceof AntlerPoint)) {
          debugger;
        }
      }
      this.baseHandle.setAttribute('at', this.at);
      if (this.owner != null) {
        this.baseHandle.setAttribute('owner', this.owner.metadata.uuid);
      }
      this.updateHandle(this.baseHandle, this.x, this.y);
      if ((_ref = dom.ui) != null) {
        _ref.appendChild(this.baseHandle);
      }
      return this;
    };

    Point.prototype.makeAntlers = function() {
      var p2, p3;
      if (this.succ != null) {
        p2 = this.succ.p2 != null ? this.succ.p2() : void 0;
      } else {
        p2 = null;
      }
      p3 = this.p3 != null ? this.p3() : null;
      this.antlers = new Antlers(this, p3, p2);
      return this;
    };

    Point.prototype.showHandles = function() {
      return this.antlers.show();
    };

    Point.prototype.hideHandles = function() {
      return this.antlers.hide();
    };

    Point.prototype.absoluteCached = void 0;

    Point.prototype.prec = null;

    Point.prototype.succ = null;

    Point.prototype.actionHint = function() {
      return this.baseHandle.setAttribute('action', '');
    };

    Point.prototype.hideActionHint = function() {
      return this.baseHandle.removeAttribute('action');
    };

    Point.prototype.updateHandle = function(handle, x, y) {
      if (handle == null) {
        handle = this.baseHandle;
      }
      if (x == null) {
        x = this.x;
      }
      if (y == null) {
        y = this.y;
      }
      if (handle === void 0) {
        return;
      }
      handle.style.left = x * ui.canvas.zoom;
      handle.style.top = y * ui.canvas.zoom;
      return this;
    };

    Point.prototype.inheritPosition = function(from) {
      this.at = from.at;
      this.prec = from.prec;
      this.succ = from.succ;
      this.prec.succ = this;
      this.succ.prec = this;
      this.owner = from.owner;
      if (from.baseHandle != null) {
        this.baseHandle = from.baseHandle;
      }
      return this;
    };

    Point.prototype.nudge = function(x, y, checkForFirstOrLast) {
      var old, _ref;
      if (checkForFirstOrLast == null) {
        checkForFirstOrLast = true;
      }
      old = this.clone();
      Point.__super__.nudge.call(this, x, y);
      if ((_ref = this.antlers) != null) {
        _ref.nudge(x, y);
      }
      this.updateHandle();
      if (this.owner.type === 'path') {
        if (checkForFirstOrLast && this.owner.points.closed) {
          if ((this === this.owner.points.first) && this.owner.points.last.equal(old)) {
            return this.owner.points.last.nudge(x, y, false);
          } else if ((this === this.owner.points.last) && this.owner.points.first.equal(old)) {
            return this.owner.points.first.nudge(x, y, false);
          }
        }
      }
    };

    Point.prototype.rotate = function(a, origin) {
      var _ref;
      Point.__super__.rotate.call(this, a, origin);
      if ((_ref = this.antlers) != null) {
        _ref.rotate(a, origin);
      }
      return this.updateHandle();
    };

    Point.prototype.scale = function(x, y, origin, angle) {
      var _ref;
      Point.__super__.scale.call(this, x, y, origin, angle);
      if ((_ref = this.antlers) != null) {
        _ref.scale(x, y, origin, angle);
      }
      this.updateHandle();
      return this;
    };

    Point.prototype.replaceWith = function(point) {
      return this.owner.points.replace(this, point);
    };

    Point.prototype.toPosn = function() {
      return new Posn(this.x, this.y);
    };

    Point.prototype.toLineSegment = function() {
      return new LineSegment(this.prec, this);
    };

    /*
    
      Linked list action
    */


    Point.prototype.setSucc = function(succ) {
      this.succ = succ;
      return succ.prec = this;
    };

    Point.prototype.setPrec = function(prec) {
      return prec.setSucc(this);
    };

    /*
    
     Visibility functions for the UI
    */


    Point.prototype.show = function() {
      if (this.baseHandle == null) {
        return;
      }
      if (!this.baseHandle) {
        this.draw();
      }
      this.baseHandle.style.display = 'block';
      return this.baseHandle.style.opacity = 1;
    };

    Point.prototype.hide = function(force) {
      if (force == null) {
        force = false;
      }
      if (this.baseHandle == null) {
        return;
      }
      if (!this.baseHandle.hasAttribute('selected') || force) {
        this.baseHandle.style.opacity = 0;
        this.baseHandle.removeAttribute('action');
        this.hideHandles();
        return this.unhover();
      }
    };

    Point.prototype.hover = function() {
      var _ref;
      if ((_ref = this.baseHandle) != null) {
        _ref.setAttribute('hover', '');
      }
      if (this.baseHandle == null) {
        console.log("base handle missing");
      }
      if (this.at === 0) {
        return this.owner.points.last.baseHandle.setAttribute('hover', '');
      } else if (this === this.owner.points.last) {
        return this.owner.points.first.baseHandle.setAttribute('hover', '');
      }
    };

    Point.prototype.unhover = function() {
      var _ref;
      return (_ref = this.baseHandle) != null ? _ref.removeAttribute('hover') : void 0;
    };

    Point.prototype.clear = function() {
      this.baseHandle.style.display = 'none';
      return this;
    };

    Point.prototype.unclear = function() {
      this.baseHandle.style.display = 'block';
      return this;
    };

    Point.prototype.remove = function() {
      var _ref, _ref1;
      if ((_ref = this.antlers) != null) {
        _ref.hide();
      }
      return (_ref1 = this.baseHandle) != null ? _ref1.remove() : void 0;
    };

    Point.prototype.toStringWithZoom = function() {
      var str;
      this.multiplyByMutable(ui.canvas.zoom);
      str = this.toString();
      this.multiplyByMutable(1 / ui.canvas.zoom);
      return str;
    };

    Point.prototype.flag = function(flag) {
      return this._flags.ensure(flag);
    };

    Point.prototype.unflag = function(flag) {
      return this._flags.remove(flag);
    };

    Point.prototype.flagged = function(flag) {
      return this._flags.has(flag);
    };

    Point.prototype.annotate = function(color, radius) {
      return ui.annotations.drawDot(this, color, radius);
    };

    return Point;

  })(Posn);

  /*
  
    Polynomial
  */


  Polynomial = (function() {
    function Polynomial(coefs) {
      var i, l, v, _ref;
      this.coefs = coefs;
      l = this.coefs.length;
      _ref = this.coefs;
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        v = _ref[i];
        this["p" + (l - i - 1)] = v;
      }
      this.coefs = this.coefs.reverse();
      this;
    }

    Polynomial.prototype.tolerance = 1e-6;

    Polynomial.prototype.accuracy = 6;

    Polynomial.prototype.degrees = function() {
      return this.coefs.length - 1;
    };

    Polynomial.prototype.interpolate = function(xs, xy, n, offset, x) {
      var c, d, den, diff, dift, dy, ho, hp, i, ns, result, w, y, _i, _j, _k, _ref, _ref1, _ref2;
      y = 0;
      dy = 0;
      ns = 0;
      c = [n];
      d = [n];
      diff = Math.abs(x - xs[offset]);
      for (i = _i = 0, _ref = n + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        dift = Math.abs(x - xs[offset + i]);
        if (dift < diff) {
          ns = i;
          diff = dift;
        }
        c[i] = d[i] = ys[offset + i];
      }
      y = ys[offset + ns];
      ns -= 1;
      for (i = _j = 1, _ref1 = m + 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        for (i = _k = 0, _ref2 = n - m + 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          ho = xs[offset + i] - x;
          hp = xs[offset + i + m] - x;
          w = c[i + 1] - d[i];
          den = ho - hp;
          if (den === 0.0) {
            result = {
              y: 0,
              dy: 0
            };
            break;
          }
          den = w / den;
          d[i] = hp * den;
          c[i] = ho * den;
        }
        dy = 2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns -= 1];
        y += dy;
      }
      return {
        y: y,
        dy: dy
      };
    };

    Polynomial.prototype["eval"] = function(x) {
      var i, result, _i, _ref;
      result = 0;
      for (i = _i = _ref = this.coefs.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        result = result * x + this.coefs[i];
      }
      return result;
    };

    Polynomial.prototype.add = function(that) {
      var d1, d2, dmax, i, newCoefs, v1, v2, _i;
      newCoefs = [];
      d1 = this.degrees();
      d2 = that.degrees();
      dmax = Math.max(d1, d2);
      for (i = _i = 0; 0 <= dmax ? _i <= dmax : _i >= dmax; i = 0 <= dmax ? ++_i : --_i) {
        v1 = i <= d1 ? this.coefs[i] : 0;
        v2 = i <= d2 ? that.coefs[i] : 0;
        newCoefs[i] = v1 + v2;
      }
      newCoefs = newCoefs.reverse();
      return new Polynomial(newCoefs);
    };

    Polynomial.prototype.roots = function() {
      switch (this.coefs.length - 1) {
        case 0:
          return [];
        case 1:
          return this.linearRoot();
        case 2:
          return this.quadraticRoots();
        case 3:
          return this.cubicRoots();
        case 4:
          return this.quarticRoots();
        default:
          return [];
      }
    };

    Polynomial.prototype.derivative = function() {
      var i, newCoefs, _i, _ref;
      newCoefs = [];
      for (i = _i = 1, _ref = this.degrees(); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        newCoefs.push(i * this.coefs[i]);
      }
      return new Polynomial(newCoefs.reverse());
    };

    Polynomial.prototype.bisection = function(min, max) {
      var i, iters, maxValue, minValue, result, tmp1, tmp2, value, _i, _ref;
      minValue = this["eval"](min);
      maxValue = this["eval"](max);
      if (Math.abs(minValue) <= this.tolerance) {
        return min;
      } else if (Math.abs(maxValue) <= this.tolerance) {
        return max;
      } else if (minValue * maxValue <= 0) {
        tmp1 = Math.log(max - min);
        tmp2 = Math.LN10 * this.accuracy;
        iters = Math.ceil((tmp1 + tmp2) / Math.LN2);
        for (i = _i = 0, _ref = iters - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          result = 0.5 * (min + max);
          value = this["eval"](result);
          if (Math.abs(value) <= this.tolerance) {
            break;
          }
          if (value * minValue < 0) {
            max = result;
            maxValue = value;
          } else {
            min = result;
            minValue = value;
          }
        }
      }
      return result;
    };

    Polynomial.prototype.rootsInterval = function(min, max) {
      var deriv, dlen, droots, i, r, results, root, _i, _ref;
      results = [];
      if (this.degrees() === 1) {
        root = this.bisection(min, max);
        if (root != null) {
          results.push(root);
        }
      } else {
        deriv = this.derivative();
        droots = deriv.rootsInterval(min, max);
        dlen = droots.length;
        if (dlen > 0) {
          root = this.bisection(min, droots[0]);
          if (root != null) {
            results.push(root);
          }
          for (i = _i = 0, _ref = dlen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            r = droots[i];
            root = this.bisection(r, droots[i + 1]);
            if (root != null) {
              results.push(root);
            }
          }
          root = this.bisection(droots[dlen - 1], max);
          if (root != null) {
            results.push(root);
          }
        } else {
          root = this.bisection(min, max);
          if (root != null) {
            results.push(root);
          }
        }
      }
      return results;
    };

    Polynomial.prototype.linearRoot = function() {
      var result;
      result = [];
      if (this.p1 !== 0) {
        result.push(-this.p0 / this.p1);
      }
      return result;
    };

    Polynomial.prototype.quadraticRoots = function() {
      var a, b, c, d, e, results;
      results = [];
      a = this.p2;
      b = this.p1 / a;
      c = this.p0 / a;
      d = b * b - 4 * c;
      if (d > 0) {
        e = Math.sqrt(d);
        results.push(0.5 * (-b + e));
        results.push(0.5 * (-b - e));
      } else if (d === 0) {
        results.push(0.5 * -b);
      }
      return results;
    };

    Polynomial.prototype.cubicRoots = function() {
      var a, angle, b, c0, c1, c2, c3, cos, discrim, distance, e, halfB, offset, results, root, sin, sqrt3, tmp;
      results = [];
      c3 = this.p3;
      c2 = this.p2 / c3;
      c1 = this.p1 / c3;
      c0 = this.p0 / c3;
      a = (3 * c1 - c2 * c2) / 3;
      b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;
      offset = c2 / 3;
      discrim = b * b / 4 + a * a * a / 27;
      halfB = b / 2;
      if ((Math.abs(discrim)) <= 1e-6) {
        discrim = 0;
      }
      if (discrim > 0) {
        e = Math.sqrt(discrim);
        tmp = -halfB + e;
        root = tmp >= 0 ? Math.pow(tmp, 1 / 3) : -Math.pow(-tmp, 1 / 3);
        tmp = -halfB - e;
        root += tmp >= 0 ? Math.pow(tmp, 1 / 3) : -Math.pow(-tmp, 1 / 3);
        results.push(root - offset);
      } else if (discrim < 0) {
        distance = Math.sqrt(-a / 3);
        angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        sqrt3 = Math.sqrt(3);
        results.push(2 * distance * cos - offset);
        results.push(-distance * (cos + sqrt3 * sin) - offset);
        results.push(-distance * (cos - sqrt3 * sin) - offset);
      } else {
        if (halfB >= 0) {
          tmp = -Math.pow(halfB, 1 / 3);
        } else {
          tmp = Math.pow(-halfB, 1 / 3);
        }
        results.push(2 * tmp - offset);
        results.push(-tmp - offset);
      }
      return results;
    };

    return Polynomial;

  })();

  Range = (function() {
    function Range(min, max) {
      this.min = min;
      this.max = max;
    }

    Range.prototype.length = function() {
      return this.max - this.min;
    };

    Range.prototype.contains = function(n) {
      return n > this.min && n < this.max;
    };

    Range.prototype.containsInclusive = function(n, tolerance) {
      if (tolerance == null) {
        tolerance = 0;
      }
      return n >= this.min - tolerance && n <= this.max + tolerance;
    };

    Range.prototype.intersects = function(n) {
      return n === this.min || n === this.max;
    };

    Range.prototype.fromList = function(alon) {
      this.min = Math.min.apply(this, alon);
      this.max = Math.max.apply(this, alon);
      return this;
    };

    Range.prototype.fromRangeList = function(alor) {
      var maxs, mins;
      mins = alor.map(function(r) {
        return r.min;
      });
      maxs = alor.map(function(r) {
        return r.max;
      });
      this.min = Math.min.apply(this, mins);
      this.max = Math.max.apply(this, maxs);
      return this;
    };

    Range.prototype.nudge = function(amt) {
      this.min += amt;
      return this.max += amt;
    };

    Range.prototype.scale = function(amt, origin) {
      this.min += (this.min - origin) * (amt - 1);
      return this.max += (this.max - origin) * (amt - 1);
    };

    Range.prototype.toString = function() {
      return "[" + (this.min.places(4)) + "," + (this.max.places(4)) + "]";
    };

    Range.prototype.percentageOfValue = function(v) {
      return (v - this.min) / this.length();
    };

    return Range;

  })();

  Bounds = (function() {
    function Bounds(x, y, width, height) {
      var minX;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      if (this.x instanceof Array) {
        minX = Math.min.apply(this, this.x.map(function(b) {
          return b.x;
        }));
        this.y = Math.min.apply(this, this.x.map(function(b) {
          return b.y;
        }));
        this.x2 = Math.max.apply(this, this.x.map(function(b) {
          return b.x2;
        }));
        this.y2 = Math.max.apply(this, this.x.map(function(b) {
          return b.y2;
        }));
        this.x = minX;
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
      } else if (this.x instanceof Posn && this.y instanceof Posn) {
        x = Math.min(this.x.x, this.y.x);
        y = Math.min(this.x.y, this.y.y);
        this.x2 = Math.max(this.x.x, this.y.x);
        this.y2 = Math.max(this.x.y, this.y.y);
        this.x = x;
        this.y = y;
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
      } else {
        this.x2 = this.x + this.width;
        this.y2 = this.y + this.height;
      }
      this.xr = new Range(this.x, this.x + this.width);
      this.yr = new Range(this.y, this.y + this.height);
    }

    Bounds.prototype.tl = function() {
      return new Posn(this.x, this.y);
    };

    Bounds.prototype.tr = function() {
      return new Posn(this.x2, this.y);
    };

    Bounds.prototype.br = function() {
      return new Posn(this.x2, this.y2);
    };

    Bounds.prototype.bl = function() {
      return new Posn(this.x, this.y2);
    };

    Bounds.prototype.clone = function() {
      return new Bounds(this.x, this.y, this.width, this.height);
    };

    Bounds.prototype.toRect = function() {
      return new Rect({
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      });
    };

    Bounds.prototype.center = function() {
      return new Posn(this.x + (this.width / 2), this.y + (this.height / 2));
    };

    Bounds.prototype.points = function() {
      return [new Posn(this.x, this.y), new Posn(this.x2, this.y), new Posn(this.x2, this.y2), new Posn(this.x, this.y2)];
    };

    Bounds.prototype.contains = function(posn, tolerance) {
      return this.xr.containsInclusive(posn.x, tolerance) && this.yr.containsInclusive(posn.y, tolerance);
    };

    Bounds.prototype.overlapsBounds = function(other, recur) {
      if (recur == null) {
        recur = true;
      }
      return this.toRect().overlaps(other.toRect());
    };

    Bounds.prototype.nudge = function(x, y) {
      this.x += x;
      this.x2 += x;
      this.y += y;
      this.y2 += y;
      this.xr.nudge(x);
      return this.yr.nudge(y);
    };

    Bounds.prototype.scale = function(x, y, origin) {
      var br, tl;
      tl = new Posn(this.x, this.y);
      br = new Posn(this.x2, this.y2);
      tl.scale(x, y, origin);
      br.scale(x, y, origin);
      this.x = tl.x;
      this.y = tl.y;
      this.x2 = br.x;
      this.y2 = br.y;
      this.width *= x;
      this.height *= y;
      this.xr.scale(x, origin);
      this.yr.scale(y, origin);
      return this;
    };

    Bounds.prototype.squareSmaller = function(anchor) {
      if (this.width < this.height) {
        return this.height = this.width;
      } else {
        return this.width = this.height;
      }
    };

    Bounds.prototype.centerOn = function(posn) {
      var offset;
      offset = posn.subtract(this.center());
      return this.nudge(offset.x, offset.y);
    };

    Bounds.prototype.fitTo = function(bounds) {
      var sh, sm, sw;
      sw = this.width / bounds.width;
      sh = this.height / bounds.height;
      sm = Math.max(sw, sh);
      return new Bounds(0, 0, this.width / sm, this.height / sm);
    };

    Bounds.prototype.adjustElemsTo = function(bounds) {
      var offset, sh, sw;
      offset = this.tl().subtract(bounds.tl());
      sw = this.width / bounds.width;
      sh = this.height / bounds.height;
      return function(elem) {
        elem.scale(1 / sw, 1 / sh, bounds.tl());
        return elem.nudge(-offset.x, offset.y);
      };
    };

    Bounds.prototype.annotateCorners = function() {
      ui.annotations.drawDot(this.tl());
      ui.annotations.drawDot(this.tr());
      ui.annotations.drawDot(this.bl());
      return ui.annotations.drawDot(this.br());
    };

    return Bounds;

  })();

  /*
  
    Antlers
  
       \
          \ O  -  (succx, succy)
            \\
              \
               \
                o
                 \
                  \
                  \\
                  \ O  -  (basex, basey)
                  |
                  |
                 /
                /
  
  
    Control handles for any vector Point. Edits base's x3 and base's succ's p2
    Each CurvePoint gets one of these. It keeps track of coordinates locally so we can
    draw these pre-emptively. For example, if you take the Pen tool and just drag a curve point right away,
    those curves don't exist yet but they come into play as soon as you add another point
    (...which will have to be a CurvePoint even if it's a static click)
  
    This class handles the GUI and updating the base and its succ's x2 y2 x3 y3. :)
  */


  Antlers = (function() {
    function Antlers(base, basep3, succp2) {
      var diff;
      this.base = base;
      this.basep3 = basep3;
      this.succp2 = succp2;
      if ((this.basep3 != null) && (this.succp2 != null)) {
        diff = Math.abs(this.basep3.angle360(this.base) - this.succp2.angle360(this.base));
        this.lockAngle = diff.within(this.angleLockThreshold, 180);
      } else {
        this.lockAngle = false;
      }
      this;
    }

    Antlers.prototype.angleLockThreshold = 0.5;

    Antlers.prototype.commit = function() {
      if (this.basep3 != null) {
        this.base.x3 = this.basep3.x;
        this.base.y3 = this.basep3.y;
      }
      if ((this.succp2 != null) && this.succ()) {
        this.succ().x2 = this.succp2.x;
        this.succ().y2 = this.succp2.y;
      }
      return this;
    };

    Antlers.prototype.importNewSuccp2 = function(succp2) {
      this.succp2 = succp2;
      if (this.succp2 != null) {
        this.basep3 = this.succp2.reflect(this.base);
      }
      return this.commit().refresh();
    };

    Antlers.prototype.killSuccp2 = function() {
      this.succp2 = new Posn(this.base.x, this.base.y);
      return this.commit().refresh();
    };

    Antlers.prototype.succ = function() {
      return this.base.succ;
    };

    Antlers.prototype.refresh = function() {
      if (!this.visible) {
        return;
      }
      return this.hide().show();
    };

    Antlers.prototype.visible = false;

    Antlers.prototype.show = function() {
      var _this = this;
      this.hide();
      this.visible = true;
      if (this.basep3 != null) {
        this.basep = new AntlerPoint(this.basep3.x, this.basep3.y, this.base.owner, this, -1);
      }
      if (this.succp2 != null) {
        this.succp = new AntlerPoint(this.succp2.x, this.succp2.y, this.base.owner, this, 1);
      }
      return (function() {
        return _this.hide();
      });
    };

    Antlers.prototype.hide = function() {
      var _ref, _ref1, _ref2;
      this.visible = false;
      if ((_ref = this.basep) != null) {
        _ref.remove();
      }
      if ((_ref1 = this.succp) != null) {
        _ref1.remove();
      }
      if ((_ref2 = this.base.owner.antlerPoints) != null) {
        _ref2.remove([this.basep, this.succp]);
      }
      return this;
    };

    Antlers.prototype.redraw = function() {
      this.hide();
      this.show();
      return this;
    };

    Antlers.prototype.hideTemp = function(p) {
      var _ref;
      return (_ref = (p === 2 ? this.succp : this.basep)) != null ? _ref.hideTemp() : void 0;
    };

    Antlers.prototype.nudge = function(x, y) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.nudge(x, y);
      }
      if ((_ref1 = this.succp2) != null) {
        _ref1.nudge(x, y);
      }
      if (this.succ() instanceof CurvePoint) {
        this.succ().x2 += x;
        this.succ().y2 -= y;
      }
      return this.commit();
    };

    Antlers.prototype.scale = function(x, y, origin) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.scale(x, y, origin);
      }
      return (_ref1 = this.succp2) != null ? _ref1.scale(x, y, origin) : void 0;
    };

    Antlers.prototype.rotate = function(a, origin) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.rotate(a, origin);
      }
      if ((_ref1 = this.succp2) != null) {
        _ref1.rotate(a, origin);
      }
      return this;
    };

    Antlers.prototype.other = function(p) {
      if (p === this.succp) {
        return this.basep;
      } else {
        return this.succp;
      }
    };

    Antlers.prototype.angleDiff = function(a, b) {
      var x;
      x = a - b;
      if (x < 0) {
        x += 360;
      }
      return x;
    };

    Antlers.prototype.flatten = function() {
      var ahead, angleBasep3, angleSuccp2, compensate, p2p3d, p3p2d;
      if ((this.succp2 == null) || (this.basep3 == null)) {
        return;
      }
      angleSuccp2 = this.succp2.angle360(this.base);
      angleBasep3 = this.basep3.angle360(this.base);
      p2p3d = this.angleDiff(angleSuccp2, angleBasep3);
      p3p2d = this.angleDiff(angleBasep3, angleSuccp2);
      if (p2p3d < p3p2d) {
        ahead = "p2";
      } else {
        ahead = "p3";
      }
      if (ahead === "p2") {
        if (p2p3d < 180) {
          compensate = (180 - p2p3d) / 2;
          this.succp2 = this.succp2.rotate(compensate, this.base);
          return this.basep3 = this.basep3.rotate(-compensate, this.base);
        }
      } else {
        if (p3p2d < 180) {
          compensate = (180 - p3p2d) / 2;
          this.succp2 = this.succp2.rotate(-compensate, this.base);
          return this.basep3 = this.basep3.rotate(compensate, this.base);
        }
      }
    };

    return Antlers;

  })();

  AntlerPoint = (function(_super) {
    __extends(AntlerPoint, _super);

    function AntlerPoint(x, y, owner, family, role) {
      var _ref;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.family = family;
      this.role = role;
      AntlerPoint.__super__.constructor.call(this, this.x, this.y, this.owner);
      this.draw();
      this.baseHandle.className += ' bz-ctrl';
      this.line = ui.annotations.drawLine(this.zoomedc(), this.family.base.zoomedc());
      if ((_ref = this.owner.antlerPoints) != null) {
        _ref.push(this);
      }
    }

    AntlerPoint.prototype.succ = function() {
      return this.family.base.succ;
    };

    AntlerPoint.prototype.base = function() {
      return this.family.base;
    };

    AntlerPoint.prototype.hideTemp = function() {
      var _this = this;
      this.line.rep.style.display = 'none';
      this.baseHandle.style.display = 'none';
      return function() {
        _this.line.rep.style.display = 'block';
        return _this.baseHandle.style.display = 'block';
      };
    };

    AntlerPoint.prototype.remove = function() {
      this.line.remove();
      return AntlerPoint.__super__.remove.apply(this, arguments);
    };

    AntlerPoint.prototype.nudge = function(x, y) {
      var newangle, oldangle, s, _ref;
      if (!this.family.lockAngle) {
        AntlerPoint.__super__.nudge.call(this, x, y);
        this.persist();
      } else {
        oldangle = this.angle360(this.family.base);
        AntlerPoint.__super__.nudge.call(this, x, y);
        newangle = this.angle360(this.family.base);
        if ((_ref = this.family.other(this)) != null) {
          _ref.rotate(newangle - oldangle, this.family.base);
        }
        this.persist();
      }
      if (this.role === -1 && this.family.base.succ instanceof SmoothTo) {
        s = this.family.base.succ;
        return s.replaceWith(s.toCurveTo());
      }
    };

    AntlerPoint.prototype.scale = function(x, y, origin) {
      AntlerPoint.__super__.scale.call(this, x, y, origin);
      return this.persist();
    };

    AntlerPoint.prototype.rotate = function(a, origin) {
      AntlerPoint.__super__.rotate.call(this, a, origin);
      return this.persist();
    };

    AntlerPoint.prototype.persist = function() {
      var first;
      if (this.role === -1) {
        this.family.basep3.copy(this);
      }
      if (this.role === 1) {
        this.family.succp2.copy(this);
      }
      if (this.family.base === this.owner.points.last) {
        first = this.owner.points.first;
        if (this.family.base.equal(first)) {
          first.antlers.succp2 = this.family.succp2.clone();
          first.antlers.basep3 = this.family.basep3.clone();
          first.antlers.commit();
        }
      }
      this.line.absorbA(this.family.base.zoomedc());
      this.line.absorbB(this.zoomedc());
      this.line.commit();
      return this.family.commit();
    };

    return AntlerPoint;

  })(Point);

  /*
  
    Path points
  
    MoveTo
      Mx,y
      Begin a path at x,y
  
    LineTo
      Lx,y
      Draw straight line from pvx,pvy to x,y
  
    CurveTo
      Cx1,y1 x2,y2 x,y
      Draw a line to x,y.
      x1,y1 is the control point put on the previous point
      x2,y2 is the control point put on this point (x,y)
  
    SmoothTo
      Sx2,y2 x,y
      Shorthand for curveto. x1,y1 becomes x2,y2 from previous CurveTo.
  
    HorizTo
      Hx
      Draw a horizontal line inheriting the y-value from precessor
  
    VertiTo
      Vy
      Draw a vertical line inheriting the x-value from precessor
  */


  MoveTo = (function(_super) {
    __extends(MoveTo, _super);

    function MoveTo(x, y, owner, prec, rel) {
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      MoveTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    MoveTo.prototype.relative = function() {
      var m, precAbs, x, y;
      if (this.at === 0) {
        this.rel = false;
        return this;
      } else {
        if (this.rel) {
          return this;
        }
        precAbs = this.prec.absolute();
        x = precAbs.x;
        y = precAbs.y;
        m = new MoveTo(this.x - x, this.y - y, this.owner);
        m.rel = true;
        return m;
      }
    };

    MoveTo.prototype.absolute = function() {
      var m, point, precAbs, x, y, _i, _len, _ref, _results;
      if (this.at === 0) {
        this.rel = false;
        return this;
      } else {
        if (!this.rel) {
          return this;
        }
        precAbs = this.prec.absolute();
        x = precAbs.x;
        y = precAbs.y;
        m = new MoveTo(this.x + x, this.y + y, this.owner);
        m.rel = false;
        return m;
      }
      _ref = points.match(/[MLCSHV][\-\de\.\,\-\s]+/gi);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        _results.push(new Point(point, this.owner));
      }
      return _results;
    };

    MoveTo.prototype.p2 = function() {
      var _ref;
      if (((_ref = this.antlers) != null ? _ref.succp2 : void 0) != null) {
        return new Posn(this.antlers.succp2.x, this.antlers.succp2.y);
      } else {
        return null;
      }
    };

    MoveTo.prototype.toString = function() {
      return "" + (this.rel ? "m" : "M") + this.x + "," + this.y;
    };

    MoveTo.prototype.toLineSegment = function() {
      return this.prec.toLineSegment();
    };

    MoveTo.prototype.clone = function() {
      return new MoveTo(this.x, this.y, this.owner, this.prec, this.rel);
    };

    return MoveTo;

  })(Point);

  LineTo = (function(_super) {
    __extends(LineTo, _super);

    function LineTo(x, y, owner, prec, rel) {
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      LineTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    LineTo.prototype.relative = function() {
      var l, precAbs, x, y;
      if (this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      l = new LineTo(this.x - x, this.y - y, this.owner);
      l.rel = true;
      return l;
    };

    LineTo.prototype.absolute = function() {
      var l, precAbs, x, y;
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      l = new LineTo(this.x + x, this.y + y, this.owner);
      l.rel = false;
      this.absoluteCached = l;
      return l;
    };

    LineTo.prototype.toString = function() {
      return "" + (this.rel ? 'l' : 'L') + this.x + "," + this.y;
    };

    LineTo.prototype.clone = function() {
      return new LineTo(this.x, this.y, this.owner, this.prec, this.rel);
    };

    return LineTo;

  })(Point);

  HorizTo = (function(_super) {
    __extends(HorizTo, _super);

    function HorizTo(x, owner, prec, rel) {
      this.x = x;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      HorizTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    HorizTo.prototype.inheritFromPrec = function(prec) {
      this.prec = prec;
      return this.y = this.prec.absolute().y;
    };

    HorizTo.prototype.toString = function() {
      return "" + (this.rel ? 'h' : 'H') + this.x;
    };

    HorizTo.prototype.convertToLineTo = function() {
      var lineTo;
      lineTo = new LineTo(this.x, this.y);
      this.replaceWith(lineTo);
      return lineTo;
    };

    HorizTo.prototype.rotate = function(a, origin) {
      return this.convertToLineTo().rotate(a, origin);
    };

    HorizTo.prototype.absolute = function() {
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      return this.absoluteCached = new HorizTo(this.x + this.prec.absolute().x, this.owner, this.prec, false);
    };

    HorizTo.prototype.relative = function() {
      if (this.rel) {
        return this;
      }
      return new HorizTo(this.x - this.prec.absolute().x, this.owner, this.prec, true);
    };

    HorizTo.prototype.clone = function() {
      return new HorizTo(this.x, this.owner, this.prec, this.rel);
    };

    return HorizTo;

  })(Point);

  VertiTo = (function(_super) {
    __extends(VertiTo, _super);

    function VertiTo(y, owner, prec, rel) {
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      VertiTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    VertiTo.prototype.inheritFromPrec = function(prec) {
      this.prec = prec;
      return this.x = this.prec.absolute().x;
    };

    VertiTo.prototype.toString = function() {
      return "" + (this.rel ? 'v' : 'V') + this.y;
    };

    VertiTo.prototype.convertToLineTo = function() {
      var lineTo;
      lineTo = new LineTo(this.x, this.y);
      this.replaceWith(lineTo);
      return lineTo;
    };

    VertiTo.prototype.rotate = function(a, origin) {
      return this.convertToLineTo().rotate(a, origin);
    };

    VertiTo.prototype.absolute = function() {
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      return this.absoluteCached = new VertiTo(this.y + this.prec.absolute().y, this.owner, this.prec, false);
    };

    VertiTo.prototype.relative = function() {
      if (this.rel) {
        return this;
      }
      return new VertiTo(this.y - this.prec.absolute().y, this.owner, this.prec, true);
    };

    VertiTo.prototype.clone = function() {
      return new VertiTo(this.y, this.owner, this.prec, this.rel);
    };

    return VertiTo;

  })(Point);

  /*
  
    CurvePoint
  
    A Point that has handles. Builds the handles in its constructor.
  */


  CurvePoint = (function(_super) {
    __extends(CurvePoint, _super);

    function CurvePoint(x2, y2, x3, y3, x, y, owner, prec, rel) {
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      /*
      
        This Class just extends into CurveTo and SmoothTo as a way of abstracting out the curve
        handling the control points. It has two control points in addition to the base point (handled by super)
      
        Each point has a predecessor and a successor (in terms of line segments).
      
        It has two control points:
          (@x2, @y2) is the first curve control point (p2), which becomes @p2h
          (@x3, @y3) is the second (p3), which becomes @p3h
        (Refer to ASCII art at top of cubic-bezier-line-segment.coffee for point name reference)
      
        Dragging these mofos will alter the correct control point(s), which will change the curve
      
        I/P:
          x2, y2: control point (p2)
          x3, y3: control point (p3)
          x, y:   next base point (like any other point)
          owner:  elem that owns this shape (supered into Point)
          prec:   point that comes before it
          rel:    bool - true if it's relative or false if it's absolute
      */

      CurvePoint.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    CurvePoint.prototype.p2 = function() {
      return new Posn(this.x2, this.y2);
    };

    CurvePoint.prototype.p3 = function() {
      return new Posn(this.x3, this.y3);
    };

    CurvePoint.prototype.p = function() {
      return new Posn(this.x, this.y);
    };

    CurvePoint.prototype.absorb = function(p, n) {
      this["x" + n] = p.x;
      return this["y" + n] = p.y;
    };

    CurvePoint.prototype.show = function() {
      if (!this.owner) {
        return this;
      }
      return CurvePoint.__super__.show.apply(this, arguments);
    };

    CurvePoint.prototype.cleanUp = function() {
      return;
      this.x2 = cleanUpNumber(this.x2);
      this.y2 = cleanUpNumber(this.y2);
      this.x3 = cleanUpNumber(this.x3);
      this.y3 = cleanUpNumber(this.y3);
      return CurvePoint.__super__.cleanUp.apply(this, arguments);
    };

    CurvePoint.prototype.scale = function(x, y, origin) {
      this.absorb(this.p2().scale(x, y, origin), 2);
      this.absorb(this.p3().scale(x, y, origin), 3);
      return CurvePoint.__super__.scale.call(this, x, y, origin);
    };

    CurvePoint.prototype.rotate = function(a, origin) {
      this.absorb(this.p2().rotate(a, origin), 2);
      this.absorb(this.p3().rotate(a, origin), 3);
      return CurvePoint.__super__.rotate.call(this, a, origin);
    };

    CurvePoint.prototype.relative = function() {
      var args, c, precAbs, x, y;
      if (this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      args = [this.x2 - x, this.y2 - y, this.x3 - x, this.y3 - y, this.x - x, this.y - y, this.owner, this.prec];
      if (this.constructor === SmoothTo) {
        args = args.slice(2);
      }
      args.unshift(null);
      c = new (Function.prototype.bind.apply(this.constructor, args));
      c.rel = true;
      return c;
    };

    CurvePoint.prototype.absolute = function() {
      var args, c, precAbs, x, y;
      if (!this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      args = [this.x2 + x, this.y2 + y, this.x3 + x, this.y3 + y, this.x + x, this.y + y, this.owner, this.prec];
      if (this.constructor === SmoothTo) {
        args = args.slice(2);
      }
      args.unshift(null);
      c = new (Function.prototype.bind.apply(this.constructor, args));
      c.rel = false;
      return c;
    };

    return CurvePoint;

  })(Point);

  CurveTo = (function(_super) {
    __extends(CurveTo, _super);

    function CurveTo(x2, y2, x3, y3, x, y, owner, prec, rel) {
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      CurveTo.__super__.constructor.call(this, this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    }

    CurveTo.prototype.toString = function() {
      return "" + (this.rel ? 'c' : 'C') + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + " " + this.x + "," + this.y;
    };

    CurveTo.prototype.reverse = function() {
      return new CurveTo(this.x3, this.y3, this.x2, this.y2, this.x, this.y, this.owner, this.prec, this.rel).inheritPosition(this);
    };

    CurveTo.prototype.clone = function() {
      return new CurveTo(this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    };

    return CurveTo;

  })(CurvePoint);

  SmoothTo = (function(_super) {
    __extends(SmoothTo, _super);

    function SmoothTo(x3, y3, x, y, owner, prec, rel) {
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      SmoothTo.__super__.constructor.call(this, this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    }

    SmoothTo.prototype.inheritFromPrec = function(prec) {
      var p2, precAbs;
      this.prec = prec;
      if (this.prec instanceof CurvePoint) {
        precAbs = this.prec.absolute();
        p2 = new Posn(precAbs.x3, precAbs.y3).reflect(precAbs);
      } else {
        p2 = new Posn(this.x, this.y);
      }
      this.x2 = p2.x;
      return this.y2 = p2.y;
    };

    SmoothTo.prototype.toCurveTo = function(p2) {
      var ct;
      if (p2 == null) {
        p2 = null;
      }
      if (p2 === null) {
        if (this.prec instanceof CurvePoint) {
          p2 = this.prec.p3().reflect(this.prec.p());
        } else {
          p2 = new Posn(this.x, this.y);
        }
      }
      ct = new CurveTo(p2.x, p2.y, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
      ct.at = this.at;
      return ct;
    };

    SmoothTo.prototype.replaceWithCurveTo = function(p2) {
      if (p2 == null) {
        p2 = null;
      }
      return this.replaceWith(this.toCurveTo(p2));
    };

    SmoothTo.prototype.toString = function() {
      return "" + (this.rel ? 's' : 'S') + this.x3 + "," + this.y3 + " " + this.x + "," + this.y;
    };

    SmoothTo.prototype.reverse = function() {
      return new CurveTo(this.x3, this.y3, this.x2, this.y2, this.x, this.y, this.owner, this.prec, this.rel);
    };

    SmoothTo.prototype.clone = function() {
      return new SmoothTo(this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    };

    return SmoothTo;

  })(CurvePoint);

  /*
  
    PointsList
  
    Stores points, keeps them in order, lets you do shit
    Basically a linked-list.
  */


  PointsList = (function() {
    function PointsList(alop, owner, segments) {
      var accumulatedSegment, commitSegment, ind, lastPoint, point,
        _this = this;
      this.owner = owner;
      this.segments = segments != null ? segments : [];
      if (typeof alop === "string") {
        alop = lab.conversions.stringToAlop(alop, this.owner);
      }
      accumulatedSegment = [];
      lastPoint = void 0;
      commitSegment = function() {
        var sgmt;
        if (accumulatedSegment.length === 0) {
          return;
        }
        sgmt = new PointsSegment(accumulatedSegment, _this);
        _this.lastSegment = sgmt;
        if (_this.firstSegment === null) {
          _this.firstSegment = sgmt;
        }
        _this.segments.push(sgmt);
        return accumulatedSegment = [];
      };
      if (this.segments.length !== 0) {
        this.firstSegment = this.segments[0];
        this.lastSegment = this.segments[this.segments.length - 1];
      }
      if (alop.length === 0) {
        return;
      }
      for (ind in alop) {
        if (!__hasProp.call(alop, ind)) continue;
        point = alop[ind];
        ind = parseInt(ind, 10);
        point.at = ind;
        if (ind === 0) {
          this.first = point;
        }
        if (ind === alop.length - 1) {
          this.last = point;
        }
        point.setPrec((lastPoint != null ? lastPoint : alop[alop.length - 1]));
        if (lastPoint != null) {
          lastPoint.setSucc(point);
        }
        if (point instanceof MoveTo) {
          commitSegment();
        }
        accumulatedSegment.push(point);
        lastPoint = point;
      }
      commitSegment();
      lastPoint.setSucc(this.first);
    }

    PointsList.prototype.first = null;

    PointsList.prototype.last = null;

    PointsList.prototype.firstSegment = null;

    PointsList.prototype.lastSegment = null;

    PointsList.prototype.closed = false;

    PointsList.prototype.moveSegmentToFront = function(segment) {
      if (!(this.segments.has(segment))) {
        return;
      }
      return this.segments = this.segments.cannibalizeUntil(segment);
    };

    PointsList.prototype.movePointToFront = function(point) {
      this.moveSegmentToFront(point.segment);
      return point.segment.movePointToFront(point);
    };

    PointsList.prototype.firstPointThatEquals = function(point) {
      return this.filter(function(p) {
        return p.equal(point);
      })[0];
    };

    PointsList.prototype.closedOnSameSpot = function() {
      return this.closed && (this.last.equal(this.first));
    };

    PointsList.prototype.length = function() {
      return this.segments.reduce(function(a, b) {
        return a + b.points.length;
      }, 0);
    };

    PointsList.prototype.all = function() {
      var pts, s, _i, _len, _ref;
      pts = [];
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        pts = pts.concat(s.points);
      }
      return pts;
    };

    PointsList.prototype.renumber = function() {
      return this.all().map(function(p, i) {
        p.at = i;
        return p;
      });
    };

    PointsList.prototype.pushSegment = function(sgmt) {
      this.lastSegment = sgmt;
      return this.segments.push(sgmt);
    };

    PointsList.prototype.push = function(point, after) {
      if (this.segments.length === 0) {
        this.pushSegment(new PointsSegment([], this));
      }
      point.owner = this.owner;
      if (after == null) {
        point.at = this.lastSegment.points.length;
        this.lastSegment.points.push(point);
        if (this.last != null) {
          this.last.setSucc(point);
          point.setPrec(this.last);
        } else {
          point.setPrec(point);
        }
        if (this.first != null) {
          this.first.setPrec(point);
          point.setSucc(this.first);
        } else {
          point.setSucc(point);
        }
        this.last = point;
        return this;
      }
    };

    PointsList.prototype.replace = function(old, replacement) {
      return this.segmentContaining(old).replace(old, replacement);
    };

    PointsList.prototype.reverse = function() {
      return new PointsList([], this.owner, this.segments.map(function(s) {
        return s.reverse();
      }));
    };

    PointsList.prototype.at = function(n) {
      return this.segmentContaining(parseInt(n, 10)).at(n);
    };

    PointsList.prototype.close = function() {
      this.closed = true;
      return this;
    };

    PointsList.prototype.relative = function() {
      this.segments = this.segments.map(function(s) {
        s.points = s.points.map(function(p) {
          var abs;
          abs = p.relative();
          abs.inheritPosition(p);
          return abs;
        });
        return s;
      });
      return this;
    };

    PointsList.prototype.absolute = function() {
      this.segments = this.segments.map(function(s) {
        s.points = s.points.map(function(p) {
          var abs;
          abs = p.absolute();
          abs.inheritPosition(p);
          return abs;
        });
        return s;
      });
      return this;
    };

    PointsList.prototype.drawBasePoints = function() {
      this.map(function(p) {
        var _ref;
        if ((_ref = p.baseHandle) != null) {
          _ref.remove();
        }
        p.draw();
        return p.makeAntlers();
      });
      return this;
    };

    PointsList.prototype.removeBasePoints = function() {
      this.map(function(p) {
        var _ref;
        return (_ref = p.baseHandle) != null ? _ref.remove() : void 0;
      });
      return this;
    };

    PointsList.prototype.hide = function() {
      return this.map(function(p) {
        return p.hide();
      });
    };

    PointsList.prototype.unhover = function() {
      return this.map(function(p) {
        return p.unhover();
      });
    };

    PointsList.prototype.join = function(x) {
      return this.all().join(x);
    };

    PointsList.prototype.segmentContaining = function(a) {
      var s, segm, segments, _i, _len, _ref;
      if (typeof a === "number") {
        _ref = this.segments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (s.startsAt <= a) {
            segm = s;
          } else {
            break;
          }
        }
        return segm;
      } else {
        segments = this.segments.filter(function(s) {
          return s.points.indexOf(a) > -1;
        });
        if (segments.length === 1) {
          return segments[0];
        }
      }
      return [];
    };

    PointsList.prototype.hasPointWithin = function(tolerance, point) {
      return this.filter(function(p) {
        return p.within(tolerance, point);
      }).length > 0;
    };

    PointsList.prototype.remove = function(x) {
      var p, _i, _len, _results;
      if (typeof x === "number") {
        x = this.at(x);
      }
      if (x instanceof Array) {
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          p = x[_i];
          _results.push(this.remove(p));
        }
        return _results;
      } else if (x instanceof Point) {
        return this.segmentContaining(x).remove(x);
      }
    };

    PointsList.prototype.filter = function(fun) {
      return this.all().filter(fun);
    };

    PointsList.prototype.filterSegments = function(fun) {
      return this.segments.map(function(segment) {
        return new PointsSegment(segment.points.filter(fun));
      });
    };

    PointsList.prototype.fetch = function(cl) {
      return this.all().filter(function(p) {
        return p instanceof cl;
      });
    };

    PointsList.prototype.map = function(fun) {
      return this.segments.map(function(s) {
        return s.points.map(fun);
      });
    };

    PointsList.prototype.forEach = function(fun) {
      return this.segments.forEach(function(s) {
        return s.points.forEach(fun);
      });
    };

    PointsList.prototype.mapApply = function(fun) {
      return this.segments.map(function(s) {
        return s.points = s.points.map(fun);
      });
    };

    PointsList.prototype.xRange = function() {
      var xs;
      xs = this.all().map(function(p) {
        return p.x;
      });
      return new Range(Math.min.apply(this, xs), Math.max.apply(this, xs));
    };

    PointsList.prototype.yRange = function() {
      var ys;
      ys = this.all().map(function(p) {
        return p.y;
      });
      return new Range(Math.min.apply(this, ys), Math.max.apply(this, ys));
    };

    PointsList.prototype.toString = function() {
      return this.segments.join(' ') + (this.closed ? "z" : "");
    };

    PointsList.prototype.insideOf = function(other) {
      return this.all().filter(function(p) {
        return p.insideOf(other);
      });
    };

    PointsList.prototype.notInsideOf = function(other) {
      return this.all().filter(function(p) {
        return !p.insideOf(other);
      });
    };

    PointsList.prototype.withoutMoveTos = function() {
      return new PointsList([], this.owner, this.filterSegments(function(p) {
        return !(p instanceof MoveTo);
      }));
    };

    return PointsList;

  })();

  /*
  
    PointsSegment
  
    A segment of points that starts with a MoveTo.
    A PointsList is composed of a list of these.
  */


  PointsSegment = (function() {
    function PointsSegment(points, list) {
      var _this = this;
      this.points = points;
      this.list = list;
      this.startsAt = this.points.length !== 0 ? this.points[0].at : 0;
      if (this.list != null) {
        this.owner = this.list.owner;
      }
      if (this.points[0] instanceof MoveTo) {
        this.moveTo = this.points[0];
      }
      this.points.forEach(function(p) {
        return p.segment = _this;
      });
      this;
    }

    PointsSegment.prototype.insert = function(point, at) {
      var head, tail;
      head = this.points.slice(0, at);
      tail = this.points.slice(at);
      if (point instanceof Array) {
        tail.forEach(function(p) {
          return p.at += point.length;
        });
        return head = head.concat(point);
      } else if (point instanceof Point) {
        tail.forEach(function(p) {
          return p.at += 1;
        });
        head[head.length - 1].setSucc(point);
        tail[0].setPrec(point);
        return head.push(point);
      } else {
        throw new Error("PointsList: don't know how to insert " + point + ".");
      }
    };

    PointsSegment.prototype.toString = function() {
      return this.points.join(' ');
    };

    PointsSegment.prototype.at = function(n) {
      return this.points[n - this.startsAt];
    };

    PointsSegment.prototype.remove = function(x) {
      x.prec.succ = x.succ;
      x.succ.prec = x.prec;
      if (x === this.list.last) {
        this.list.last = x.prec;
      }
      if (x === this.list.first) {
        this.list.first = x.succ;
      }
      this.points = this.points.remove(x);
      return x.remove();
    };

    PointsSegment.prototype.movePointToFront = function(point) {
      if (!(this.points.has(point))) {
        return;
      }
      this.removeMoveTo();
      this.points = this.points.cannibalizeUntil(point);
      return this;
    };

    PointsSegment.prototype.moveMoveTo = function(otherPoint) {
      var i, segment, tail, _i, _ref;
      tail = this.points.slice(1);
      for (i = _i = 0, _ref = otherPoint.at - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        segment = segment.cannibalize();
      }
      this.moveTo.copy(otherPoint);
      return this.points = [this.moveTo].concat(segment);
    };

    PointsSegment.prototype.replace = function(old, replacement) {
      var at, np, p, prec, replen, succ, _i, _j, _len, _len1, _ref;
      if (replacement instanceof Point) {
        replacement.inheritPosition(old);
        this.points = this.points.replace(old, replacement);
      } else if (replacement instanceof Array) {
        replen = replacement.length;
        at = old.at;
        prec = old.prec;
        succ = old.succ;
        old.succ.prec = replacement[replen - 1];
        for (_i = 0, _len = replacement.length; _i < _len; _i++) {
          np = replacement[_i];
          np.owner = this.owner;
          np.at = at;
          np.prec = prec;
          np.succ = succ;
          prec.succ = np;
          prec = np;
          at += 1;
        }
        this.points = this.points.replace(old, replacement);
        _ref = this.points.slice(at);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          p = _ref[_j];
          p.at += replen - 1;
        }
      }
      return replacement;
    };

    PointsSegment.prototype.validateLinks = function() {
      var i, p, prev, succ, _ref;
      console.log(this.points.map(function(p) {
        return "" + p.prec.at + " " + p.at + " " + p.succ.at;
      }));
      prev = this.points.length - 1;
      _ref = this.points;
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        p = _ref[i];
        i = parseInt(i, 10);
        if (!(p.prec === this.points[prev])) {
          console.log(p, "prec wrong. Expecting", prev);
          debugger;
          return false;
          break;
        }
        succ = i === this.points.length - 1 ? 0 : i + 1;
        if (!(p.succ === this.points[succ])) {
          console.log(p, "succ wrong");
          return false;
          break;
        }
        prev = i;
      }
      return true;
    };

    PointsSegment.prototype.reverse = function() {
      var index, point, positions, stack, tailRev, _ref;
      this.removeMoveTo();
      positions = [];
      stack = [];
      _ref = this.points;
      for (index in _ref) {
        if (!__hasProp.call(_ref, index)) continue;
        point = _ref[index];
        stack.push(point);
        positions.push({
          x: point.x,
          y: point.y
        });
      }
      tailRev = stack.slice(1).reverse().map(function(p) {
        if (p instanceof CurvePoint) {
          return p.reverse();
        } else {
          return p;
        }
      });
      positions = positions.reverse();
      stack = stack.slice(0, 1).concat(tailRev);
      stack = stack.map(function(p, i) {
        var c, succ;
        c = positions[0];
        p.x = c.x;
        p.y = c.y;
        succ = p.succ;
        p.succ = p.prec;
        p.prec = succ;
        p.at = i;
        positions = positions.slice(1);
        return p;
      });
      return new PointsSegment(stack, this.list);
    };

    PointsSegment.prototype.removeMoveTo = function() {
      return this.points = this.points.filter(function(p) {
        return !(p instanceof MoveTo);
      });
    };

    PointsSegment.prototype.ensureMoveTo = function() {
      var firstPoint, lastPoint, moveTo;
      lastPoint = this.points.last();
      firstPoint = this.points.first();
      moveTo = new MoveTo(lastPoint.x, lastPoint.y, lastPoint.owner, lastPoint);
      moveTo.at = 0;
      lastPoint.succ = firstPoint.prec = moveTo;
      moveTo.succ = firstPoint;
      this.points.unshift(moveTo);
      return this;
    };

    return PointsSegment;

  })();

  /*
    Internal representation of a straight line segment
  
    a
     \
      \
       \
        \
         \
          \
           \
            b
  
    I/P:
      a: First point
      b: Second point
  */


  LineSegment = (function() {
    function LineSegment(a, b, source) {
      this.a = a;
      this.b = b;
      this.source = source != null ? source : this.toLineTo();
      this.calculate();
    }

    LineSegment.prototype.calculate = function() {
      this.slope = (this.a.y - this.b.y) / (this.b.x - this.a.x);
      this.angle = Math.atan(this.slope) / (Math.PI / 180);
      this.length = Math.sqrt(Math.pow(this.b.x - this.a.x, 2) + Math.pow(this.b.y - this.a.y, 2));
      return this;
    };

    LineSegment.prototype.beginning = function() {
      return this.a;
    };

    LineSegment.prototype.end = function() {
      return this.a;
    };

    LineSegment.prototype.toString = function() {
      return "(Line segment: " + (this.a.toString()) + " " + (this.b.toString()) + ")";
    };

    LineSegment.prototype.constructorString = function() {
      return "new LineSegment(" + (this.a.constructorString()) + ", " + (this.b.constructorString()) + ")";
    };

    LineSegment.prototype.angle360 = function() {
      return this.b.angle360(this.a);
    };

    LineSegment.prototype.toLineTo = function() {
      return new LineTo(this.b.x, this.b.y);
    };

    LineSegment.prototype.toSVGPoint = function() {
      return this.toLineTo();
    };

    LineSegment.prototype.reverse = function() {
      return new LineSegment(this.b, this.a);
    };

    LineSegment.prototype.bounds = function(useCached) {
      var height, maxx, maxy, minx, miny, width;
      if (useCached == null) {
        useCached = false;
      }
      if ((this.boundsCached != null) && useCached) {
        return this.boundsCached;
      }
      minx = Math.min(this.a.x, this.b.x);
      maxx = Math.max(this.a.x, this.b.x);
      miny = Math.min(this.a.y, this.b.y);
      maxy = Math.max(this.a.y, this.b.y);
      width = this.width();
      height = this.height();
      return this.boundsCached = new Bounds(minx, miny, width, height);
    };

    LineSegment.prototype.boundsCached = void 0;

    LineSegment.prototype.rotate = function(angle, origin) {
      return new LineSegment(this.a.rotate(angle, origin), this.b.rotate(angle, origin));
    };

    LineSegment.prototype.width = function() {
      return Math.abs(this.a.x - this.b.x);
    };

    LineSegment.prototype.height = function() {
      return Math.abs(this.a.y - this.b.y);
    };

    LineSegment.prototype.xRange = function() {
      return new Range(Math.min(this.a.x, this.b.x), Math.max(this.a.x, this.b.x));
    };

    LineSegment.prototype.yRange = function() {
      return new Range(Math.min(this.a.y, this.b.y), Math.max(this.a.y, this.b.y));
    };

    LineSegment.prototype.xDiff = function() {
      return Math.max(this.b.x, this.a.x) - Math.min(this.b.x, this.a.x);
    };

    LineSegment.prototype.xbaDiff = function() {
      return this.b.x - this.a.x;
    };

    LineSegment.prototype.yDiff = function() {
      return Math.max(this.b.y, this.a.y) - Math.min(this.b.y, this.a.y);
    };

    LineSegment.prototype.ybaDiff = function() {
      return this.b.y - this.a.y;
    };

    LineSegment.prototype.yAtX = function(x, extrapolate) {
      if (extrapolate == null) {
        extrapolate = true;
      }
      if (!extrapolate && !this.xRange().containsInclusive(x)) {
        return null;
      }
      return this.a.y + ((x - this.a.x) * this.slope);
    };

    LineSegment.prototype.xAtY = function(y, extrapolate) {
      if (extrapolate == null) {
        extrapolate = true;
      }
      if (!extrapolate && !this.yRange().containsInclusive(y)) {
        return null;
      }
      return this.a.x + ((y - this.a.y) / this.slope);
    };

    LineSegment.prototype.ends = function() {
      return [a, b];
    };

    LineSegment.prototype.posnAtPercent = function(p) {
      return new Posn(this.a.x + (this.b.x - this.a.x) * p, this.a.y + (this.b.y - this.a.y) * p);
    };

    LineSegment.prototype.findPercentageOfPoint = function(p) {
      var distanceA;
      distanceA = p.distanceFrom(this.a);
      return distanceA / (distanceA + p.distanceFrom(this.b));
    };

    LineSegment.prototype.splitAt = function(p, forced) {
      var distances, distancesSorted, key, nextA, posn, segments, split, _i, _j, _len, _len1;
      if (forced == null) {
        forced = null;
      }
      if (typeof p === "number") {
        split = forced ? forced : this.posnAtPercent(p);
        return [new LineSegment(this.a, split), new LineSegment(split, this.b)];
      } else if (p instanceof Array) {
        segments = [];
        distances = {};
        for (_i = 0, _len = p.length; _i < _len; _i++) {
          posn = p[_i];
          distances[posn.distanceFrom(this.a)] = posn;
        }
        distancesSorted = Object.keys(distances).map(parseFloat).sort(sortNumbers);
        nextA = this.a;
        for (_j = 0, _len1 = distancesSorted.length; _j < _len1; _j++) {
          key = distancesSorted[_j];
          posn = distances[key];
          segments.push(new LineSegment(nextA, posn));
          nextA = posn;
        }
        segments.push(new LineSegment(nextA, this.b));
        return segments;
      } else if (p instanceof Posn) {
        return [new LineSegment(this.a, p), new LineSegment(p, this.b)];
      }
    };

    LineSegment.prototype.midPoint = function() {
      return this.splitAt(0.5)[0].b;
    };

    LineSegment.prototype.nudge = function(x, y) {
      this.a.nudge(x, y);
      return this.b.nudge(x, y);
    };

    LineSegment.prototype.scale = function(x, y, origin) {
      this.a.scale(x, y, origin);
      return this.b.scale(x, y, origin);
    };

    LineSegment.prototype.equal = function(ls) {
      if (ls instanceof CubicBezier) {
        return false;
      }
      return ((this.a.equal(ls.a)) && (this.b.equal(ls.b))) || ((this.a.equal(ls.b)) && (this.b.equal(ls.a)));
    };

    LineSegment.prototype.intersects = function(s) {
      var inter;
      inter = this.intersection(s);
      return inter instanceof Posn || inter instanceof Array;
    };

    LineSegment.prototype.intersection = function(s) {
      if (s instanceof LineSegment) {
        return this.intersectionWithLineSegment(s);
      } else if (s instanceof Circle) {
        return this.intersectionWithCircle(s);
      } else if (s instanceof CubicBezier) {
        return s.intersectionWithLineSegment(this);
      }
    };

    LineSegment.prototype.intersectionWithLineSegment = function(s) {
      /*
        Get intersection with another LineSegment
      
        I/P : LineSegment
      
        O/P : If intersection exists, [x, y] coords of intersection
              If none exists, null
              If they're parallel, 0
              If they're coincident, Infinity
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var ana_m, ana_s, anam, anas, crossDiff;
      ana_s = s.xbaDiff() * (this.a.y - s.a.y) - s.ybaDiff() * (this.a.x - s.a.x);
      ana_m = this.xbaDiff() * (this.a.y - s.a.y) - this.ybaDiff() * (this.a.x - s.a.x);
      crossDiff = s.ybaDiff() * this.xbaDiff() - s.xbaDiff() * this.ybaDiff();
      if (crossDiff !== 0) {
        anas = ana_s / crossDiff;
        anam = ana_m / crossDiff;
        if (0 <= anas && anas <= 1 && 0 <= anam && anam <= 1) {
          return new Posn(this.a.x + anas * (this.b.x - this.a.x), this.a.y + anas * (this.b.y - this.a.y));
        } else {
          return null;
        }
      } else {
        if (ana_s === 0 || ana_m === 0) {
          return Infinity;
        } else {
          return 0;
        }
      }
    };

    LineSegment.prototype.intersectionWithEllipse = function(s) {
      /*
       Get intersection with an ellipse
      
       I/P: Ellipse
      
       O/P: null if no intersections, or Array of Posn(s) if there are
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var a, b, c, center, cx, cy, d, diff, dir, mDiff, mDir, origin, results, root, rx, ry, t, t_a, t_b;
      rx = s.data.rx;
      ry = s.data.ry;
      cx = s.data.cx;
      cy = s.data.cy;
      origin = new Posn(this.a.x, this.a.y);
      dir = new Posn(this.b.x - this.a.x, this.b.y - this.a.y);
      center = new Posn(cx, cy);
      diff = origin.subtract(center);
      mDir = new Posn(dir.x / (rx * rx), dir.y / (ry * ry));
      mDiff = new Posn(diff.x / (rx * rx), diff.y / (ry * ry));
      results = [];
      a = dir.dot(mDir);
      b = dir.dot(mDiff);
      c = diff.dot(mDiff) - 1.0;
      d = b * b - a * c;
      if (d < 0) {
        return null;
      } else if (d > 0) {
        root = Math.sqrt(d);
        t_a = (-b - root) / a;
        t_b = (-b + root) / a;
        if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
          if ((t_a < 0 && t_b < 0) && (t_a > 1 && t_b > 1)) {
            return null;
          } else {
            return null;
          }
        } else {
          if (0 <= t_a && t_a <= 1) {
            results.push(this.a.lerp(this.b, t_a));
          }
          if (0 <= t_b && t_b <= 1) {
            results.push(this.a.lerp(this.b, t_b));
          }
        }
      } else {
        t = -b / a;
        if (0 <= t && t <= 1) {
          results.push(this.a.lerp(this.b, t));
        } else {
          return null;
        }
      }
      return results;
    };

    LineSegment.prototype.intersectionWithCircle = function(s) {
      /*
        Get intersection with a circle
      
        I/P : Circle
      
        O/P : If intersection exists, [x, y] coords of intersection
              If none exists, null
              If they're parallel, 0
              If they're coincident, Infinity
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var a, b, cc, deter, e, ints, u1, u2;
      a = Math.pow(this.xDiff(), 2) + Math.pow(this.yDiff(), 2);
      b = 2 * ((this.b.x - this.a.x) * (this.a.x - s.data.cx) + (this.b.y - this.a.y) * (this.a.y - s.data.cy));
      cc = Math.pow(s.data.cx, 2) + Math.pow(s.data.cy, 2) + Math.pow(this.a.x, 2) + Math.pow(this.a.y, 2) - 2 * (s.data.cx * this.a.x + s.data.cy * this.a.y) - Math.pow(s.data.r, 2);
      deter = b * b - 4 * a * cc;
      if (deter < 0) {
        return null;
      } else if (deter === 0) {
        return 0;
      } else {
        e = Math.sqrt(deter);
        u1 = (-b + e) / (2 * a);
        u2 = (-b - e) / (2 * a);
        if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
          if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {
            return null;
          } else {
            return true;
          }
        } else {
          ints = [];
          if (0 <= u1 && u1 <= 1) {
            ints.push(this.a.lerp(this.b, u1));
          }
          if (0 <= u2 && u2 <= 1) {
            ints.push(this.a.lerp(this.b, u2));
          }
          return ints;
        }
      }
    };

    return LineSegment;

  })();

  Ray = (function(_super) {
    __extends(Ray, _super);

    function Ray(a, angle) {
      this.a = a;
      this.angle = angle;
      Ray.__super__.constructor.call(this, this.a, this.a.clone().nudge(0, -1e5).rotate(this.angle, this.a));
    }

    return Ray;

  })(LineSegment);

  /*
    Internal representation of a cubic bezier line segment
  
    p1                                     p4
     o                                     o
      \\                                 //
       \\                               //
        \ \                           / /
         \   \                     /   /
          \     _               _     /
           \      __         __      /
            Â°       --_____--       Â°
             p2                    p3
  
    I/P:
      p1: First absolute point, the moveto
      p2: The first point's curve handle
      p3: The second point's curve handle
      p4: The second absolute point
  
      In context with syntax: M[p1]C[p2] [p3] [p4]
  */


  CubicBezier = (function() {
    function CubicBezier(p1, p2, p3, p4, source) {
      this.p1 = p1;
      this.p2 = p2;
      this.p3 = p3;
      this.p4 = p4;
      this.source = source != null ? source : this.toCurveTo();
    }

    /*
    toString: ->
      "(Cubic bezier: #{@p1},#{@p2},#{@p3},#{@p4})"
    */


    CubicBezier.prototype.toString = function() {
      return "new CubicBezier(" + this.p1 + ", " + this.p2 + ", " + this.p3 + ", " + this.p4 + ")";
    };

    CubicBezier.prototype.toCurveTo = function() {
      return new CurveTo(this.p2.x, this.p2.y, this.p3.x, this.p3.y, this.p4.x, this.p4.y);
    };

    CubicBezier.prototype.toSVGPoint = function() {
      return this.toCurveTo();
    };

    CubicBezier.prototype.length = function() {
      return this.intoLineSegments(4).reduce(function(a, b) {
        return a + b.length;
      });
    };

    CubicBezier.prototype.beginning = function() {
      return this.p1;
    };

    CubicBezier.prototype.end = function() {
      return this.p4;
    };

    CubicBezier.prototype.nudge = function(x, y) {
      this.p1.nudge(x, y);
      this.p2.nudge(x, y);
      this.p3.nudge(x, y);
      this.p4.nudge(x, y);
      return this;
    };

    CubicBezier.prototype.scale = function(x, y, origin) {
      this.p1.scale(x, y, origin);
      this.p2.scale(x, y, origin);
      this.p3.scale(x, y, origin);
      this.p4.scale(x, y, origin);
      return this;
    };

    CubicBezier.prototype.rotate = function(angle, origin) {
      this.p1.rotate(angle, origin);
      this.p2.rotate(angle, origin);
      this.p3.rotate(angle, origin);
      this.p4.rotate(angle, origin);
      return this;
    };

    CubicBezier.prototype.reverse = function() {
      return new CubicBezier(this.p4, this.p3, this.p2, this.p1);
    };

    CubicBezier.prototype.equal = function(cbls) {
      if (cbls instanceof LineSegment) {
        return false;
      }
      return ((this.p1.equal(cbls.p1)) && (this.p2.equal(cbls.p2)) && (this.p3.equal(cbls.p3)) && (this.p4.equal(cbls.p4))) || ((this.p1.equal(cbls.p4)) && (this.p2.equal(cbls.p3)) && (this.p3.equal(cbls.p2)) && (this.p4.equal(cbls.p1)));
    };

    CubicBezier.prototype.intersects = function(other) {
      var inter;
      inter = this.intersection(other);
      return inter instanceof Posn || (inter instanceof Array && inter.length > 0);
    };

    CubicBezier.prototype.intersection = function(other) {
      switch (other.constructor) {
        case LineSegment:
          return this.intersectionWithLineSegment(other);
        case CubicBezier:
          return this.intersectionWithCubicBezier(other);
      }
    };

    CubicBezier.prototype.xRange = function() {
      return this.bounds().xr;
    };

    CubicBezier.prototype.yRange = function() {
      return this.bounds().yr;
    };

    CubicBezier.prototype.ends = function() {
      return [this.p1, this.p4];
    };

    CubicBezier.prototype.midPoint = function() {
      return this.splitAt(0.5)[0].p4;
    };

    CubicBezier.prototype.bounds = function(useCached) {
      var d, height, i, maxx, maxy, minx, miny, px, py, qx, qy, rx, ry, sx, sy, top2x, top2y, top3x, top3y, top4x, top4y, toqx, toqy, torx, tory, totx, toty, tx, ty, width, x, y, _i;
      if (useCached == null) {
        useCached = false;
      }
      if ((this.boundsCached != null) && useCached) {
        return this.boundsCached;
      }
      minx = miny = Infinity;
      maxx = maxy = -Infinity;
      top2x = this.p2.x - this.p1.x;
      top2y = this.p2.y - this.p1.y;
      top3x = this.p3.x - this.p2.x;
      top3y = this.p3.y - this.p2.y;
      top4x = this.p4.x - this.p3.x;
      top4y = this.p4.y - this.p3.y;
      for (i = _i = 0; _i <= 40; i = ++_i) {
        d = i / 40;
        px = this.p1.x + d * top2x;
        py = this.p1.y + d * top2y;
        qx = this.p2.x + d * top3x;
        qy = this.p2.y + d * top3y;
        rx = this.p3.x + d * top4x;
        ry = this.p3.y + d * top4y;
        toqx = qx - px;
        toqy = qy - py;
        torx = rx - qx;
        tory = ry - qy;
        sx = px + d * toqx;
        sy = py + d * toqy;
        tx = qx + d * torx;
        ty = qy + d * tory;
        totx = tx - sx;
        toty = ty - sy;
        x = sx + d * totx;
        y = sy + d * toty;
        minx = Math.min(minx, x);
        miny = Math.min(miny, y);
        maxx = Math.max(maxx, x);
        maxy = Math.max(maxy, y);
        width = maxx - minx;
        height = maxy - miny;
      }
      return this.boundsCached = new Bounds(minx, miny, width, height);
    };

    CubicBezier.prototype.boundsCached = void 0;

    CubicBezier.prototype.intoLineSegments = function(n) {
      var i, last, m, segments, x, y, _i;
      segments = [];
      for (m = _i = 0; 0 <= n ? _i <= n : _i >= n; m = 0 <= n ? ++_i : --_i) {
        i = 1 / m;
        x = Math.pow(1 - i, 3) * this.p1.x + 3 * Math.pow(1 - i, 2) * i * this.p2.x + 3 * (1 - i) * Math.pow(i, 2) * this.p3.x + Math.pow(i, 3) * this.p4.x;
        y = Math.pow(1 - i, 3) * this.p1.y + 3 * Math.pow(1 - i, 2) * i * this.p2.y + 3 * (1 - i) * Math.pow(i, 2) * this.p3.y + Math.pow(i, 3) * this.p4.y;
        if (m % 2 === 0) {
          last = new Posn(x, y);
        } else {
          segments.push(new LineSegment(last, new Posn(x, y)));
        }
      }
      return segments.splice(1);
    };

    CubicBezier.prototype.splitAt = function(t, force) {
      var p10, p5, p6, p7, p8, p9, pair, perc, percent, percentages, posn, segments, sortedPosns, tail, _i, _j, _len, _len1;
      if (force == null) {
        force = null;
      }
      if (typeof t === "number") {
        p5 = new LineSegment(this.p1, this.p2).posnAtPercent(t);
        p6 = new LineSegment(this.p2, this.p3).posnAtPercent(t);
        p7 = new LineSegment(this.p3, this.p4).posnAtPercent(t);
        p8 = new LineSegment(p5, p6).posnAtPercent(t);
        p9 = new LineSegment(p6, p7).posnAtPercent(t);
        p10 = force ? force : new LineSegment(p8, p9).posnAtPercent(t);
        return [new CubicBezier(this.p1, p5, p8, p10), new CubicBezier(p10, p9, p7, this.p4)];
      } else if (t instanceof Posn) {
        return this.splitAt(this.findPercentageOfPoint(t), t);
      } else if (t instanceof Array) {
        sortedPosns = {};
        segments = [];
        for (_i = 0, _len = t.length; _i < _len; _i++) {
          posn = t[_i];
          percent = this.findPercentageOfPoint(posn);
          sortedPosns[percent] = posn;
        }
        percentages = Object.keys(sortedPosns).map(parseFloat).sort(sortNumbers);
        tail = this;
        for (_j = 0, _len1 = percentages.length; _j < _len1; _j++) {
          perc = percentages[_j];
          pair = tail.splitAt(sortedPosns[perc]);
          segments.push(pair[0]);
          tail = pair[1];
        }
        segments.push(tail);
        return segments;
      }
    };

    CubicBezier.prototype.findPercentageOfPoint = function(posn, tolerance, accumulated, nextstep) {
      var a, ab, ac, b, bb, bc, split;
      if (tolerance == null) {
        tolerance = 1e-3;
      }
      if (accumulated == null) {
        accumulated = 0.0;
      }
      if (nextstep == null) {
        nextstep = 0.5;
      }
      split = this.splitAt(0.5);
      a = split[0];
      b = split[1];
      if (a.p4.within(tolerance, posn) || nextstep < 1e-4) {
        return accumulated;
      }
      ab = a.bounds();
      bb = b.bounds();
      if (ab.xr.containsInclusive(posn.x, 0.2) && ab.yr.containsInclusive(posn.y, 0.2)) {
        ac = a.findPercentageOfPoint(posn, tolerance, accumulated, nextstep / 2);
      }
      if (bb.xr.containsInclusive(posn.x, 0.2) && bb.yr.containsInclusive(posn.y, 0.2)) {
        bc = b.findPercentageOfPoint(posn, tolerance, accumulated + nextstep, nextstep / 2);
      }
      if (ac != null) {
        return ac;
      } else if (bc != null) {
        return bc;
      } else {
        return accumulated;
      }
    };

    /*
    
      Intersection methods
    */


    CubicBezier.prototype.intersectionWithLineSegment = function(l) {
      /*
      
        Given a LineSegment, lists intersection point(s).
      
        I/P: LineSegment
        O/P: Array of Posns
      
        I am a cute sick Kate Whiper Snapper
        i love monodebe and I learn all about the flexible scemless data base
      
        Disclaimer: I don't really understand this but it passes my tests.
      */

      var a, b, c, c0, c1, c2, c3, cl, d, i, max, min, n, p10, p5, p6, p7, p8, p9, results, roots, t;
      min = l.a.min(l.b);
      max = l.a.max(l.b);
      results = [];
      a = this.p1.multiplyBy(-1);
      b = this.p2.multiplyBy(3);
      c = this.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(this.p4)));
      c3 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(3);
      b = this.p2.multiplyBy(-6);
      c = this.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c2 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(-3);
      b = this.p2.multiplyBy(3);
      c = a.add(b);
      c1 = new Posn(c.x, c.y);
      c0 = new Posn(this.p1.x, this.p1.y);
      n = new Posn(l.a.y - l.b.y, l.b.x - l.a.x);
      cl = l.a.x * l.b.y - l.b.x * l.a.y;
      roots = new Polynomial([n.dot(c3), n.dot(c2), n.dot(c1), n.dot(c0) + cl]).roots();
      for (i in roots) {
        t = roots[i];
        if (0 <= t && t <= 1) {
          p5 = this.p1.lerp(this.p2, t);
          p6 = this.p2.lerp(this.p3, t);
          p7 = this.p3.lerp(this.p4, t);
          p8 = p5.lerp(p6, t);
          p9 = p6.lerp(p7, t);
          p10 = p8.lerp(p9, t);
          if (l.a.x === l.b.x) {
            if ((min.y <= p10.y) && (p10.y <= max.y)) {
              results.push(p10);
            }
          } else if (l.a.y === l.b.y) {
            if (min.x <= p10.x && p10.x <= max.x) {
              results.push(p10);
            }
          } else if (p10.gte(min) && p10.lte(max)) {
            results.push(p10);
          }
        }
      }
      return results;
    };

    CubicBezier.prototype.intersectionWithCubicBezier = function(other) {
      var a, b, c, c10, c10x2, c10x3, c10y2, c10y3, c11, c11x2, c11x3, c11y2, c11y3, c12, c12x2, c12x3, c12y2, c12y3, c13, c13x2, c13x3, c13y2, c13y3, c20, c20x2, c20x3, c20y2, c20y3, c21, c21x2, c21x3, c21y2, c22, c22x2, c22x3, c22y2, c23, c23x2, c23x3, c23y2, c23y3, d, i, j, k, poly, results, roots, s, tolerance, xRoot, xRoots, yRoot, yRoots;
      results = [];
      a = this.p1.multiplyBy(-1);
      b = this.p2.multiplyBy(3);
      c = this.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(this.p4)));
      c13 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(3);
      b = this.p2.multiplyBy(-6);
      c = this.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c12 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(-3);
      b = this.p2.multiplyBy(3);
      c = a.add(b);
      c11 = new Posn(c.x, c.y);
      c10 = new Posn(this.p1.x, this.p1.y);
      a = other.p1.multiplyBy(-1);
      b = other.p2.multiplyBy(3);
      c = other.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(other.p4)));
      c23 = new Posn(d.x, d.y);
      a = other.p1.multiplyBy(3);
      b = other.p2.multiplyBy(-6);
      c = other.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c22 = new Posn(d.x, d.y);
      a = other.p1.multiplyBy(-3);
      b = other.p2.multiplyBy(3);
      c = a.add(b);
      c21 = new Posn(c.x, c.y);
      c20 = new Posn(other.p1.x, other.p1.y);
      c10x2 = c10.x * c10.x;
      c10x3 = c10.x * c10.x * c10.x;
      c10y2 = c10.y * c10.y;
      c10y3 = c10.y * c10.y * c10.y;
      c11x2 = c11.x * c11.x;
      c11x3 = c11.x * c11.x * c11.x;
      c11y2 = c11.y * c11.y;
      c11y3 = c11.y * c11.y * c11.y;
      c12x2 = c12.x * c12.x;
      c12x3 = c12.x * c12.x * c12.x;
      c12y2 = c12.y * c12.y;
      c12y3 = c12.y * c12.y * c12.y;
      c13x2 = c13.x * c13.x;
      c13x3 = c13.x * c13.x * c13.x;
      c13y2 = c13.y * c13.y;
      c13y3 = c13.y * c13.y * c13.y;
      c20x2 = c20.x * c20.x;
      c20x3 = c20.x * c20.x * c20.x;
      c20y2 = c20.y * c20.y;
      c20y3 = c20.y * c20.y * c20.y;
      c21x2 = c21.x * c21.x;
      c21x3 = c21.x * c21.x * c21.x;
      c21y2 = c21.y * c21.y;
      c22x2 = c22.x * c22.x;
      c22x3 = c22.x * c22.x * c22.x;
      c22y2 = c22.y * c22.y;
      c23x2 = c23.x * c23.x;
      c23x3 = c23.x * c23.x * c23.x;
      c23y2 = c23.y * c23.y;
      c23y3 = c23.y * c23.y * c23.y;
      poly = new Polynomial([-c13x3 * c23y3 + c13y3 * c23x3 - 3 * c13.x * c13y2 * c23x2 * c23.y + 3 * c13x2 * c13.y * c23.x * c23y2, -6 * c13.x * c22.x * c13y2 * c23.x * c23.y + 6 * c13x2 * c13.y * c22.y * c23.x * c23.y + 3 * c22.x * c13y3 * c23x2 - 3 * c13x3 * c22.y * c23y2 - 3 * c13.x * c13y2 * c22.y * c23x2 + 3 * c13x2 * c22.x * c13.y * c23y2, -6 * c21.x * c13.x * c13y2 * c23.x * c23.y - 6 * c13.x * c22.x * c13y2 * c22.y * c23.x + 6 * c13x2 * c22.x * c13.y * c22.y * c23.y + 3 * c21.x * c13y3 * c23x2 + 3 * c22x2 * c13y3 * c23.x + 3 * c21.x * c13x2 * c13.y * c23y2 - 3 * c13.x * c21.y * c13y2 * c23x2 - 3 * c13.x * c22x2 * c13y2 * c23.y + c13x2 * c13.y * c23.x * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-c21.y * c23y2 - 2 * c22y2 * c23.y - c23.y * (2 * c21.y * c23.y + c22y2)), c11.x * c12.y * c13.x * c13.y * c23.x * c23.y - c11.y * c12.x * c13.x * c13.y * c23.x * c23.y + 6 * c21.x * c22.x * c13y3 * c23.x + 3 * c11.x * c12.x * c13.x * c13.y * c23y2 + 6 * c10.x * c13.x * c13y2 * c23.x * c23.y - 3 * c11.x * c12.x * c13y2 * c23.x * c23.y - 3 * c11.y * c12.y * c13.x * c13.y * c23x2 - 6 * c10.y * c13x2 * c13.y * c23.x * c23.y - 6 * c20.x * c13.x * c13y2 * c23.x * c23.y + 3 * c11.y * c12.y * c13x2 * c23.x * c23.y - 2 * c12.x * c12y2 * c13.x * c23.x * c23.y - 6 * c21.x * c13.x * c22.x * c13y2 * c23.y - 6 * c21.x * c13.x * c13y2 * c22.y * c23.x - 6 * c13.x * c21.y * c22.x * c13y2 * c23.x + 6 * c21.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.y * c23.x * c23.y + c22x3 * c13y3 - 3 * c10.x * c13y3 * c23x2 + 3 * c10.y * c13x3 * c23y2 + 3 * c20.x * c13y3 * c23x2 + c12y3 * c13.x * c23x2 - c12x3 * c13.y * c23y2 - 3 * c10.x * c13x2 * c13.y * c23y2 + 3 * c10.y * c13.x * c13y2 * c23x2 - 2 * c11.x * c12.y * c13x2 * c23y2 + c11.x * c12.y * c13y2 * c23x2 - c11.y * c12.x * c13x2 * c23y2 + 2 * c11.y * c12.x * c13y2 * c23x2 + 3 * c20.x * c13x2 * c13.y * c23y2 - c12.x * c12y2 * c13.y * c23x2 - 3 * c20.y * c13.x * c13y2 * c23x2 + c12x2 * c12.y * c13.x * c23y2 - 3 * c13.x * c22x2 * c13y2 * c22.y + c13x2 * c13.y * c23.x * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c22.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c21.y * c22.y * c23.y - c20.y * c23y2 - c22.y * (2 * c21.y * c23.y + c22y2) - c23.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), 6 * c11.x * c12.x * c13.x * c13.y * c22.y * c23.y + c11.x * c12.y * c13.x * c22.x * c13.y * c23.y + c11.x * c12.y * c13.x * c13.y * c22.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c23.y - c11.y * c12.x * c13.x * c13.y * c22.y * c23.x - 6 * c11.y * c12.y * c13.x * c22.x * c13.y * c23.x - 6 * c10.x * c22.x * c13y3 * c23.x + 6 * c20.x * c22.x * c13y3 * c23.x + 6 * c10.y * c13x3 * c22.y * c23.y + 2 * c12y3 * c13.x * c22.x * c23.x - 2 * c12x3 * c13.y * c22.y * c23.y + 6 * c10.x * c13.x * c22.x * c13y2 * c23.y + 6 * c10.x * c13.x * c13y2 * c22.y * c23.x + 6 * c10.y * c13.x * c22.x * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c23.y - 3 * c11.x * c12.x * c13y2 * c22.y * c23.x + 2 * c11.x * c12.y * c22.x * c13y2 * c23.x + 4 * c11.y * c12.x * c22.x * c13y2 * c23.x - 6 * c10.x * c13x2 * c13.y * c22.y * c23.y - 6 * c10.y * c13x2 * c22.x * c13.y * c23.y - 6 * c10.y * c13x2 * c13.y * c22.y * c23.x - 4 * c11.x * c12.y * c13x2 * c22.y * c23.y - 6 * c20.x * c13.x * c22.x * c13y2 * c23.y - 6 * c20.x * c13.x * c13y2 * c22.y * c23.x - 2 * c11.y * c12.x * c13x2 * c22.y * c23.y + 3 * c11.y * c12.y * c13x2 * c22.x * c23.y + 3 * c11.y * c12.y * c13x2 * c22.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c23.y - 2 * c12.x * c12y2 * c13.x * c22.y * c23.x - 2 * c12.x * c12y2 * c22.x * c13.y * c23.x - 6 * c20.y * c13.x * c22.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c13y2 * c23.x - 6 * c21.x * c13.x * c22.x * c13y2 * c22.y + 6 * c20.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.x * c22.y * c23.y + 2 * c12x2 * c12.y * c22.x * c13.y * c23.y + 2 * c12x2 * c12.y * c13.y * c22.y * c23.x + 3 * c21.x * c22x2 * c13y3 + 3 * c21x2 * c13y3 * c23.x - 3 * c13.x * c21.y * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c23.y + c13x2 * c22.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c13.y * c23.x * (6 * c20.y * c22.y + 3 * c21y2) + c21.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c22.y * c23.y - c23.y * (2 * c20.y * c22.y + c21y2) - c21.y * (2 * c21.y * c23.y + c22y2) - c22.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), c11.x * c21.x * c12.y * c13.x * c13.y * c23.y + c11.x * c12.y * c13.x * c21.y * c13.y * c23.x + c11.x * c12.y * c13.x * c22.x * c13.y * c22.y - c11.y * c12.x * c21.x * c13.x * c13.y * c23.y - c11.y * c12.x * c13.x * c21.y * c13.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c22.y - 6 * c11.y * c21.x * c12.y * c13.x * c13.y * c23.x - 6 * c10.x * c21.x * c13y3 * c23.x + 6 * c20.x * c21.x * c13y3 * c23.x + 2 * c21.x * c12y3 * c13.x * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c23.y + 6 * c10.x * c13.x * c21.y * c13y2 * c23.x + 6 * c10.x * c13.x * c22.x * c13y2 * c22.y + 6 * c10.y * c21.x * c13.x * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c23.y - 3 * c11.x * c12.x * c21.y * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c22.y + 2 * c11.x * c21.x * c12.y * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c13y2 * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c23.y - 6 * c10.y * c13x2 * c21.y * c13.y * c23.x - 6 * c10.y * c13x2 * c22.x * c13.y * c22.y - 6 * c20.x * c21.x * c13.x * c13y2 * c23.y - 6 * c20.x * c13.x * c21.y * c13y2 * c23.x - 6 * c20.x * c13.x * c22.x * c13y2 * c22.y + 3 * c11.y * c21.x * c12.y * c13x2 * c23.y - 3 * c11.y * c12.y * c13.x * c22x2 * c13.y + 3 * c11.y * c12.y * c13x2 * c21.y * c23.x + 3 * c11.y * c12.y * c13x2 * c22.x * c22.y - 2 * c12.x * c21.x * c12y2 * c13.x * c23.y - 2 * c12.x * c21.x * c12y2 * c13.y * c23.x - 2 * c12.x * c12y2 * c13.x * c21.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c22.y - 6 * c20.y * c21.x * c13.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c22.x * c13y2 + 6 * c20.y * c13x2 * c21.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c23.y + 2 * c12x2 * c12.y * c21.y * c13.y * c23.x + 2 * c12x2 * c12.y * c22.x * c13.y * c22.y - 3 * c10.x * c22x2 * c13y3 + 3 * c20.x * c22x2 * c13y3 + 3 * c21x2 * c22.x * c13y3 + c12y3 * c13.x * c22x2 + 3 * c10.y * c13.x * c22x2 * c13y2 + c11.x * c12.y * c22x2 * c13y2 + 2 * c11.y * c12.x * c22x2 * c13y2 - c12.x * c12y2 * c22x2 * c13.y - 3 * c20.y * c13.x * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c22.y + c12x2 * c12.y * c13.x * (2 * c21.y * c23.y + c22y2) + c11.x * c12.x * c13.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c21.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c21.y * c23.y - c22y2) + c10.y * c13x3 * (6 * c21.y * c23.y + 3 * c22y2) + c11.y * c12.x * c13x2 * (-2 * c21.y * c23.y - c22y2) + c11.x * c12.y * c13x2 * (-4 * c21.y * c23.y - 2 * c22y2) + c10.x * c13x2 * c13.y * (-6 * c21.y * c23.y - 3 * c22y2) + c13x2 * c22.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c21.y * c23.y - c22.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c21.y * c23.y + c22y2) - c21.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c23.y + c10.x * c11.y * c12.x * c13.x * c13.y * c23.y + 6 * c10.x * c11.y * c12.y * c13.x * c13.y * c23.x - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c23.y - c10.y * c11.x * c12.y * c13.x * c13.y * c23.x + c10.y * c11.y * c12.x * c13.x * c13.y * c23.x + c11.x * c11.y * c12.x * c12.y * c13.x * c23.y - c11.x * c11.y * c12.x * c12.y * c13.y * c23.x + c11.x * c20.x * c12.y * c13.x * c13.y * c23.y + c11.x * c20.y * c12.y * c13.x * c13.y * c23.x + c11.x * c21.x * c12.y * c13.x * c13.y * c22.y + c11.x * c12.y * c13.x * c21.y * c22.x * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c23.y - 6 * c20.x * c11.y * c12.y * c13.x * c13.y * c23.x - c11.y * c12.x * c20.y * c13.x * c13.y * c23.x - c11.y * c12.x * c21.x * c13.x * c13.y * c22.y - c11.y * c12.x * c13.x * c21.y * c22.x * c13.y - 6 * c11.y * c21.x * c12.y * c13.x * c22.x * c13.y - 6 * c10.x * c20.x * c13y3 * c23.x - 6 * c10.x * c21.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c23.x + 6 * c20.x * c21.x * c22.x * c13y3 + 2 * c20.x * c12y3 * c13.x * c23.x + 2 * c21.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c23.y - 6 * c10.x * c10.y * c13.x * c13y2 * c23.x + 3 * c10.x * c11.x * c12.x * c13y2 * c23.y - 2 * c10.x * c11.x * c12.y * c13y2 * c23.x - 4 * c10.x * c11.y * c12.x * c13y2 * c23.x + 3 * c10.y * c11.x * c12.x * c13y2 * c23.x + 6 * c10.x * c10.y * c13x2 * c13.y * c23.y + 6 * c10.x * c20.x * c13.x * c13y2 * c23.y - 3 * c10.x * c11.y * c12.y * c13x2 * c23.y + 2 * c10.x * c12.x * c12y2 * c13.x * c23.y + 2 * c10.x * c12.x * c12y2 * c13.y * c23.x + 6 * c10.x * c20.y * c13.x * c13y2 * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c22.y + 6 * c10.x * c13.x * c21.y * c22.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c23.y + 6 * c10.y * c20.x * c13.x * c13y2 * c23.x + 2 * c10.y * c11.y * c12.x * c13x2 * c23.y - 3 * c10.y * c11.y * c12.y * c13x2 * c23.x + 2 * c10.y * c12.x * c12y2 * c13.x * c23.x + 6 * c10.y * c21.x * c13.x * c22.x * c13y2 - 3 * c11.x * c20.x * c12.x * c13y2 * c23.y + 2 * c11.x * c20.x * c12.y * c13y2 * c23.x + c11.x * c11.y * c12y2 * c13.x * c23.x - 3 * c11.x * c12.x * c20.y * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c22.y - 3 * c11.x * c12.x * c21.y * c22.x * c13y2 + 2 * c11.x * c21.x * c12.y * c22.x * c13y2 + 4 * c20.x * c11.y * c12.x * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c23.y - 6 * c10.y * c20.x * c13x2 * c13.y * c23.y - 6 * c10.y * c20.y * c13x2 * c13.y * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c22.y - 2 * c10.y * c12x2 * c12.y * c13.x * c23.y - 2 * c10.y * c12x2 * c12.y * c13.y * c23.x - 6 * c10.y * c13x2 * c21.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c23.y - 2 * c11.x * c11y2 * c13.x * c13.y * c23.x + 3 * c20.x * c11.y * c12.y * c13x2 * c23.y - 2 * c20.x * c12.x * c12y2 * c13.x * c23.y - 2 * c20.x * c12.x * c12y2 * c13.y * c23.x - 6 * c20.x * c20.y * c13.x * c13y2 * c23.x - 6 * c20.x * c21.x * c13.x * c13y2 * c22.y - 6 * c20.x * c13.x * c21.y * c22.x * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c23.x + 3 * c11.y * c21.x * c12.y * c13x2 * c22.y + 3 * c11.y * c12.y * c13x2 * c21.y * c22.x - 2 * c12.x * c20.y * c12y2 * c13.x * c23.x - 2 * c12.x * c21.x * c12y2 * c13.x * c22.y - 2 * c12.x * c21.x * c12y2 * c22.x * c13.y - 2 * c12.x * c12y2 * c13.x * c21.y * c22.x - 6 * c20.y * c21.x * c13.x * c22.x * c13y2 - c11y2 * c12.x * c12.y * c13.x * c23.x + 2 * c20.x * c12x2 * c12.y * c13.y * c23.y + 6 * c20.y * c13x2 * c21.y * c22.x * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c23.y + c11x2 * c12.x * c12.y * c13.y * c23.y + 2 * c12x2 * c20.y * c12.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c22.y + 2 * c12x2 * c12.y * c21.y * c22.x * c13.y + c21x3 * c13y3 + 3 * c10x2 * c13y3 * c23.x - 3 * c10y2 * c13x3 * c23.y + 3 * c20x2 * c13y3 * c23.x + c11y3 * c13x2 * c23.x - c11x3 * c13y2 * c23.y - c11.x * c11y2 * c13x2 * c23.y + c11x2 * c11.y * c13y2 * c23.x - 3 * c10x2 * c13.x * c13y2 * c23.y + 3 * c10y2 * c13x2 * c13.y * c23.x - c11x2 * c12y2 * c13.x * c23.y + c11y2 * c12x2 * c13.y * c23.x - 3 * c21x2 * c13.x * c21.y * c13y2 - 3 * c20x2 * c13.x * c13y2 * c23.y + 3 * c20y2 * c13x2 * c13.y * c23.x + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c10.y * c13x3 * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c11.y * c12.x * c13x2 * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c12x2 * c12.y * c13.x * (2 * c20.y * c23.y + 2 * c21.y * c22.y) + c11.x * c12.y * c13x2 * (-4 * c20.y * c23.y - 4 * c21.y * c22.y) + c10.x * c13x2 * c13.y * (-6 * c20.y * c23.y - 6 * c21.y * c22.y) + c20.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c21.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21.y * c22.y - c20y2 * c23.y - c21.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c22.y + c10.x * c11.y * c12.x * c13.x * c13.y * c22.y + 6 * c10.x * c11.y * c12.y * c13.x * c22.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c22.y - c10.y * c11.x * c12.y * c13.x * c22.x * c13.y + c10.y * c11.y * c12.x * c13.x * c22.x * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c22.y - c11.x * c11.y * c12.x * c12.y * c22.x * c13.y + c11.x * c20.x * c12.y * c13.x * c13.y * c22.y + c11.x * c20.y * c12.y * c13.x * c22.x * c13.y + c11.x * c21.x * c12.y * c13.x * c21.y * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c22.y - 6 * c20.x * c11.y * c12.y * c13.x * c22.x * c13.y - c11.y * c12.x * c20.y * c13.x * c22.x * c13.y - c11.y * c12.x * c21.x * c13.x * c21.y * c13.y - 6 * c10.x * c20.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c22.x + 2 * c20.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c22.y - 6 * c10.x * c10.y * c13.x * c22.x * c13y2 + 3 * c10.x * c11.x * c12.x * c13y2 * c22.y - 2 * c10.x * c11.x * c12.y * c22.x * c13y2 - 4 * c10.x * c11.y * c12.x * c22.x * c13y2 + 3 * c10.y * c11.x * c12.x * c22.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c13.y * c22.y + 6 * c10.x * c20.x * c13.x * c13y2 * c22.y - 3 * c10.x * c11.y * c12.y * c13x2 * c22.y + 2 * c10.x * c12.x * c12y2 * c13.x * c22.y + 2 * c10.x * c12.x * c12y2 * c22.x * c13.y + 6 * c10.x * c20.y * c13.x * c22.x * c13y2 + 6 * c10.x * c21.x * c13.x * c21.y * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c22.y + 6 * c10.y * c20.x * c13.x * c22.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c22.y - 3 * c10.y * c11.y * c12.y * c13x2 * c22.x + 2 * c10.y * c12.x * c12y2 * c13.x * c22.x - 3 * c11.x * c20.x * c12.x * c13y2 * c22.y + 2 * c11.x * c20.x * c12.y * c22.x * c13y2 + c11.x * c11.y * c12y2 * c13.x * c22.x - 3 * c11.x * c12.x * c20.y * c22.x * c13y2 - 3 * c11.x * c12.x * c21.x * c21.y * c13y2 + 4 * c20.x * c11.y * c12.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c22.y - 6 * c10.y * c20.x * c13x2 * c13.y * c22.y - 6 * c10.y * c20.y * c13x2 * c22.x * c13.y - 6 * c10.y * c21.x * c13x2 * c21.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c22.y - 2 * c10.y * c12x2 * c12.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c22.y - 2 * c11.x * c11y2 * c13.x * c22.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c22.y - 2 * c20.x * c12.x * c12y2 * c13.x * c22.y - 2 * c20.x * c12.x * c12y2 * c22.x * c13.y - 6 * c20.x * c20.y * c13.x * c22.x * c13y2 - 6 * c20.x * c21.x * c13.x * c21.y * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c22.x + 3 * c11.y * c21.x * c12.y * c13x2 * c21.y - 2 * c12.x * c20.y * c12y2 * c13.x * c22.x - 2 * c12.x * c21.x * c12y2 * c13.x * c21.y - c11y2 * c12.x * c12.y * c13.x * c22.x + 2 * c20.x * c12x2 * c12.y * c13.y * c22.y - 3 * c11.y * c21x2 * c12.y * c13.x * c13.y + 6 * c20.y * c21.x * c13x2 * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c22.y + c11x2 * c12.x * c12.y * c13.y * c22.y + 2 * c12x2 * c20.y * c12.y * c22.x * c13.y + 2 * c12x2 * c21.x * c12.y * c21.y * c13.y - 3 * c10.x * c21x2 * c13y3 + 3 * c20.x * c21x2 * c13y3 + 3 * c10x2 * c22.x * c13y3 - 3 * c10y2 * c13x3 * c22.y + 3 * c20x2 * c22.x * c13y3 + c21x2 * c12y3 * c13.x + c11y3 * c13x2 * c22.x - c11x3 * c13y2 * c22.y + 3 * c10.y * c21x2 * c13.x * c13y2 - c11.x * c11y2 * c13x2 * c22.y + c11.x * c21x2 * c12.y * c13y2 + 2 * c11.y * c12.x * c21x2 * c13y2 + c11x2 * c11.y * c22.x * c13y2 - c12.x * c21x2 * c12y2 * c13.y - 3 * c20.y * c21x2 * c13.x * c13y2 - 3 * c10x2 * c13.x * c13y2 * c22.y + 3 * c10y2 * c13x2 * c22.x * c13.y - c11x2 * c12y2 * c13.x * c22.y + c11y2 * c12x2 * c22.x * c13.y - 3 * c20x2 * c13.x * c13y2 * c22.y + 3 * c20y2 * c13x2 * c22.x * c13.y + c12x2 * c12.y * c13.x * (2 * c20.y * c22.y + c21y2) + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c12x3 * c13.y * (-2 * c20.y * c22.y - c21y2) + c10.y * c13x3 * (6 * c20.y * c22.y + 3 * c21y2) + c11.y * c12.x * c13x2 * (-2 * c20.y * c22.y - c21y2) + c11.x * c12.y * c13x2 * (-4 * c20.y * c22.y - 2 * c21y2) + c10.x * c13x2 * c13.y * (-6 * c20.y * c22.y - 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21y2 - c20y2 * c22.y - c20.y * (2 * c20.y * c22.y + c21y2)), -c10.x * c11.x * c12.y * c13.x * c21.y * c13.y + c10.x * c11.y * c12.x * c13.x * c21.y * c13.y + 6 * c10.x * c11.y * c21.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c21.y * c13.y - c10.y * c11.x * c21.x * c12.y * c13.x * c13.y + c10.y * c11.y * c12.x * c21.x * c13.x * c13.y - c11.x * c11.y * c12.x * c21.x * c12.y * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c21.y + c11.x * c20.x * c12.y * c13.x * c21.y * c13.y + 6 * c11.x * c12.x * c20.y * c13.x * c21.y * c13.y + c11.x * c20.y * c21.x * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c13.x * c21.y * c13.y - 6 * c20.x * c11.y * c21.x * c12.y * c13.x * c13.y - c11.y * c12.x * c20.y * c21.x * c13.x * c13.y - 6 * c10.x * c20.x * c21.x * c13y3 - 2 * c10.x * c21.x * c12y3 * c13.x + 6 * c10.y * c20.y * c13x3 * c21.y + 2 * c20.x * c21.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c21.y * c13.y - 2 * c12x3 * c20.y * c21.y * c13.y - 6 * c10.x * c10.y * c21.x * c13.x * c13y2 + 3 * c10.x * c11.x * c12.x * c21.y * c13y2 - 2 * c10.x * c11.x * c21.x * c12.y * c13y2 - 4 * c10.x * c11.y * c12.x * c21.x * c13y2 + 3 * c10.y * c11.x * c12.x * c21.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c21.y * c13.y + 6 * c10.x * c20.x * c13.x * c21.y * c13y2 - 3 * c10.x * c11.y * c12.y * c13x2 * c21.y + 2 * c10.x * c12.x * c21.x * c12y2 * c13.y + 2 * c10.x * c12.x * c12y2 * c13.x * c21.y + 6 * c10.x * c20.y * c21.x * c13.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c21.y + 6 * c10.y * c20.x * c21.x * c13.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c21.y - 3 * c10.y * c11.y * c21.x * c12.y * c13x2 + 2 * c10.y * c12.x * c21.x * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c21.y * c13y2 + 2 * c11.x * c20.x * c21.x * c12.y * c13y2 + c11.x * c11.y * c21.x * c12y2 * c13.x - 3 * c11.x * c12.x * c20.y * c21.x * c13y2 + 4 * c20.x * c11.y * c12.x * c21.x * c13y2 - 6 * c10.x * c20.y * c13x2 * c21.y * c13.y - 2 * c10.x * c12x2 * c12.y * c21.y * c13.y - 6 * c10.y * c20.x * c13x2 * c21.y * c13.y - 6 * c10.y * c20.y * c21.x * c13x2 * c13.y - 2 * c10.y * c12x2 * c21.x * c12.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c21.y - c11.x * c11.y * c12x2 * c21.y * c13.y - 4 * c11.x * c20.y * c12.y * c13x2 * c21.y - 2 * c11.x * c11y2 * c21.x * c13.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c21.y - 2 * c20.x * c12.x * c21.x * c12y2 * c13.y - 2 * c20.x * c12.x * c12y2 * c13.x * c21.y - 6 * c20.x * c20.y * c21.x * c13.x * c13y2 - 2 * c11.y * c12.x * c20.y * c13x2 * c21.y + 3 * c11.y * c20.y * c21.x * c12.y * c13x2 - 2 * c12.x * c20.y * c21.x * c12y2 * c13.x - c11y2 * c12.x * c21.x * c12.y * c13.x + 6 * c20.x * c20.y * c13x2 * c21.y * c13.y + 2 * c20.x * c12x2 * c12.y * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c21.y * c13.y + c11x2 * c12.x * c12.y * c21.y * c13.y + 2 * c12x2 * c20.y * c21.x * c12.y * c13.y + 2 * c12x2 * c20.y * c12.y * c13.x * c21.y + 3 * c10x2 * c21.x * c13y3 - 3 * c10y2 * c13x3 * c21.y + 3 * c20x2 * c21.x * c13y3 + c11y3 * c21.x * c13x2 - c11x3 * c21.y * c13y2 - 3 * c20y2 * c13x3 * c21.y - c11.x * c11y2 * c13x2 * c21.y + c11x2 * c11.y * c21.x * c13y2 - 3 * c10x2 * c13.x * c21.y * c13y2 + 3 * c10y2 * c21.x * c13x2 * c13.y - c11x2 * c12y2 * c13.x * c21.y + c11y2 * c12x2 * c21.x * c13.y - 3 * c20x2 * c13.x * c21.y * c13y2 + 3 * c20y2 * c21.x * c13x2 * c13.y, c10.x * c10.y * c11.x * c12.y * c13.x * c13.y - c10.x * c10.y * c11.y * c12.x * c13.x * c13.y + c10.x * c11.x * c11.y * c12.x * c12.y * c13.y - c10.y * c11.x * c11.y * c12.x * c12.y * c13.x - c10.x * c11.x * c20.y * c12.y * c13.x * c13.y + 6 * c10.x * c20.x * c11.y * c12.y * c13.x * c13.y + c10.x * c11.y * c12.x * c20.y * c13.x * c13.y - c10.y * c11.x * c20.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c20.y * c13.x * c13.y + c10.y * c20.x * c11.y * c12.x * c13.x * c13.y - c11.x * c20.x * c11.y * c12.x * c12.y * c13.y + c11.x * c11.y * c12.x * c20.y * c12.y * c13.x + c11.x * c20.x * c20.y * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c20.y * c13.x * c13.y - 2 * c10.x * c20.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c20.y * c13.y - 3 * c10.x * c10.y * c11.x * c12.x * c13y2 - 6 * c10.x * c10.y * c20.x * c13.x * c13y2 + 3 * c10.x * c10.y * c11.y * c12.y * c13x2 - 2 * c10.x * c10.y * c12.x * c12y2 * c13.x - 2 * c10.x * c11.x * c20.x * c12.y * c13y2 - c10.x * c11.x * c11.y * c12y2 * c13.x + 3 * c10.x * c11.x * c12.x * c20.y * c13y2 - 4 * c10.x * c20.x * c11.y * c12.x * c13y2 + 3 * c10.y * c11.x * c20.x * c12.x * c13y2 + 6 * c10.x * c10.y * c20.y * c13x2 * c13.y + 2 * c10.x * c10.y * c12x2 * c12.y * c13.y + 2 * c10.x * c11.x * c11y2 * c13.x * c13.y + 2 * c10.x * c20.x * c12.x * c12y2 * c13.y + 6 * c10.x * c20.x * c20.y * c13.x * c13y2 - 3 * c10.x * c11.y * c20.y * c12.y * c13x2 + 2 * c10.x * c12.x * c20.y * c12y2 * c13.x + c10.x * c11y2 * c12.x * c12.y * c13.x + c10.y * c11.x * c11.y * c12x2 * c13.y + 4 * c10.y * c11.x * c20.y * c12.y * c13x2 - 3 * c10.y * c20.x * c11.y * c12.y * c13x2 + 2 * c10.y * c20.x * c12.x * c12y2 * c13.x + 2 * c10.y * c11.y * c12.x * c20.y * c13x2 + c11.x * c20.x * c11.y * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c20.y * c13y2 - 2 * c10.x * c12x2 * c20.y * c12.y * c13.y - 6 * c10.y * c20.x * c20.y * c13x2 * c13.y - 2 * c10.y * c20.x * c12x2 * c12.y * c13.y - 2 * c10.y * c11x2 * c11.y * c13.x * c13.y - c10.y * c11x2 * c12.x * c12.y * c13.y - 2 * c10.y * c12x2 * c20.y * c12.y * c13.x - 2 * c11.x * c20.x * c11y2 * c13.x * c13.y - c11.x * c11.y * c12x2 * c20.y * c13.y + 3 * c20.x * c11.y * c20.y * c12.y * c13x2 - 2 * c20.x * c12.x * c20.y * c12y2 * c13.x - c20.x * c11y2 * c12.x * c12.y * c13.x + 3 * c10y2 * c11.x * c12.x * c13.x * c13.y + 3 * c11.x * c12.x * c20y2 * c13.x * c13.y + 2 * c20.x * c12x2 * c20.y * c12.y * c13.y - 3 * c10x2 * c11.y * c12.y * c13.x * c13.y + 2 * c11x2 * c11.y * c20.y * c13.x * c13.y + c11x2 * c12.x * c20.y * c12.y * c13.y - 3 * c20x2 * c11.y * c12.y * c13.x * c13.y - c10x3 * c13y3 + c10y3 * c13x3 + c20x3 * c13y3 - c20y3 * c13x3 - 3 * c10.x * c20x2 * c13y3 - c10.x * c11y3 * c13x2 + 3 * c10x2 * c20.x * c13y3 + c10.y * c11x3 * c13y2 + 3 * c10.y * c20y2 * c13x3 + c20.x * c11y3 * c13x2 + c10x2 * c12y3 * c13.x - 3 * c10y2 * c20.y * c13x3 - c10y2 * c12x3 * c13.y + c20x2 * c12y3 * c13.x - c11x3 * c20.y * c13y2 - c12x3 * c20y2 * c13.y - c10.x * c11x2 * c11.y * c13y2 + c10.y * c11.x * c11y2 * c13x2 - 3 * c10.x * c10y2 * c13x2 * c13.y - c10.x * c11y2 * c12x2 * c13.y + c10.y * c11x2 * c12y2 * c13.x - c11.x * c11y2 * c20.y * c13x2 + 3 * c10x2 * c10.y * c13.x * c13y2 + c10x2 * c11.x * c12.y * c13y2 + 2 * c10x2 * c11.y * c12.x * c13y2 - 2 * c10y2 * c11.x * c12.y * c13x2 - c10y2 * c11.y * c12.x * c13x2 + c11x2 * c20.x * c11.y * c13y2 - 3 * c10.x * c20y2 * c13x2 * c13.y + 3 * c10.y * c20x2 * c13.x * c13y2 + c11.x * c20x2 * c12.y * c13y2 - 2 * c11.x * c20y2 * c12.y * c13x2 + c20.x * c11y2 * c12x2 * c13.y - c11.y * c12.x * c20y2 * c13x2 - c10x2 * c12.x * c12y2 * c13.y - 3 * c10x2 * c20.y * c13.x * c13y2 + 3 * c10y2 * c20.x * c13x2 * c13.y + c10y2 * c12x2 * c12.y * c13.x - c11x2 * c20.y * c12y2 * c13.x + 2 * c20x2 * c11.y * c12.x * c13y2 + 3 * c20.x * c20y2 * c13x2 * c13.y - c20x2 * c12.x * c12y2 * c13.y - 3 * c20x2 * c20.y * c13.x * c13y2 + c12x2 * c20y2 * c12.y * c13.x]);
      roots = poly.rootsInterval(0, 1);
      for (i in roots) {
        if (!__hasProp.call(roots, i)) continue;
        s = roots[i];
        xRoots = new Polynomial([c13.x, c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x]).roots();
        yRoots = new Polynomial([c13.y, c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y]).roots();
        if (xRoots.length > 0 && yRoots.length > 0) {
          tolerance = 1e-2;
          for (j in xRoots) {
            if (!__hasProp.call(xRoots, j)) continue;
            xRoot = xRoots[j];
            if (0 <= xRoot && xRoot <= 1) {
              for (k in yRoots) {
                if (!__hasProp.call(yRoots, k)) continue;
                yRoot = yRoots[k];
                if (Math.abs(xRoot - yRoot) < tolerance) {
                  results.push(c23.multiplyBy(s * s * s).add(c22.multiplyBy(s * s).add(c21.multiplyBy(s).add(c20))));
                }
              }
            }
          }
        }
      }
      return results;
    };

    return CubicBezier;

  })();

  /*
  
      Mondrian SVG library
  
      Artur Sapek 2012 - 2013
  */


  Monsvg = (function() {
    function Monsvg(data) {
      this.data = data != null ? data : {};
      this.rep = this.toSVG();
      this.$rep = $(this.rep);
      this.metadata = {
        angle: 0,
        locked: false
      };
      if (!this.data.dontTrack) {
        this.metadata.uuid = uuid();
      }
      this.rep.setAttribute('uuid', this.metadata.uuid);
      this.validateColors();
      if (this.type !== "text") {
        this.data = $.extend({
          fill: new Color("none"),
          stroke: new Color("none")
        }, this.data);
      }
      this.updateDataArchived();
      if (this.data["mondrian:angle"] != null) {
        this.metadata.angle = parseFloat(this.data["mondrian:angle"], 10);
      }
      /*
      if @data.transform?
        attrs = @data.transform.split(" ")
        for attr in attrs
          key = attr.match(/[a-z]+/gi)?[0]
          val = attr.match(/\([\-\d\,\.]*\)/gi)?[0].replace(/[\(\)]/gi, "")
        @transform[key] = val.replace(/[\(\)]/gi, "")
        #console.log "saved #{attr} as #{key} #{val}"
      */

    }

    Monsvg.prototype.commit = function() {
      /*
      newTransform = []
      
      for own key, val of @transform
        if key is "translate"
          newTransform.push "#{key}(#{val.x},#{val.y})"
        else
          newTransform.push "#{key}(#{val})"
      
      @data.transform = newTransform.join(" ")
      */

      var key, val, _ref;
      _ref = this.data;
      for (key in _ref) {
        val = _ref[key];
        if (key === "") {
          delete this.data[""];
        } else {
          if (("" + val).mentions("NaN")) {
            throw new Error("NaN! Ack. Attribute = " + key + ", Value = " + val);
          }
          this.rep.setAttribute(key, val);
        }
      }
      if (this.metadata.angle === 0) {
        this.rep.removeAttribute('mondrian:angle');
      } else {
        if (this.metadata.angle < 0) {
          this.metadata.angle += 360;
        }
        this.rep.setAttribute('mondrian:angle', this.metadata.angle);
      }
      return this;
    };

    Monsvg.prototype.updateDataArchived = function(attr) {
      if (attr != null) {
        return this.dataArchived[attr] = this.data[attr];
      } else {
        return this.dataArchived = cloneObject(this.data);
      }
    };

    Monsvg.prototype.toSVG = function() {
      var key, self, val, _ref;
      self = document.createElementNS('http://www.w3.org/2000/svg', this.type);
      _ref = this.data;
      for (key in _ref) {
        val = _ref[key];
        if (key !== "") {
          self.setAttribute(key, val);
        }
      }
      return self;
    };

    Monsvg.prototype.validateColors = function() {
      if ((this.data.fill != null) && !(this.data.fill instanceof Color)) {
        this.data.fill = new Color(this.data.fill);
      }
      if ((this.data.stroke != null) && !(this.data.stroke instanceof Color)) {
        this.data.stroke = new Color(this.data.stroke);
      }
      if (this.data["stroke-width"] == null) {
        return this.data["stroke-width"] = 1;
      }
    };

    Monsvg.prototype.points = [];

    Monsvg.prototype.center = function() {
      var xr, yr;
      xr = this.xRange();
      yr = this.yRange();
      return new Posn(xr.min + (xr.max - xr.min) / 2, yr.min + (yr.max - yr.min) / 2);
    };

    Monsvg.prototype.queryPoint = function(rep) {
      return this.points.filter(function(a) {
        return a.baseHandle === rep;
      })[0];
    };

    Monsvg.prototype.queryAntlerPoint = function(rep) {
      return this.antlerPoints.filter(function(a) {
        return a.baseHandle === rep;
      })[0];
    };

    Monsvg.prototype.show = function() {
      return this.rep.style.display = "block";
    };

    Monsvg.prototype.hide = function() {
      return this.rep.style.display = "none";
    };

    Monsvg.prototype.showPoints = function() {
      this.points.map(function(point) {
        return point.show();
      });
      return this;
    };

    Monsvg.prototype.hidePoints = function() {
      this.points.map(function(point) {
        return point.hide();
      });
      return this;
    };

    Monsvg.prototype.unhoverPoints = function() {
      this.points.map(function(point) {
        return point.unhover();
      });
      return this;
    };

    Monsvg.prototype.removePoints = function() {
      this.points.map(function(point) {
        return point.clear();
      });
      return this;
    };

    Monsvg.prototype.unremovePoints = function() {
      this.points.map(function(point) {
        return point.unclear();
      });
      return this;
    };

    Monsvg.prototype.destroyPoints = function() {
      return this.points.map(function(p) {
        return p.remove();
      });
    };

    Monsvg.prototype.removeHoverTargets = function() {
      var existent, ht, _i, _len, _results;
      existent = qa("svg#hover-targets [owner='" + this.metadata.uuid + "']");
      _results = [];
      for (_i = 0, _len = existent.length; _i < _len; _i++) {
        ht = existent[_i];
        _results.push(ht.remove());
      }
      return _results;
    };

    Monsvg.prototype.redrawHoverTargets = function() {
      var _this = this;
      this.removeHoverTargets();
      this.points.map(function(p) {
        return new HoverTarget(p.prec, p);
      });
      return this;
    };

    Monsvg.prototype.topLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().min);
    };

    Monsvg.prototype.topRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().min);
    };

    Monsvg.prototype.bottomRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().max);
    };

    Monsvg.prototype.bottomLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().max);
    };

    Monsvg.prototype.attr = function(data) {
      var key, val, _results;
      _results = [];
      for (key in data) {
        val = data[key];
        if (typeof val === 'function') {
          _results.push(this.data[key] = val(this.data[key]));
        } else {
          _results.push(this.data[key] = val);
        }
      }
      return _results;
    };

    Monsvg.prototype.appendTo = function(selector, track) {
      var target;
      if (track == null) {
        track = true;
      }
      if (typeof selector === "string") {
        target = q(selector);
      } else {
        target = selector;
      }
      target.appendChild(this.rep);
      if (track) {
        if (!ui.elements.has(this)) {
          ui.elements.push(this);
        }
      }
      return this;
    };

    Monsvg.prototype.clone = function() {
      var clone, cloneData, cloneTransform;
      cloneData = cloneObject(this.data);
      cloneTransform = cloneObject(this.transform);
      delete cloneData.id;
      clone = new this.constructor(cloneData);
      clone.transform = cloneTransform;
      return clone;
    };

    Monsvg.prototype["delete"] = function() {
      var _this = this;
      this.rep.remove();
      ui.elements = ui.elements.remove(this);
      return async(function() {
        _this.destroyPoints();
        _this.removeHoverTargets();
        if (_this.group) {
          return _this.group["delete"]();
        }
      });
    };

    Monsvg.prototype.zIndex = function() {
      var zi,
        _this = this;
      zi = 0;
      dom.$main.children().each(function(ind, elem) {
        if (elem.getAttribute("uuid") === _this.metadata.uuid) {
          zi = ind;
          return false;
        }
      });
      return zi;
    };

    Monsvg.prototype.moveForward = function(n) {
      var next, x, _i;
      if (n == null) {
        n = 1;
      }
      for (x = _i = 1; 1 <= n ? _i <= n : _i >= n; x = 1 <= n ? ++_i : --_i) {
        next = this.$rep.next();
        if (next.length === 0) {
          break;
        }
        next.after(this.$rep);
      }
      return this;
    };

    Monsvg.prototype.moveBack = function(n) {
      var prev, x, _i;
      if (n == null) {
        n = 1;
      }
      for (x = _i = 1; 1 <= n ? _i <= n : _i >= n; x = 1 <= n ? ++_i : --_i) {
        prev = this.$rep.prev();
        if (prev.length === 0) {
          break;
        }
        prev.before(this.$rep);
      }
      return this;
    };

    Monsvg.prototype.bringToFront = function() {
      return dom.$main.append(this.$rep);
    };

    Monsvg.prototype.sendToBack = function() {
      return dom.$main.prepend(this.$rep);
    };

    Monsvg.prototype.transform = {};

    Monsvg.prototype.swapFillAndStroke = function() {
      var swap;
      swap = this.data.stroke;
      this.attr({
        'stroke': this.data.fill,
        'fill': swap
      });
      return this.commit();
    };

    Monsvg.prototype.eyedropper = function(sample) {
      this.data.fill = sample.data.fill;
      this.data.stroke = sample.data.stroke;
      this.data['stroke-width'] = sample.data['stroke-width'];
      return this.commit();
    };

    Monsvg.prototype.bounds = function() {
      var cached, xr, yr;
      cached = this.boundsCached;
      if (cached !== null && this.caching) {
        return cached;
      } else {
        xr = this.xRange();
        yr = this.yRange();
        return this.boundsCached = new Bounds(xr.min, yr.min, xr.length(), yr.length());
      }
    };

    Monsvg.prototype.boundsCached = null;

    Monsvg.prototype.hideUI = function() {
      return ui.removePointHandles();
    };

    Monsvg.prototype.refreshUI = function() {
      this.points.map(function(p) {
        return p.updateHandle();
      });
      return this.redrawHoverTargets();
    };

    Monsvg.prototype.overlaps = function(other) {
      return this['overlaps' + other.type.capitalize()](other);
    };

    Monsvg.prototype.lineSegmentsIntersect = function(other) {
      var a, b, continueChecking, mbounds, mline, ms, obounds, oline, os, _i, _j, _len, _len1;
      ms = this.lineSegments();
      os = other.lineSegments();
      for (_i = 0, _len = ms.length; _i < _len; _i++) {
        mline = ms[_i];
        if (mline instanceof CubicBezier) {
          mbounds = mline.bounds(true);
        }
        a = mline instanceof LineSegment ? mline.a : mline.p1;
        b = mline instanceof LineSegment ? mline.b : mline.p2;
        if ((other.contains(a)) || (other.contains(b))) {
          return true;
        }
        for (_j = 0, _len1 = os.length; _j < _len1; _j++) {
          oline = os[_j];
          if (mline instanceof CubicBezier || oline instanceof CubicBezier) {
            obounds = oline.bounds(true);
            continueChecking = mbounds.overlapsBounds(obounds);
          } else {
            continueChecking = true;
          }
          if (continueChecking) {
            if (mline.intersects(oline)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    Monsvg.prototype.lineSegmentIntersections = function(other) {
      var inter, intersections, mbounds, mline, ms, obounds, oline, os, _i, _j, _len, _len1;
      intersections = [];
      ms = this.lineSegments();
      os = other.lineSegments();
      for (_i = 0, _len = ms.length; _i < _len; _i++) {
        mline = ms[_i];
        mbounds = mline.bounds(true);
        for (_j = 0, _len1 = os.length; _j < _len1; _j++) {
          oline = os[_j];
          obounds = oline.bounds(true);
          inter = mline.intersection(oline);
          if (inter instanceof Posn) {
            intersections.push({
              intersection: [inter],
              aline: mline,
              bline: oline,
              a: mline.source,
              b: oline.source
            });
          } else if (inter instanceof Array && inter.length > 0) {
            intersections.push({
              intersection: inter,
              aline: mline,
              bline: oline,
              a: mline.source,
              b: oline.source
            });
          }
        }
      }
      return intersections;
    };

    Monsvg.prototype.remove = function() {
      this.rep.remove();
      if (this.points !== []) {
        return this.points.map(function(p) {
          var _ref;
          return (_ref = p.baseHandle) != null ? _ref.remove() : void 0;
        });
      }
    };

    Monsvg.prototype.convertTo = function(type) {
      var result;
      result = this["convertTo" + type]();
      result.eyedropper(this);
      return result;
    };

    Monsvg.prototype.toString = function() {
      return "(" + this.type + " Monsvg object)";
    };

    Monsvg.prototype.repToString = function() {
      return new XMLSerializer().serializeToString(this.rep);
    };

    Monsvg.prototype.carryOutTransformations = function(transform, center) {
      var attr, attrs, factor, key, val, x, y, _i, _len, _ref, _ref1, _results;
      if (transform == null) {
        transform = this.data.transform;
      }
      if (center == null) {
        center = new Posn(0, 0);
      }
      /*
        We do things this way because fuck the transform attribute.
      
        Basically, when we commit shapes for the first time from some other file,
        if they have a transform attribute we effectively just alter the data
        that makes those shapes up so that they still look the same, but they no longer
        have a transform attr.
      */

      attrs = transform.replace(", ", ",").split(" ").reverse();
      _results = [];
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        attr = attrs[_i];
        key = (_ref = attr.match(/[a-z]+/gi)) != null ? _ref[0] : void 0;
        val = (_ref1 = attr.match(/\([\-\d\,\.]*\)/gi)) != null ? _ref1[0].replace(/[\(\)]/gi, "") : void 0;
        switch (key) {
          case "scale":
            factor = parseFloat(val);
            this.scale(factor, factor, center);
            _results.push(this.data["stroke-width"] *= factor);
            break;
          case "translate":
            val = val.split(",");
            x = parseFloat(val[0]);
            y = val[1] != null ? parseFloat(val[1]) : 0;
            _results.push(this.nudge(x, -y));
            break;
          case "rotate":
            this.rotate(parseFloat(val), center);
            _results.push(this.metadata.angle = 0);
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };

    Monsvg.prototype.applyTransform = function(transform) {
      var attr, key, val, x, y, _i, _len, _ref, _ref1, _ref2;
      console.log("apply transform");
      _ref = transform.split(" ");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        key = (_ref1 = attr.match(/[a-z]+/gi)) != null ? _ref1[0] : void 0;
        val = (_ref2 = attr.match(/\([\-\d\,\.]*\)/gi)) != null ? _ref2[0].replace(/[\(\)]/gi, "") : void 0;
        switch (key) {
          case "scale":
            val = parseFloat(val);
            if (this.transform.scale != null) {
              this.transform.scale *= val;
            } else {
              this.transform.scale = val;
            }
            break;
          case "translate":
            val = val.split(",");
            x = parseFloat(val[0]);
            y = parseFloat(val[1]);
            x = parseFloat(x);
            y = parseFloat(y);
            if (this.transform.translate != null) {
              this.transform.translate.x += x;
              this.transform.translate.y += y;
            } else {
              this.transform.translate = {
                x: x,
                y: y
              };
            }
            break;
          case "rotate":
            val = parseFloat(val);
            if (this.transform.rotate != null) {
              this.transform.rotate += val;
              this.transform.rotate %= 360;
            } else {
              this.transform.rotate = val;
            }
        }
      }
      return this.commit();
    };

    Monsvg.prototype.setFill = function(val) {
      return this.data.fill = new Color(val);
    };

    Monsvg.prototype.setStroke = function(val) {
      return this.data.stroke = new Color(val);
    };

    Monsvg.prototype.setStrokeWidth = function(val) {
      return this.data['stroke-width'] = val;
    };

    Monsvg.prototype.setupToCanvas = function(context) {
      var _ref;
      context.beginPath();
      context.fillStyle = "" + this.data.fill;
      if (((this.data['stroke-width'] != null) > 0) && (((_ref = this.data.stroke) != null ? _ref.hex : void 0) !== "none")) {
        context.strokeStyle = "" + this.data.stroke;
        context.lineWidth = parseFloat(this.data['stroke-width']);
      } else {
        context.strokeStyle = "none";
        context.lineWidth = "0";
      }
      return context;
    };

    Monsvg.prototype.finishToCanvas = function(context) {
      var _ref, _ref1;
      if ((_ref = this.points) != null ? _ref.closed : void 0) {
        context.closePath();
      }
      context.fill();
      if ((this.data['stroke-width'] > 0) && (((_ref1 = this.data.stroke) != null ? _ref1.hex : void 0) !== "none")) {
        context.stroke();
      }
      return context;
    };

    Monsvg.prototype.clearCachedObjects = function() {};

    Monsvg.prototype.lineSegments = function() {};

    return Monsvg;

  })();

  /*
  
    HoverTarget
  */


  HoverTarget = (function(_super) {
    __extends(HoverTarget, _super);

    HoverTarget.prototype.type = 'path';

    function HoverTarget(a, b, width) {
      this.a = a;
      this.b = b;
      this.width = width;
      if (this.width == null) {
        this.width = 1;
      }
      this.owner = this.b.owner;
      b = this.b instanceof SmoothTo ? this.b.toCurveTo() : this.b;
      this.d = "M" + (this.a.x * ui.canvas.zoom) + "," + (this.a.y * ui.canvas.zoom) + " " + (b.toStringWithZoom());
      this.data = {
        fill: "none",
        stroke: "rgba(75, 175, 255, 0.0)",
        "stroke-width": 4 / ui.canvas.zoom,
        d: this.d
      };
      this.b.hoverTarget = this;
      HoverTarget.__super__.constructor.call(this, this.data);
      this.appendTo('#hover-targets', false);
      this.rep.setAttribute('a', this.a.at);
      this.rep.setAttribute('b', this.b.at);
      this.rep.setAttribute('owner', this.owner.metadata.uuid);
    }

    HoverTarget.prototype.highlight = function() {
      ui.unhighlightHoverTargets();
      this.a.hover();
      this.b.hover();
      this.attr({
        "stroke-width": 5,
        stroke: "#4981e0"
      });
      ui.hoverTargetsHighlighted.push(this);
      return this.commit();
    };

    HoverTarget.prototype.unhighlight = function() {
      this.attr({
        "stroke-width": 5,
        stroke: "rgba(75, 175, 255, 0.0)"
      });
      return this.commit();
    };

    HoverTarget.prototype.active = function() {
      this.a.baseHandle.setAttribute('active', '');
      return this.b.baseHandle.setAttribute('active', '');
    };

    HoverTarget.prototype.nudge = function(x, y) {
      this.a.nudge(x, y);
      this.b.nudge(x, y);
      this.owner.commit();
      this.unhighlight();
      return this.constructor(this.a, this.b, this.width);
    };

    return HoverTarget;

  })(Monsvg);

  /*
  
    Line
  */


  Line = (function(_super) {
    __extends(Line, _super);

    function Line() {
      _ref = Line.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Line.prototype.type = 'line';

    Line.prototype.a = function() {
      return new Posn(this.data.x1, this.data.y1);
    };

    Line.prototype.b = function() {
      return new Posn(this.data.x2, this.data.y2);
    };

    Line.prototype.absorbA = function(a) {
      this.data.x1 = a.x;
      return this.data.y1 = a.y;
    };

    Line.prototype.absorbB = function(b) {
      this.data.x2 = b.x;
      return this.data.y2 = b.y;
    };

    Line.prototype.asLineSegment = function() {
      return new LineSegment(this.a(), this.b());
    };

    Line.prototype.fromLineSegment = function(ls) {
      this.absorbA(ls.a);
      return this.absorbB(ls.b);
    };

    Line.prototype.xRange = function() {
      return this.asLineSegment().xRange();
    };

    Line.prototype.yRange = function() {
      return this.asLineSegment().yRange();
    };

    Line.prototype.nudge = function(x, y) {
      this.data.x1 += x;
      this.data.x2 += x;
      this.data.y1 -= y;
      this.data.y2 -= y;
      return this.commit();
    };

    Line.prototype.scale = function(x, y, origin) {
      this.absorbA(this.a().scale(x, y, origin));
      this.absorbB(this.b().scale(x, y, origin));
      return this.commit();
    };

    Line.prototype.overlapsRect = function(rect) {
      var l, ls, _i, _len, _ref1;
      ls = this.asLineSegment();
      if (this.a().insideOf(rect)) {
        return true;
      }
      if (this.b().insideOf(rect)) {
        return true;
      }
      _ref1 = rect.lineSegments();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        l = _ref1[_i];
        if (l.intersects(ls)) {
          return true;
        }
      }
      return false;
    };

    return Line;

  })(Monsvg);

  Rect = (function(_super) {
    __extends(Rect, _super);

    Rect.prototype.type = 'rect';

    function Rect(data) {
      this.data = data;
      Rect.__super__.constructor.call(this, this.data);
      if (this.data.x == null) {
        this.data.x = 0;
      }
      if (this.data.y == null) {
        this.data.y = 0;
      }
      this.data.x = parseFloat(this.data.x);
      this.data.y = parseFloat(this.data.y);
      this.data.width = parseFloat(this.data.width);
      this.data.height = parseFloat(this.data.height);
    }

    Rect.prototype.commit = function() {
      this._validateDimensions();
      return Rect.__super__.commit.apply(this, arguments);
    };

    Rect.prototype.points = function() {
      return [new Point(this.data.x, this.data.y), new Point(this.data.x + this.data.width, this.data.y), new Point(this.data.x + this.data.width, this.data.y + this.data.height), new Point(this.data.x, this.data.y + this.data.height)];
    };

    /*
    
      Geometric data
    
        points()
        lineSegments()
        center()
        xRange()
        yRange()
    */


    Rect.prototype.lineSegments = function() {
      var p;
      p = this.points();
      return [new LineSegment(p[0], p[1], p[1]), new LineSegment(p[1], p[2], p[2]), new LineSegment(p[2], p[3], p[3]), new LineSegment(p[3], p[0], p[0])];
    };

    Rect.prototype.center = function() {
      return new Posn(this.data.x + (this.data.width / 2), this.data.y + (this.data.height / 2));
    };

    Rect.prototype.xRange = function() {
      return new Range(this.data.x, this.data.x + this.data.width);
    };

    Rect.prototype.yRange = function() {
      return new Range(this.data.y, this.data.y + this.data.height);
    };

    Rect.prototype.clearCachedObjects = function() {};

    /*
    
      Relationship analysis
    
        contains()
        overlaps()
        intersections()
        containments()
        containmentsBothWays()
    */


    Rect.prototype.contains = function(posn) {
      return this.xRange().contains(posn.x) && this.yRange().contains(posn.y);
    };

    Rect.prototype.overlaps = function(other) {
      /*
        Fuck you whore
        Redirects to appropriate method.
      
        I/P: Polygon/Circle/Rect
        O/P: true or false
      */

      return this['overlaps' + other.type.capitalize()](other);
    };

    Rect.prototype.overlapsPolygon = function(polygon) {
      if (this.contains(polygon.center() || polygon.contains(this.center()))) {
        return true;
      }
      return this.lineSegmentsIntersect(polygon);
    };

    Rect.prototype.overlapsCircle = function(circle) {};

    Rect.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Rect.prototype.intersections = function(obj) {
      var inter, intersections, s1, s2, _i, _j, _len, _len1, _ref1, _ref2;
      intersections = [];
      _ref1 = this.lineSegments();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        s1 = _ref1[_i];
        _ref2 = obj.lineSegments();
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          s2 = _ref2[_j];
          inter = s1.intersection(s2);
          if (inter instanceof Posn) {
            intersections.push(inter);
          }
        }
      }
      return intersections;
    };

    Rect.prototype.containments = function(obj) {
      var containments, point, points, xr, yr, _i, _len;
      containments = [];
      points = obj.points;
      xr = this.xRange();
      yr = this.yRange();
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        if (xr.contains(point.x) && yr.contains(point.y)) {
          containments.push(point);
        }
      }
      return containments;
    };

    Rect.prototype.containmentsBothWays = function(obj) {
      return this.containments(obj).concat(obj.containments(this));
    };

    Rect.prototype.scale = function(factorX, factorY, origin) {
      var _this = this;
      if (origin == null) {
        origin = this.center();
      }
      this.attr({
        x: function(x) {
          return (x - origin.x) * factorX + origin.x;
        },
        y: function(y) {
          return (y - origin.y) * factorY + origin.y;
        },
        width: function(w) {
          return w * factorX;
        },
        height: function(h) {
          return h * factorY;
        }
      });
      return this.commit();
    };

    Rect.prototype.nudge = function(x, y) {
      this.data.x += x;
      this.data.y -= y;
      return this.commit();
    };

    Rect.prototype.convertToPath = function() {
      var path, pts;
      pts = this.points();
      path = new Path({
        d: "M" + pts[0] + " L" + pts[1] + " L" + pts[2] + " L" + pts[3] + " L" + pts[0]
      });
      path.eyedropper(this);
      path.updateDataArchived();
      return path;
    };

    Rect.prototype.drawToCanvas = function(context) {
      context = this.setupToCanvas(context);
      context.rect(this.data.x, this.data.y, this.data.width, this.data.height);
      return context = this.finishToCanvas(context);
    };

    Rect.prototype._validateDimensions = function() {
      if (this.data.height < 0) {
        this.data.height *= -1;
      }
      if (this.data.width < 0) {
        return this.data.width *= -1;
      }
    };

    return Rect;

  })(Monsvg);

  Circle = (function(_super) {
    __extends(Circle, _super);

    function Circle() {
      _ref1 = Circle.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Circle.prototype.type = 'circle';

    Circle.prototype.scale = function(factor, origin) {
      this.attr({
        'r': function(r) {
          return r * factor;
        }
      });
      return this.commit();
    };

    Circle.prototype.scaleXY = function(x, y, origin) {};

    Circle.prototype.points = [];

    Circle.prototype.center = function() {
      return new Posn(this.data.cx, this.data.cy);
    };

    Circle.prototype.xRange = function() {
      return new Range(this.data.cx - this.data.r, this.data.cx + this.data.r);
    };

    Circle.prototype.yRange = function() {
      return new Range(this.data.cy - this.data.r, this.data.cy + this.data.r);
    };

    Circle.prototype.overlaps = function(other) {
      /*
        Checks for overlap with another shape.
        Redirects to appropriate method.
      
        I/P: Polygon/Circle/Rect
        O/P: true or false
      */

      return this['overlaps' + other.type.capitalize()](other);
    };

    Circle.prototype.overlapsPolygon = function(polygon) {
      var line, _i, _len, _ref2;
      if (polygon.contains(this.center())) {
        return true;
      }
      _ref2 = polygon.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        if (line.intersects(this)) {
          return true;
        }
      }
      return false;
    };

    Circle.prototype.overlapsCircle = function(circle) {};

    Circle.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Circle.prototype.nudge = function(x, y) {
      this.attr({
        cx: function(cx) {
          return cx += x;
        },
        cy: function(cy) {
          return cy -= y;
        }
      });
      return this.commit();
    };

    return Circle;

  })(Monsvg);

  /*
  
    Ellipse
  */


  Ellipse = (function(_super) {
    __extends(Ellipse, _super);

    Ellipse.prototype.type = 'ellipse';

    function Ellipse(data) {
      this.data = data;
      Ellipse.__super__.constructor.call(this, this.data);
      this.data.cx = parseFloat(this.data.cx);
      this.data.cy = parseFloat(this.data.cy);
      this.data.rx = parseFloat(this.data.rx);
      this.data.ry = parseFloat(this.data.ry);
    }

    Ellipse.prototype.xRange = function() {
      return new Range(this.data.cx - this.data.rx, this.data.cx + this.data.rx);
    };

    Ellipse.prototype.yRange = function() {
      return new Range(this.data.cy - this.data.ry, this.data.cy + this.data.ry);
    };

    Ellipse.prototype.c = function() {
      return new Posn(this.data.cx, this.data.cy);
    };

    Ellipse.prototype.top = function() {
      return new Posn(this.data.cx, this.data.cy - this.data.ry);
    };

    Ellipse.prototype.right = function() {
      return new Posn(this.data.cx + this.data.rx, this.data.cy);
    };

    Ellipse.prototype.bottom = function() {
      return new Posn(this.data.cx, this.data.cy + this.data.ry);
    };

    Ellipse.prototype.left = function() {
      return new Posn(this.data.cx - this.data.rx, this.data.cy);
    };

    Ellipse.prototype.overlapsRect = function(r) {
      var l, _i, _len, _ref2;
      _ref2 = r.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        l = _ref2[_i];
        if ((l.intersectionWithEllipse(this)) instanceof Array) {
          return true;
        }
      }
    };

    Ellipse.prototype.nudge = function(x, y) {
      this.data.cx += x;
      this.data.cy -= y;
      return this.commit();
    };

    Ellipse.prototype.scale = function(x, y, origin) {
      var c;
      c = this.c().scale(x, y, origin);
      this.data.cx = c.x;
      this.data.cy = c.y;
      this.data.rx *= x;
      this.data.ry *= y;
      return this.commit();
    };

    Ellipse.prototype.convertToPath = function() {
      var bottom, kx, ky, left, p, right, rx, ry, top;
      p = new Path({
        d: "M" + this.data.cx + "," + (this.data.cy - this.data.ry)
      });
      p.eyedropper(this);
      top = this.top();
      right = this.right();
      bottom = this.bottom();
      left = this.left();
      rx = this.data.rx;
      ry = this.data.ry;
      ky = Math.KAPPA * ry;
      kx = Math.KAPPA * rx;
      p.points.push(new CurveTo(top.x + kx, top.y, right.x, right.y - ky, right.x, right.y));
      p.points.push(new CurveTo(right.x, right.y + ky, bottom.x + kx, bottom.y, bottom.x, bottom.y));
      p.points.push(new CurveTo(bottom.x - kx, bottom.y, left.x, left.y + ky, left.x, left.y));
      p.points.push(new CurveTo(left.x, left.y - ky, top.x - kx, top.y, top.x, top.y));
      p.points.close();
      p.points.drawBasePoints();
      p.updateDataArchived();
      return p;
    };

    return Ellipse;

  })(Monsvg);

  Polygon = (function(_super) {
    __extends(Polygon, _super);

    Polygon.prototype.type = 'polygon';

    function Polygon(data) {
      this.data = data;
      this.points = new PointsList(this.parsePoints(this.data.points));
      Polygon.__super__.constructor.call(this, this.data);
    }

    Polygon.prototype.appendTo = function(selector, track) {
      if (track == null) {
        track = true;
      }
      Polygon.__super__.appendTo.call(this, selector, track);
      this.points.drawBasePoints().hide();
      if (track) {
        this.redrawHoverTargets();
      }
      return this;
    };

    Polygon.prototype.commit = function() {
      this.data.points = this.points.toString();
      return Polygon.__super__.commit.apply(this, arguments);
    };

    Polygon.prototype.lineSegments = function() {
      var points, segments;
      points = this.points.points;
      segments = [];
      points.map(function(curr, ind) {
        var next;
        next = points[ind === (points.length - 1) ? 0 : ind + 1];
        return segments.push(new LineSegment(curr, next));
      });
      return segments;
    };

    Polygon.prototype.xs = function() {
      return this.points.all().map(function(posn) {
        return posn.x;
      });
    };

    Polygon.prototype.ys = function() {
      return this.points.all().map(function(posn) {
        return posn.y;
      });
    };

    Polygon.prototype.xRange = function() {
      return new Range().fromList(this.xs());
    };

    Polygon.prototype.yRange = function() {
      return new Range().fromList(this.ys());
    };

    Polygon.prototype.topLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().min);
    };

    Polygon.prototype.topRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().min);
    };

    Polygon.prototype.bottomRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().max);
    };

    Polygon.prototype.bottomLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().max);
    };

    Polygon.prototype.bounds = function() {
      var xr, yr;
      xr = this.xRange();
      yr = this.yRange();
      return new Bounds(xr.min, yr.min, xr.length(), yr.length());
    };

    Polygon.prototype.center = function() {
      return this.bounds().center();
    };

    Polygon.prototype.parsePoints = function() {
      var points,
        _this = this;
      if (this.data.points === '') {
        return [];
      }
      points = [];
      this.data.points = this.data.points.match(/[\d\,\. ]/gi).join('');
      this.data.points.split(' ').map(function(coords) {
        var p, x, y;
        coords = coords.split(',');
        if (coords.length === 2) {
          x = parseFloat(coords[0]);
          y = parseFloat(coords[1]);
          p = new Point(x, y, _this);
          return points.push(p);
        }
      });
      return points;
    };

    Polygon.prototype.clearCachedObjects = function() {};

    /*
      Transformations
        rotate
        nudge
    */


    Polygon.prototype.rotate = function(angle, center) {
      var _this = this;
      if (center == null) {
        center = this.center();
      }
      this.points.map(function(p) {
        return p.rotate(angle, center);
      });
      this.metadata.angle += angle;
      return this.metadata.angle %= 360;
    };

    Polygon.prototype.scale = function(x, y, origin) {
      if (origin == null) {
        origin = this.center();
      }
      this.points.map(function(p) {
        return p.scale(x, y, origin);
      });
      return this.commit();
    };

    Polygon.prototype.nudge = function(x, y) {
      this.points.map(function(p) {
        return p.nudge(x, y);
      });
      return this.commit();
    };

    Polygon.prototype.contains = function(posn) {
      return posn.insideOf(this.lineSegments());
    };

    Polygon.prototype.overlaps = function(other) {
      return this['overlaps' + other.type.capitalize()](other);
    };

    Polygon.prototype.overlapsPolygon = function(polygon) {
      var line, polyLine, _i, _j, _len, _len1, _ref2, _ref3;
      if (this.contains(polygon.center() || polygon.contains(this.center()))) {
        return true;
      }
      _ref2 = this.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        if (polygon.contains(line.a || polygon.contains(line.b))) {
          return true;
        }
        _ref3 = polygon.lineSegments();
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          polyLine = _ref3[_j];
          if (polyLine.intersects(line)) {
            return true;
          }
        }
      }
      return false;
    };

    Polygon.prototype.overlapsCircle = function(circle) {};

    Polygon.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Polygon.prototype.convertToPath = function() {
      var lt, old, p, path, _i, _len, _ref2;
      path = new Path({
        d: "M" + (this.points.at(0).x) + "," + (this.points.at(0).y)
      });
      path.eyedropper(this);
      old = path.points.at(0);
      _ref2 = this.points.all().slice(1);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        lt = new LineTo(p.x, p.y, path, old, false);
        path.points.push(lt);
        old = lt;
      }
      path.points.close();
      return path;
    };

    return Polygon;

  })(Monsvg);

  Polyline = (function(_super) {
    __extends(Polyline, _super);

    function Polyline() {
      _ref2 = Polyline.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Polyline.prototype.convertToPath = function() {
      var lt, old, p, path, _i, _len, _ref3;
      path = new Path({
        d: "M" + (this.points.at(0).x) + "," + (this.points.at(0).y)
      });
      path.eyedropper(this);
      old = path.points.at(0);
      _ref3 = this.points.all().slice(1);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        lt = new LineTo(p.x, p.y, path, old, false);
        path.points.push(lt);
        old = lt;
      }
      return path;
    };

    return Polyline;

  })(Polygon);

  /*
  
    Path
  
    Highest order of vector data. Lowest level of expression.
  */


  Path = (function(_super) {
    __extends(Path, _super);

    Path.prototype.type = 'path';

    function Path(data) {
      var _ref3, _ref4, _ref5;
      this.data = data;
      Path.__super__.constructor.call(this, this.data);
      if (((_ref3 = this.data) != null ? _ref3.d : void 0) != null) {
        this.importNewPoints(this.data.d);
      }
      this.antlerPoints = new PointsList([], this);
      if (((_ref4 = this.data) != null ? (_ref5 = _ref4.d) != null ? _ref5.match(/z$/gi) : void 0 : void 0) !== null) {
        this.points.closed = true;
      }
    }

    Path.prototype.caching = true;

    Path.prototype.commit = function() {
      this.data.d = this.points.toString();
      return Path.__super__.commit.apply(this, arguments);
    };

    Path.prototype.hover = function() {
      if (!ui.selection.elements.all.has(this)) {
        this.showPoints();
      }
      return ui.unhighlightHoverTargets();
    };

    Path.prototype.unhover = function() {
      return this.hidePoints();
    };

    Path.prototype.virgin = void 0;

    Path.prototype.virginMode = function() {
      this.virgin.eyedropper(this);
      return this.$rep.replaceWith(this.virgin.$rep);
    };

    Path.prototype.editMode = function() {
      return this.virgin.$rep.replaceWith(this.$rep);
    };

    Path.prototype.woohoo = function() {
      return this.virgin = void 0;
    };

    Path.prototype.importNewPoints = function(points) {
      if (points instanceof PointsList) {
        this.points = points;
      } else {
        this.points = new PointsList(points, this);
      }
      this.points = this.points.absolute();
      this.clearCachedObjects();
      return this;
    };

    Path.prototype.cleanUpPoints = function() {
      var p, _i, _len, _ref3;
      _ref3 = this.points.all();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        p.cleanUp();
      }
      return this.commit();
    };

    Path.prototype.appendTo = function(selector, track) {
      if (track == null) {
        track = true;
      }
      Path.__super__.appendTo.call(this, selector, track);
      this.points.drawBasePoints().hide();
      if (track) {
        this.redrawHoverTargets();
      }
      return this;
    };

    Path.prototype.xRange = function() {
      var cached;
      cached = this.xRangeCached;
      if (cached !== null) {
        return cached;
      } else {
        return this.xRangeCached = new Range().fromRangeList(this.lineSegments().map(function(x) {
          return x.xRange();
        }));
      }
    };

    Path.prototype.xRangeCached = null;

    Path.prototype.yRange = function() {
      var cached;
      cached = this.yRangeCached;
      if (cached !== null) {
        return cached;
      } else {
        return this.yRangeCached = new Range().fromRangeList(this.lineSegments().map(function(x) {
          return x.yRange();
        }));
      }
    };

    Path.prototype.yRangeCached = null;

    Path.prototype.nudgeCachedObjects = function(x, y) {
      var _ref3, _ref4, _ref5, _ref6;
      if ((_ref3 = this.boundsCached) != null) {
        _ref3.nudge(x, y);
      }
      if ((_ref4 = this.xRangeCached) != null) {
        _ref4.nudge(x);
      }
      if ((_ref5 = this.yRangeCached) != null) {
        _ref5.nudge(y);
      }
      return (_ref6 = this.lineSegmentsCached) != null ? _ref6.map(function(ls) {
        return ls.nudge(x, y);
      }) : void 0;
    };

    Path.prototype.scaleCachedObjects = function(x, y, origin) {
      var _ref3, _ref4, _ref5;
      if ((_ref3 = this.boundsCached) != null) {
        _ref3.scale(x, y, origin);
      }
      if ((_ref4 = this.xRangeCached) != null) {
        _ref4.scale(x, origin.x);
      }
      if ((_ref5 = this.yRangeCached) != null) {
        _ref5.scale(y, origin.y);
      }
      return this.lineSegmentsCached = null;
      /*
      @lineSegmentsCached.map (ls) ->
        ls.scale(x, y, origin)
      */

    };

    Path.prototype.clearCachedObjects = function() {
      this.lineSegmentsCached = null;
      this.boundsCached = null;
      this.xRangeCached = null;
      this.yRangeCached = null;
      return this;
    };

    Path.prototype.lineSegments = function() {
      var cached, segments,
        _this = this;
      cached = this.lineSegmentsCached;
      if (cached !== null) {
        return cached;
      } else {
        segments = [];
        this.points.all().map(function(curr, ind) {
          return segments.push(lab.conversions.pathSegment(curr, curr.succ));
        });
        return this.lineSegmentsCached = segments;
      }
    };

    Path.prototype.lineSegmentsCached = null;

    Path.prototype.scale = function(x, y, origin) {
      var angle, _ref3,
        _this = this;
      if (origin == null) {
        origin = this.center();
      }
      this.scaleCachedObjects(x, y, origin);
      angle = this.metadata.angle;
      if (angle !== 0) {
        this.rotate(360 - angle, origin);
      }
      this.points.map(function(a) {
        return a.scale(x, y, origin);
      });
      if (angle !== 0) {
        this.rotate(angle, origin);
      }
      this.commit();
      return (_ref3 = this.virgin) != null ? _ref3.scale(x, y, origin) : void 0;
    };

    Path.prototype.nudge = function(x, y) {
      var _ref3;
      this.points.map(function(p) {
        return p.nudge(x, y, false);
      });
      this.nudgeCachedObjects(x, y);
      this.commit();
      return (_ref3 = this.virgin) != null ? _ref3.nudge(x, y) : void 0;
    };

    Path.prototype.rotate = function(a, origin) {
      if (origin == null) {
        origin = this.center();
      }
      this.metadata.angle += a;
      this.metadata.angle %= 360;
      this.clearCachedObjects();
      this.points.map(function(p) {
        return p.rotate(a, origin);
      });
      this.commit();
      return this.woohoo();
    };

    Path.prototype.fitToBounds = function(bounds) {
      var mb, myHeight, myWidth, sx, sy;
      this.clearCachedObjects();
      mb = this.bounds();
      myWidth = mb.width;
      myHeight = mb.height;
      sx = bounds.width / mb.width;
      sy = bounds.height / mb.height;
      if ((isNaN(sx)) || (sx === Infinity) || (sx === -Infinity) || (sx === 0)) {
        sx = 1;
      }
      if ((isNaN(sy)) || (sy === Infinity) || (sy === -Infinity) || (sy === 0)) {
        sy = 1;
      }
      sx = Math.max(1e-5, sx);
      sy = Math.max(1e-5, sy);
      this.scale(sx, sy, new Posn(mb.x, mb.y));
      this.nudge(bounds.x - mb.x, mb.y - bounds.y);
      if (this.points.toString().indexOf("NaN") > -1) {
        debugger;
      }
    };

    Path.prototype.overlapsRect = function(rect) {
      var point, _i, _len, _ref3;
      if (this.bounds().overlapsBounds(rect.bounds())) {
        _ref3 = this.points.all();
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          point = _ref3[_i];
          if (point.insideOf(rect)) {
            return true;
          }
        }
        return this.lineSegmentsIntersect(rect);
      } else {
        return false;
      }
    };

    Path.prototype.drawToCanvas = function(context) {
      var point, _i, _len, _ref3;
      context = this.setupToCanvas(context);
      _ref3 = this.points.all();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        point = _ref3[_i];
        switch (point.constructor) {
          case MoveTo:
            context.moveTo(point.x, point.y);
            break;
          case LineTo:
          case HorizTo:
          case VertiTo:
            context.lineTo(point.x, point.y);
            break;
          case CurveTo:
          case SmoothTo:
            context.bezierCurveTo(point.x2, point.y2, point.x3, point.y3, point.x, point.y);
        }
      }
      return this.finishToCanvas(context);
    };

    return Path;

  })(Monsvg);

  /*
  */


  Text = (function(_super) {
    __extends(Text, _super);

    Text.prototype.type = 'text';

    function Text(data, content) {
      this.data = data;
      this.content = content != null ? content : "";
      this.data = $.extend({
        x: 0,
        y: 0,
        'font-size': ui.utilities.typography.sizeControl.read(),
        'font-family': ui.utilities.typography.faceControl.selected.val
      }, this.data);
      this.data.x = float(this.data.x);
      this.data.y = float(this.data.y);
      Text.__super__.constructor.call(this, this.data);
      this.transformations = new Transformations(this, [new RotateTransformation(0), new ScaleTransformation(1, 1), new TranslateTransformation(0, 0)]);
      this.origin = new Posn(this.data.x, this.data.y);
      this.textEditable = new TextEditable(this);
      this;
    }

    Text.prototype.caching = false;

    Text.prototype.setContent = function(content) {
      this.content = content;
      return this.commit();
    };

    Text.prototype.setSize = function(size) {
      return this.data['font-size'] = size;
    };

    Text.prototype.setFace = function(face) {
      return this.data['font-family'] = face;
    };

    Text.prototype.commit = function() {
      this.data.x = this.origin.x;
      this.data.y = this.origin.y;
      this.rep.textContent = this.content;
      this.transformations.commit();
      return Text.__super__.commit.apply(this, arguments);
    };

    Text.prototype.editableMode = function() {
      this.textEditable.show();
      this.hide();
      ui.textEditing = this;
      return ui.selection.elements.deselectAll();
    };

    Text.prototype.displayMode = function() {
      this.textEditable.hide();
      this.show();
      ui.textEditing = void 0;
      return this.adjustForScale();
    };

    Text.prototype.show = function() {
      return this.rep.style.display = "block";
    };

    Text.prototype.hide = function() {
      return this.rep.style.display = "none";
    };

    Text.prototype.originRotated = function() {
      return this.origin.clone().rotate(this.metadata.angle, this.center());
    };

    Text.prototype.simulateInSandbox = function() {
      return $("#text-sandbox").text(this.content).css({
        'font-size': this.data['font-size'],
        'font-family': this.data['font-family']
      });
    };

    Text.prototype.selectAll = function() {
      this.editableMode();
      this.textEditable.focus();
      document.execCommand('selectAll', false, null);
    };

    Text.prototype["delete"] = function() {
      Text.__super__["delete"].apply(this, arguments);
      return this.textEditable.hide();
    };

    Text.prototype.toSVG = function() {
      var self;
      self = Text.__super__.toSVG.apply(this, arguments);
      self.textContent = this.content;
      return self;
    };

    Text.prototype.normalizedOrigin = function() {
      return this.origin.clone().rotate(-this.metadata.angle, this.center());
    };

    Text.prototype.nudge = function(x, y) {
      this.origin.nudge(x, y);
      this.adjustForScale();
      return this.commit();
    };

    Text.prototype.rotate = function(a, origin, adjust) {
      var nc, oc;
      if (origin == null) {
        origin = this.center();
      }
      if (adjust == null) {
        adjust = true;
      }
      this.metadata.angle += a;
      this.metadata.angle %= 360;
      oc = this.center();
      nc = this.center().rotate(a, origin);
      this.origin.nudge(nc.x - oc.x, oc.y - nc.y);
      this.transformations.get('rotate').rotate(a);
      if (adjust) {
        this.adjustForScale();
      }
      return this.commit();
    };

    Text.prototype.scale = function(x, y, origin) {
      var angle;
      angle = this.metadata.angle;
      if (angle !== 0) {
        this.rotate(360 - angle, origin);
      }
      this.origin.scale(x, y, origin);
      this.transformations.get('scale').scale(x, y);
      this.adjustForScale();
      if (angle !== 0) {
        this.rotate(angle, origin);
      }
      return this.commit();
    };

    Text.prototype.adjustForScale = function() {
      var a, scale, translate;
      scale = this.transformations.get('scale');
      translate = this.transformations.get('translate');
      a = this.metadata.angle;
      this.rotate(-a, this.center(), false);
      translate.y = ((scale.y - 1) / scale.y) * -this.origin.y;
      translate.x = ((scale.x - 1) / scale.x) * -this.origin.x;
      this.rotate(a, this.center(), false);
      return this.commit();
    };

    Text.prototype.hover = function() {
      if (ui.selection.elements.all.has(this)) {

      }
      /*
      $("#text-underline").show().css
        left: @origin.x * ui.canvas.zoom
        top:  @origin.y * ui.canvas.zoom
        width: "#{@width() * ui.canvas.zoom}px"
      */

    };

    Text.prototype.unhover = function() {
      return $("#text-underline").hide();
    };

    Text.prototype.drawToCanvas = function() {};

    Text.prototype.clone = function() {
      var cloned;
      cloned = Text.__super__.clone.apply(this, arguments);
      cloned.setContent(this.content);
      return cloned;
    };

    Text.prototype.width = function() {
      this.simulateInSandbox();
      return $("#text-sandbox")[0].clientWidth * this.transformations.get('scale').x;
    };

    Text.prototype.height = function() {
      return this.data['font-size'] * this.transformations.get('scale').y;
    };

    Text.prototype.xRange = function() {
      return new Range(this.origin.x, this.origin.x + this.width());
    };

    Text.prototype.yRange = function() {
      return new Range(this.origin.y - this.height(), this.origin.y);
    };

    Text.prototype.overlapsRect = function(rect) {
      return this.bounds().toRect().overlaps(rect);
    };

    Text.prototype.setupToCavnas = function(context) {
      var orr, scale;
      scale = this.transformations.get('scale');
      orr = this.originRotated();
      context.translate(orr.x, orr.y);
      context.rotate(this.metadata.angle * (Math.PI / 180));
      context.scale(scale.x, scale.y);
      context.font = "" + this.data['font-size'] + "px " + this.data['font-family'];
      return context;
    };

    Text.prototype.drawToCanvas = function(context) {
      var scale;
      scale = this.transformations.get('scale');
      context = this.setupToCavnas(context);
      context.fillText(this.content.strip(), 0, 0);
      return context = this.finishToCanvas(context);
    };

    Text.prototype.finishToCanvas = function(context) {
      var orr, scale;
      scale = this.transformations.get('scale');
      orr = this.originRotated();
      context.scale(1 / scale.x, 1 / scale.y);
      context.rotate(-this.metadata.angle * (Math.PI / 180));
      context.translate(-orr.x, -orr.y);
      return context;
    };

    return Text;

  })(Monsvg);

  /*
  
    TextEditable
  
    A content-editable <p> that lives in the #typography div
    Used to edit the contents of a Text object, each of which
    are tied to one of these.
  */


  TextEditable = (function() {
    function TextEditable(owner) {
      this.owner = owner;
    }

    TextEditable.prototype.refresh = function() {
      var left, myOffset, ownerOffset, resetToBlank, top, tr;
      this.$rep.text(this.owner.content);
      if (this.owner.data['font-size'] != null) {
        this.$rep.css({
          'font-size': float(this.owner.data['font-size']) * ui.canvas.zoom + 'px'
        });
      }
      if (this.owner.data['font-family'] != null) {
        this.$rep.css({
          'font-family': this.owner.data['font-family']
        });
      }
      tr = this.owner.transformations.get('translate');
      if (this.owner.rep.textContent === '') {
        resetToBlank = true;
        this.owner.rep.textContent = '[FILLER]';
        this.$rep.text('[FILLER]');
      }
      ownerOffset = this.owner.$rep.offset();
      left = ownerOffset.left - ui.canvas.normal.x;
      top = ownerOffset.top - ui.canvas.normal.y;
      this.$rep.css({
        left: left.px(),
        top: top.px(),
        color: this.owner.data.fill
      });
      /*
      @rep.style.textShadow = @owner.data.strokeWidth.px()
      @rep.style.webkitTextStrokeWidth = @owner.data.strokeWidth.px()
      */

      this.$rep.css;
      this.owner.transformations.applyAsCSS(this.rep);
      myOffset = this.$rep.offset();
      if (resetToBlank) {
        this.$rep.text('');
        this.owner.rep.textContent = '';
      }
      return this.$rep.css({
        left: (left + ownerOffset.left - myOffset.left).px(),
        top: (top + ownerOffset.top - myOffset.top).px()
      });
    };

    TextEditable.prototype.show = function() {
      var _this = this;
      this.$rep = $("<div class=\"text\" contenteditable=\"true\"\n   quarantine spellcheck=\"false\">" + this.owner.content + "</div>");
      this.rep = this.$rep[0];
      $('#typography').append(this.$rep);
      this.$rep.one('blur', function() {
        _this.commit();
        return _this.owner.displayMode();
      });
      this.rep.style.display = "block";
      return this.refresh();
    };

    TextEditable.prototype.hide = function() {
      if (this.rep == null) {
        return;
      }
      this.rep.remove();
      return this.rep = void 0;
    };

    TextEditable.prototype.focus = function() {
      return this.$rep.focus();
    };

    TextEditable.prototype.commit = function() {
      var newOr, oldOr;
      oldOr = this.owner.originRotated();
      this.owner.setContent(this.$rep.text().replace(/$\s+/g, ''));
      newOr = this.owner.originRotated();
      return this.owner.nudge(oldOr.x - newOr.x, oldOr.y - newOr.y);
    };

    return TextEditable;

  })();

  /*
  */


  Tspan = (function(_super) {
    __extends(Tspan, _super);

    Tspan.prototype.type = 'tspan';

    function Tspan(data) {
      this.data = data;
    }

    return Tspan;

  })(Monsvg);

  /*
  
    Pathfinder
  
    Union, subtract, intersect.
  
    In-progress; this is still unstable, buggy. Not available through UI yet.
    To invoke "Union", select elements and hit "U" on the keyboard.
  */


  DEBUGGING = true;

  pathfinder = {
    merge: function(elems) {
      var elemClones, finalResult, first, merged, second, _ref3;
      this._reset();
      elemClones = elems.map(function(elem) {
        return elem.clone();
      });
      while (elemClones.length > 1) {
        _ref3 = [elemClones[0], elemClones[1]], first = _ref3[0], second = _ref3[1];
        merged = this._mergePair(first, second);
        elemClones = [merged].concat(elemClones.slice(2));
      }
      finalResult = elemClones[0];
      finalResult.appendTo('#main');
      finalResult.eyedropper(elems[0]);
      return ui.selection.elements.select(finalResult);
    },
    _segments: [],
    _segmentAccumulation: [],
    _intersections: [],
    _keep: function(point) {
      this._segmentAccumulation.push(point);
      if (DEBUGGING) {
        ui.annotations.drawDot(point, ui.colors.black.hex, 4);
      }
      return point.flag('kept');
    },
    _commitCurrentSegment: function() {
      if (this._segmentAccumulation.length === 0) {
        return;
      }
      this._segments.push(new PointsSegment(this._segmentAccumulation).ensureMoveTo());
      return this._segmentAccumulation = [];
    },
    _getIntersection: function(point) {
      var fil;
      fil = this._intersections.filter(function(int) {
        return int.intersection.has(function(p) {
          return p.equal(point);
        });
      });
      if (fil.length > 0) {
        return fil[0];
      }
    },
    _packageSegmentsIntoPathElement: function() {
      var pathElement, pointsList;
      pointsList = new PointsList([], [], this._segments);
      pathElement = new Path({
        d: pointsList.toString(),
        fill: new Color(0, 0, 0, 0.4).toRGBString(),
        stroke: ui.colors.black.hex
      });
      return pathElement;
    },
    _reset: function() {
      return this._segments = this._segmentAccumulation = this._intersections = [];
    },
    _splitAtIntersections: function(elem, intersections) {
      var inter, ls, lsSplit, newListOfPoints, originalPoint, posns, workingPoints, _i, _len, _ref3;
      if (intersections.length === 0) {
        return elem;
      }
      workingPoints = elem.points.all();
      _ref3 = elem.lineSegments();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        ls = _ref3[_i];
        inter = intersections.filter(function(int) {
          return (int.aline.equal(ls)) || (int.bline.equal(ls));
        });
        if (inter.length > 0) {
          originalPoint = ls.source;
          if (originalPoint.succ instanceof SmoothTo) {
            originalPoint.succ.replaceWithCurveTo();
          }
          posns = inter.reduce(function(x, y) {
            return x.concat(y.intersection);
          }, []);
          posns = posns.filter(function(p) {
            var valid;
            valid = workingPoints.filter(function(x) {
              return x.within(0.1, p);
            }).length === 0;
            if (valid) {
              workingPoints.push(p);
            }
            return valid;
          });
          lsSplit = ls.splitAt(posns);
          newListOfPoints = lsSplit.map(function(lx) {
            return lx.source;
          });
          newListOfPoints.slice(0, newListOfPoints.length - 1).forEach(function(p) {
            return p.flag('desired');
          });
          elem.points.replace(originalPoint, newListOfPoints);
        }
      }
      return elem;
    },
    _desiredPointsRemaining: function(points) {
      return points.filter(function(p) {
        return (p.flagged('desired')) && (!(p.flagged('kept')));
      });
    },
    _findAndSplitIntersections: function(a, b) {
      this._intersections = lab.analysis.intersections(a, b);
      a = this._splitAtIntersections(a, this._intersections);
      b = this._splitAtIntersections(b, this._intersections);
      return [a, b];
    },
    _removeOverlappingAdjecentPoints: function(elem) {
      return elem.points.forEach(function(p) {
        if (p.within(1e-5, p.succ)) {
          return elem.points.remove(p);
        }
      });
    },
    _flagDesiredPoints: function(a, b) {
      a.points.all().forEach(function(point) {
        if (!point.insideOf(b)) {
          return point.flag('desired');
        }
      });
      b.points.all().forEach(function(point) {
        if (!point.insideOf(a)) {
          return point.flag('desired');
        }
      });
      return [a, b];
    },
    _mergePair: function(first, second) {
      var pointsAlternate, pointsWalking, result, _ref3, _ref4;
      this._intersections = lab.analysis.intersections(first, second);
      _ref3 = this._findAndSplitIntersections(first, second), first = _ref3[0], second = _ref3[1];
      _ref4 = this._flagDesiredPoints(first, second), first = _ref4[0], second = _ref4[1];
      pointsWalking = first.points.withoutMoveTos();
      pointsAlternate = second.points.withoutMoveTos();
      this._walk(pointsWalking, pointsAlternate);
      result = this._packageSegmentsIntoPathElement();
      this._reset();
      return result;
    },
    _walk: function(pointsWalking, pointsAlternate) {
      var current, desiredPoint, desiredPointsRemaining, desiredSegment, intersection, optionA, optionB, otherSamePoint, point, points, pointsRemainingAlternate, pointsRemainingWalking, precTooClose, segment, succTooClose, _i, _j, _len, _len1, _ref3;
      current = pointsWalking.owner;
      _ref3 = pointsWalking.segments;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        segment = _ref3[_i];
        points = segment.points;
        if (points[0].flagged('kept')) {
          this._commitCurrentSegment();
          pointsRemainingWalking = this._desiredPointsRemaining(pointsWalking);
          pointsRemainingAlternate = this._desiredPointsRemaining(pointsAlternate);
          if ((pointsRemainingWalking.length === 0) || (pointsRemainingAlternate.length === 0)) {
            return;
          }
          if (pointsRemainingWalking.length > 0) {
            pointsWalking.movePointToFront(pointsRemainingWalking[0]);
            return this._walk(pointsWalking, pointsAlternate);
          } else if (pointsRemainingAlternate.length > 0) {
            pointsAlternate.movePointToFront(pointsRemainingAlternate[0]);
            return this._walk(pointsAlternate, pointsWalking);
          }
        }
        for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
          point = points[_j];
          if (DEBUGGING) {
            ui.annotations.drawDot(point, ui.colors.green.hex, 8);
          }
          intersection = this._getIntersection(point);
          if (intersection) {
            otherSamePoint = pointsAlternate.filter(function(p) {
              return p.equal(point);
            })[0];
            otherSamePoint.flag('kept');
            optionA = lab.conversions.pathSegment(otherSamePoint, otherSamePoint.succ);
            optionB = lab.conversions.pathSegment(otherSamePoint.prec, otherSamePoint);
            if (otherSamePoint.within(1e-2, otherSamePoint.succ)) {
              succTooClose = true;
            }
            if (otherSamePoint.within(1e-2, otherSamePoint.prec)) {
              precTooClose = true;
            }
            if (!(optionA.midPoint().insideOf(current))) {
              desiredPoint = otherSamePoint.succ;
            } else if (!(optionB.midPoint().insideOf(current))) {
              pointsAlternate = pointsAlternate.reverse();
              otherSamePoint = pointsAlternate.filter(function(p) {
                return p.equal(point);
              })[0];
              desiredPoint = otherSamePoint.succ;
            } else {
              print("PANIC");
            }
            desiredSegment = desiredPoint.segment;
            pointsAlternate.moveSegmentToFront(desiredSegment);
            desiredSegment.movePointToFront(desiredPoint);
            this._keep(point);
            return this._walk(pointsAlternate, pointsWalking);
          } else {
            if (point.flagged('kept')) {
              break;
            } else {
              this._keep(point);
            }
          }
        }
        this._commitCurrentSegment();
        desiredPointsRemaining = this._desiredPointsRemaining(segment.points);
        if (desiredPointsRemaining.length === 0) {
          if (pointsWalking.segments.without(segment).length === 0) {
            this._walk(pointsAlternate, pointsWalking);
          } else {
            pointsWalking.segments = pointsWalking.segments.cannibalize();
            this._walk(pointsWalking, pointsAlternate);
          }
        } else {
          segment.movePointToFront(desiredPointsRemaining[0]);
          this._walk(pointsWalking, pointsAlternate);
        }
      }
      this._commitCurrentSegment();
      return this._walk(pointsAlternate, pointsWalking);
    }
  };

  /*
  
    File
  
    An SVG file representation in Mondy.
    Extends into various subclasses that are designed to
    work with different file Services.
  */


  File = (function() {
    function File(key, name, path, thumbnail, contents) {
      this.key = key;
      this.name = name;
      this.path = path;
      this.thumbnail = thumbnail;
      this.contents = contents;
      this;
    }

    File.prototype.fromService = function(service) {
      switch (service) {
        case services.local:
          return function(key) {
            return new LocalFile(key);
          };
        case services.permalink:
          return function(key) {
            return new PermalinkFile(key);
          };
        case services.dropbox:
          return function(name, path, modified) {
            return new DropboxFile(name, path, modified);
          };
      }
    };

    File.prototype.use = function(overwrite) {
      var _this = this;
      if (overwrite == null) {
        overwrite = false;
      }
      ui.file = this;
      ui.menu.refresh();
      if (("" + window.location.pathname + window.location.search) !== this.expectedURL()) {
        history.replaceState("", "", this.expectedURL());
      }
      ui.menu.items.filename.refresh();
      if (this.contents != null) {
        if (overwrite) {
          io.parseAndAppend(this.contents);
          if (this.archive != null) {
            archive.loadFromString(this.archive);
            ui.utilities.history.deleteThumbsCached().build();
            delete this.archive;
          } else {
            console.log("No saved archive found that matches the file, starting with a fresh one.");
            archive.setup();
          }
        }
      } else {
        this.load(function() {
          return _this.use();
        });
      }
      return this;
    };

    File.prototype.get = function(ok, error) {
      this.service.get(this.key, ok, error);
      return this;
    };

    File.prototype.put = function(ok, error) {
      this.service.put(this.key, this.contents, ok, error);
      return this;
    };

    File.prototype.set = function(contents) {
      this.contents = contents != null ? contents : io.makeFile();
      return this;
    };

    File.prototype.save = function(ok) {
      this.set();
      this.put(ok);
      return this;
    };

    File.prototype.hasChanges = function() {
      return this.contents !== io.makeFile();
    };

    File.prototype.toString = function() {
      var data;
      data = {
        key: this.key,
        name: this.name,
        path: this.path,
        service: this.service.name
      };
      return data.toString();
    };

    File.prototype.expectedURL = function() {
      switch (this.constructor) {
        case PermalinkFile:
          return "/?p=" + this.key;
        default:
          return "/";
      }
    };

    File.prototype.readonly = false;

    return File;

  })();

  window.LocalFile = LocalFile;

  window.File = File;

  LocalFile = (function(_super) {
    __extends(LocalFile, _super);

    function LocalFile(key) {
      this.key = key;
      this.service = services.local;
      this.name = this.key;
      this.path = "";
      this.displayLocation = "local storage";
      this.load();
      LocalFile.__super__.constructor.call(this, this.key, this.name, this.path, this.thumbnail, this.contents);
      this;
    }

    LocalFile.prototype.load = function(ok) {
      var _this = this;
      if (ok == null) {
        ok = function() {};
      }
      this.get(function(data) {
        _this.contents = data.contents;
        _this.archive = data.archive;
        if (_this === ui.file) {
          _this.use(true);
        }
        return ok(data);
      });
      return this;
    };

    return LocalFile;

  })(File);

  window.LocalFile = LocalFile;

  PermalinkFile = (function(_super) {
    __extends(PermalinkFile, _super);

    function PermalinkFile(key) {
      this.key = key;
      this.service = services.permalink;
      this.path = "";
      this.displayLocation = "permalink ";
      PermalinkFile.__super__.constructor.call(this, this.key, this.name, this.path, this.thumbnail);
    }

    PermalinkFile.prototype.load = function() {
      var _this = this;
      this.get(function(data) {
        _this.contents = data.contents;
        _this.name = data.file_name;
        if (_this === ui.file) {
          return _this.use();
        }
      });
      return this;
    };

    PermalinkFile.prototype.use = function(overwrite) {
      PermalinkFile.__super__.use.call(this, overwrite);
      if (this.contents != null) {
        return history.replaceState("", "", "/?p=" + this.key);
      }
    };

    return PermalinkFile;

  })(File);

  DropboxFile = (function(_super) {
    __extends(DropboxFile, _super);

    function DropboxFile(key) {
      this.key = key;
      this.service = services.dropbox;
      this.name = this.key.match(/[^\/]+$/)[0];
      this.path = this.key.substring(0, this.key.length - this.name.length);
      this.displayLocation = this.key;
      DropboxFile.__super__.constructor.call(this, this.key, this.name, this.path, this.thumbnail);
    }

    DropboxFile.prototype.load = function(ok) {
      var _this = this;
      if (ok == null) {
        ok = function() {};
      }
      this.get((function(data) {
        _this.contents = data.contents;
        archive.get();
        if (_this === ui.file) {
          _this.use(true);
        }
        return ok(data);
      }), (function(error) {
        _this.contents = io.makeFile();
        if (_this === ui.file) {
          return _this.use(true);
        }
      }));
      return this;
    };

    DropboxFile.prototype.put = function(ok) {
      archive.put();
      return DropboxFile.__super__.put.call(this, ok);
    };

    return DropboxFile;

  })(File);

  /*
  
    Preload new visitors' files with a sample file
  */


  demoFiles = {
    albq: "<svg id=\"main\" width=\"800\" height=\"470.59\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:mondrian=\"http://mondrian.io/xml\" viewbox=\"0 0 800 470.59\" enable-background=\"new 0 0 800 470.59\" style=\"width: 800px; height: 470.59px; -webkit-transform: scale(1);\">\n  <rect opacity=\"1\" fill=\"rgb(199, 15, 46)\" fill-opacity=\"1\" stroke=\"none\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"miter\" stroke-miterlimit=\"4\" stroke-dasharray=\"none\" stroke-opacity=\"1\" id=\"rect3491\" width=\"800\" height=\"470.58984\" x=\"0\" y=\"0.00015633789\" >\n  </rect>\n  <path id=\"path3290\" fill=\"rgb(245, 220, 15)\" fill-rule=\"evenodd\" stroke=\"none\" stroke-width=\"1px\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-opacity=\"1\" fill-opacity=\"1\" d=\"M394.625,383.43375 C381.16854,383.95982 376.92586,396.10106 374.875,403.46875 C372.73136,411.16976 373.54029,423.67459 382,423.7775 C385.09344,423.81513 388.0005,422.0739 390.09375,420.21875 L384.875,442.21875 L393.5,442.21875 L404.4375,395.78125 C404.95468,393.59667 404.72172,391.07616 403.75,388.875 C401.94548,384.78738 398.68662,383.27496 394.625,383.43375 M393.34375,389.78125 C395.26133,389.83533 397.13959,390.74597 396.53125,393.3125 L391.25,415.59375 C379.11731,421.56397 381.42886,411.35222 383.375,402.96875 C384.35154,398.76206 386.57754,392.68705 390.3125,390.4375 C391.02749,390.00687 392.1932,389.7488 393.34375,389.78125 M421.3125,384.09 L412.75,384.09 L407.9375,404.7775 C405.17878,416.63643 409.35555,423.26919 414.875,423.7775 C418.15997,424.08003 421.54456,422.35493 423.87944,419.06596 L422.75,423.09 L431.25,423.09 L440.5625,384.09 L432,384.09 L425.44194,411.70796 C423.41424,416.12473 419.5936,418.94076 416.3125,416.465 C413.65852,414.46243 415.31018,409.25358 416.4375,404.5275 L421.3125,384.09 M516.95447,383.43375 C503.49801,383.95982 499.25533,396.10106 497.20447,403.46875 C495.06083,411.16976 495.86976,423.67459 504.32947,423.7775 C507.42291,423.81513 510.32997,422.0739 512.42322,420.21875 L507.20447,442.21875 L515.82947,442.21875 L526.76697,395.78125 C527.28415,393.59667 527.05119,391.07616 526.07947,388.875 C524.27495,384.78738 521.01609,383.27496 516.95447,383.43375 M515.67322,389.78125 C517.5908,389.83533 519.46906,390.74597 518.86072,393.3125 L513.57947,415.59375 C501.44678,421.56397 503.75833,411.35222 505.70447,402.96875 C506.68101,398.76206 508.90701,392.68705 512.64197,390.4375 C513.35696,390.00687 514.52267,389.7488 515.67322,389.78125 M545.76329,384.09 L537.20079,384.09 L532.38829,404.7775 C529.62957,416.63643 533.80634,423.26919 539.32579,423.7775 C542.61076,424.08003 545.99535,422.35493 548.33023,419.06596 L547.20079,423.09 L555.70079,423.09 L565.01329,384.09 L556.45079,384.09 L549.89273,411.70796 C547.86503,416.12473 544.04439,418.94076 540.76329,416.465 C538.10931,414.46243 539.76097,409.25358 540.88829,404.5275 L545.76329,384.09 M463.125,383.40625 C455.93939,383.74932 452.75701,386.31345 449.25,390.09375 C444.85824,394.82776 442.19997,401.01352 441.375,408.21875 C440.52947,415.60356 444.72557,423.74517 451.375,423.78125 C456.75995,423.80993 461.45192,422.15464 465.5,416.34375 L463.05676,413.12906 C461.40372,415.01424 460.23986,415.98258 458.39644,416.78384 C455.27512,418.14056 451.48107,419.23399 449.73995,415.69399 C449.17445,414.54425 449.16151,412.84294 449.3125,410.71875 C463.67766,411.06162 470.27579,400.56019 471.13756,396.15181 C472.74417,387.93325 468.44611,383.1522 463.125,383.40625 M463.5,397.46875 C461.95149,401.52548 455.46221,405.30317 449.75628,405.35447 C450.96482,396.91546 454.90118,389.33747 459.875,388.96875 C465.30667,388.56609 464.31332,395.33803 463.5,397.46875 M587.92935,383.40625 C580.74374,383.74932 577.56136,386.31345 574.05435,390.09375 C569.66259,394.82776 567.00432,401.01352 566.17935,408.21875 C565.33382,415.60356 569.52992,423.74517 576.17935,423.78125 C581.5643,423.80993 586.25627,422.15464 590.30435,416.34375 L587.86111,413.12906 C586.20807,415.01424 585.04421,415.98258 583.20079,416.78384 C580.07947,418.14056 576.28542,419.23399 574.5443,415.69399 C573.9788,414.54425 573.96586,412.84294 574.11685,410.71875 C588.48201,411.06162 595.08014,400.56019 595.94191,396.15181 C597.54852,387.93325 593.25046,383.1522 587.92935,383.40625 M588.30435,397.46875 C586.75584,401.52548 580.26656,405.30317 574.56063,405.35447 C575.76917,396.91546 579.70553,389.33747 584.67935,388.96875 C590.11102,388.56609 589.11767,395.33803 588.30435,397.46875 M354.84446,384.09 L346.28196,384.09 L341.46946,404.7775 C338.71074,416.63643 342.88751,423.26919 348.40696,423.7775 C351.69193,424.08003 355.07652,422.35493 357.4114,419.06596 L356.28196,423.09 L364.78196,423.09 L374.09446,384.09 L365.53196,384.09 L358.9739,411.70796 C356.9462,416.12473 353.12556,418.94076 349.84446,416.465 C347.19048,414.46243 348.84214,409.25358 349.96946,404.5275 L354.84446,384.09 M315.37813,423.7775 C328.83459,423.25143 333.07727,411.11019 335.12813,403.7425 C337.27177,396.04149 336.46284,383.53666 328.00313,383.43375 C324.90969,383.39612 322.00263,385.13735 319.90938,386.9925 L326.25313,360.6175 L317.62813,360.6175 L306.19063,408.055 C304.45111,415.86104 306.38136,423.3441 315.37813,423.7775 M314.09688,410.52375 L318.75313,391.6175 C330.88582,385.64728 328.57427,395.85903 326.62813,404.2425 C325.65159,408.44919 323.42559,414.5242 319.69063,416.77375 C314.56894,418.67038 312.88313,415.66403 314.09688,410.52375 M287.15663,416.63765 L300.625,360.715 L309.25,360.715 L294.375,423.09 C289.83883,422.57067 288.15033,419.55539 287.15663,416.63765 M494.4375,384.09375 C491.55707,384.26624 488.73052,385.9659 486.6875,388.84375 L487.8125,384.8125 L479.3125,384.8125 L470,423.8125 L478.5625,423.8125 L485.125,396.1875 C488.08663,390.36739 493.58787,391.43816 496.71859,393.15257 L499.90625,386.03125 C498.68568,384.92568 497.25033,384.26893 495.6875,384.125 C495.27688,384.08718 494.84899,384.06911 494.4375,384.09375 M279.34375,353.0625 C275.35785,353.05705 272.13945,354.9123 269.75,357.34375 C276.33396,354.89877 284.97578,355.42612 282.125,367.09375 L275.375,394.6875 C267.83796,396.40612 261.51167,396.33588 255.90625,394.78125 C256.435,393.02259 256.96397,391.34882 257.5,389.84375 C262.21528,376.6043 269.37175,365.06154 275.5,359.34375 C275.25117,359.31468 275.00252,359.28736 274.75,359.28125 C266.9218,359.09196 257.68856,368.03927 250.5,385.34375 C247.42153,392.75433 246.52867,401.53171 246.90625,412.0625 C246.9977,414.61292 245.96073,415.84375 242.75,415.84375 L233.8125,415.84375 C230.06115,415.84375 227.31254,418.60908 225.40625,421.6875 C224.45847,423.21805 223.15246,423.71875 221.40625,423.71875 L211.03125,423.71875 C206.57801,423.71875 202.74003,429.12391 201.59375,431.6875 L215.4375,431.71875 C218.9619,431.7267 222.90385,430.22707 223.84375,427.28125 C224.45839,425.35484 225.23385,423.84375 227.1875,423.84375 L237.25,423.84375 C246.53998,423.84375 250.83126,411.82928 254.15625,400.71875 C259.90669,403.23586 266.88029,402.82892 273.59375,401.96875 L270,416.71875 C270.94199,419.86009 274.014,423.09375 277.25,423.09375 L289.625,371.21875 C291.17932,364.70318 292.03438,357.19937 285.25,354.34375 C283.12988,353.45137 281.15552,353.06498 279.34375,353.0625 M243.78125,404.53125 C244.30746,389.04608 250.37557,371.20112 262.15257,362.43138 C242.39633,365.95552 238.5331,389.72437 243.78125,404.53125z\" >\n  </path>\n  <path opacity=\"1\" fill=\"rgb(245, 220, 15)\" fill-opacity=\"1\" fill-rule=\"evenodd\" stroke=\"none\" stroke-width=\"1px\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-opacity=\"1\" d=\"M140.80512,124.44307 C140.48954,116.8959 137.95674,109.29261 133.84446,102.14704 C145.40584,83.622779 143.15705,58.912707 127.06066,42.816361 C120.00663,35.762334 111.31952,31.366697 102.20147,29.624435 C104.88234,31.270212 107.41539,33.247368 109.73654,35.568516 C122.55956,48.391552 125.06105,67.622572 117.27168,82.966804 C109.71805,77.067306 100.88709,72.515567 91.572737,67.697681 C84.623787,64.10338 79.717594,57.217864 77.806247,40.45197 C71.216273,40.15034 66.12818,42.142295 62.316259,45.954216 C58.504317,49.766157 56.512369,54.854243 56.814014,61.444203 C73.579929,63.355529 80.465367,68.261662 84.059727,75.210691 C88.877607,84.525041 93.429347,93.356005 99.328847,100.90964 C83.984607,108.69901 64.753659,106.19759 51.930561,93.374496 C49.609412,91.053347 47.632256,88.520293 45.98648,85.839425 C47.728734,94.957482 52.124456,103.64465 59.178405,110.69861 C75.274701,126.79491 99.984907,129.04385 118.50909,117.48242 C125.65466,121.59469 133.25786,124.12744 140.80512,124.44307z\" id=\"path3404\" >\n  </path>\n  <path opacity=\"1\" fill=\"rgb(245, 220, 15)\" fill-opacity=\"1\" stroke=\"none\" stroke-width=\"11.78761100999999900\" stroke-linecap=\"round\" stroke-linejoin=\"miter\" stroke-miterlimit=\"4\" stroke-dasharray=\"none\" stroke-opacity=\"1\" d=\"M384.15625,22.34375 L384.15625,129.125 C381.52847,129.81543 378.98223,130.67432 376.5,131.6875 L376.5,46.03125 L364.5,46.03125 L364.5,138.1875 C358.29317,142.49038 352.89663,147.88692 348.59375,154.09375 L256.4375,154.09375 L256.4375,166.09375 L342.09375,166.09375 C341.08057,168.57598 340.22168,171.12222 339.53125,173.75 L232.75,173.75 L232.75,185.75 L337.625,185.5 C337.53694,186.85258 337.5,188.21954 337.5,189.59375 C337.5,190.96796 337.53694,192.33501 337.625,193.6875 L232.75,193.4375 L232.75,205.4375 L339.53125,205.4375 C340.22168,208.06458 341.08057,210.61248 342.09375,213.09375 L256.4375,213.09375 L256.4375,225.09375 L348.625,225.09375 C352.92561,231.28867 358.29982,236.67401 364.5,240.96875 L364.5,333.15625 L376.5,333.15625 L376.5,247.46875 C378.98223,248.48097 381.52847,249.34152 384.15625,250.03125 L384.15625,356.84375 L396.15625,356.84375 L395.90625,251.9375 C397.25883,252.02546 398.62579,252.0625 400,252.0625 C401.37421,252.0625 402.74117,252.02546 404.09375,251.9375 L403.84375,356.84375 L415.84375,356.84375 L415.84375,250.03125 C418.47153,249.34152 421.01777,248.48097 423.5,247.46875 L423.5,333.15625 L435.5,333.15625 L435.5,240.96875 C441.70018,236.67401 447.07439,231.28867 451.375,225.09375 L543.5625,225.09375 L543.5625,213.09375 L457.90625,213.09375 C458.91943,210.61248 459.77832,208.06458 460.46875,205.4375 L567.25,205.4375 L567.25,193.4375 L462.375,193.6875 C462.46306,192.33501 462.5,190.96796 462.5,189.59375 C462.5,188.21954 462.46306,186.85258 462.375,185.5 L567.25,185.75 L567.25,173.75 L460.46875,173.75 C459.77832,171.12222 458.91943,168.57598 457.90625,166.09375 L543.5625,166.09375 L543.5625,154.09375 L451.40625,154.09375 C447.10337,147.88692 441.70683,142.49038 435.5,138.1875 L435.5,46.03125 L423.5,46.03125 L423.5,131.6875 C421.01777,130.67432 418.47153,129.81543 415.84375,129.125 L415.84375,22.34375 L403.84375,22.34375 L404.09375,127.21875 C402.74117,127.13069 401.37421,127.09375 400,127.09375 C398.62579,127.09375 397.25883,127.13069 395.90625,127.21875 L396.15625,22.34375 L384.15625,22.34375 M400,139.0625 C427.94161,139.06249 450.5,161.65213 450.5,189.59375 C450.49998,217.53538 427.94162,240.09375 400,240.09375 C372.05837,240.09374 349.5,217.53538 349.5,189.59375 C349.5,161.65213 372.05838,139.0625 400,139.0625\" id=\"path3423\" >\n  </path>\n  <path id=\"path3458\" fill=\"rgb(245, 220, 15)\" fill-rule=\"evenodd\" stroke=\"none\" stroke-width=\"1px\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-opacity=\"1\" fill-opacity=\"1\" d=\"M371.23106,205.77851 C369.29484,210.95758 371.19003,215.67896 374.7666,218.15287 C381.53891,197.75345 387.50725,184.36933 394.74236,171.83738 L376.00403,171.83738 L370.87751,180.49944 L384.48931,180.49944 C380.0699,188.19847 375.31518,194.85415 371.23106,205.77851 M404.21875,170.25 C397.53833,170.25 391.24637,178.65645 390.15625,189 C389.06613,199.34356 393.60084,207.71874 400.28125,207.71875 C406.96167,207.71875 413.25362,199.34356 414.34375,189 C415.43387,178.65644 410.89917,170.25 404.21875,170.25 M401.46875,177.84375 C405.06775,177.84375 408.34127,182.85241 408.78125,189 C409.22124,195.14759 406.66151,200.125 403.0625,200.125 C399.46349,200.125 396.18998,195.14759 395.75,189 C395.31003,182.85241 397.86974,177.84375 401.46875,177.84375 M438.125,159.96875 C428.35549,167.45602 419.05386,175.60093 417.5,188.09375 C416.47978,196.29615 419.06754,207.70302 427.25,207.71875 C431.87039,207.72763 438.82592,205.12517 441.625,189.96875 C443.62668,179.13008 438.156,171.79085 433.375,170.46875 C435.93931,167.09182 437.87506,165.38544 441,162.84375 L438.125,159.96875 M436.25,189.90625 C436.83451,197.46827 431.6068,203.1044 427.125,198.53125 C423.58711,194.92125 421.24957,186.94715 428,177.96875 C434.44668,178.06469 435.85259,184.76478 436.25,189.90625 M362.83417,206.83917 L369.3749,171.92577 L362.21545,171.92577 L356.90518,199.89321 C355.86506,205.37119 359.31092,206.83917 362.83417,206.83917z\" >\n  </path>\n</svg>"
  };

  /*
  
  
    archive
  
    Undo/redos
  
    Manages a stack of Events that describe exactly how the file was put together.
    The Archive is designed to describe the calculations needed to reconstruct the file
    step by step without actually saving the results of any of those calculations.
  
    It merely retains the bare minimum information to carry that calculation out again.
  
    For example, if we nudged a certain shape, we won't be saving the old and new point values,
    which could look like a big wall of characters like "M 434.37889,527.30393 C 434.37378,524.01..."
    Instead we just say "move shape 3 over 23 pixels and up 5 pixels."
  
    Since that procedure is 100% reproducable we can save just that information and always be able
    to do it again.
  
  
    This design is much faster and more efficient and allows us to save the entire history for a file on
    S3 and pull it back down regardless of where and when the file is opened again.
  
    The trade-off is we need to have lots of different Event subclasses that do different things, and
    practically operation in the program needs to be custom-fitted to an Event call.
  
    Again, doing things this way instead of a simpler one-size-fits-all solution gives us more control
    over what is happening and only store the bare minimum details we need in order to offer a
    full start-to-finish file history.
  
  
    Events are serialized in an extremely minimal way. For example, here is a MapEvent that describes a nudge:
  
    {"t":"m:n","i":[5],"a":{"x":0,"y":-10}}
  
    What this is saying, in order of appearance is:
      - The type of this event is "map: nudge"
      - We're applying this event to the element at the z-index 5
      - The arguments for the nudge operation are x = 0, y = -10
  
    That's just an example of how aggressively minimal this system is.
  
  
    History is saved as pure JSON on S3 under this scheme:
  
      development: s3.amazonaws.com/mondy_archives_dev/(USER EMAIL)/( MD5 OF FILE CONTENTS ).json
      prodution:   s3.amazonaws.com/mondy_archives/(USER EMAIL)/( MD5 OF FILE CONTENTS ).json
  
    "Waboom"
  */


  window.archive = {
    setup: function() {
      return this.events = [
        {
          "do": (function() {}),
          undo: (function() {}),
          position: 0,
          current: true
        }
      ];
    },
    undo: function() {
      return this.goToEvent(this.currentPosition() - 1);
    },
    redo: function() {
      return this.goToEvent(this.currentPosition() + 1);
    },
    goToEnd: function() {
      return this.goToEvent(this.events.length - 1);
    },
    goToBeginning: function() {
      return this.goToEvent(0);
    },
    eventsUpToCurrent: function() {
      return this.events.slice(0, this.currentPosition() + 1);
    },
    currentEvent: function() {
      var ce;
      ce = this.events.filter(function(e) {
        return e.current;
      });
      if (ce != null) {
        return ce[0];
      } else {
        return null;
      }
    },
    currentPosition: function() {
      var ce;
      ce = this.currentEvent();
      if (ce != null) {
        return ce.position;
      } else {
        return -1;
      }
    },
    currentlyAtEnd: function() {
      return this.currentPosition() === this.events.length - 1;
    },
    currentlyAtBeginning: function() {
      return this.currentPosition() === 0;
    },
    addEvent: function(event) {
      var uh, _ref3;
      if (this.events.length) {
        this.events = this.eventsUpToCurrent();
      }
      ui.utilities.history.deleteThumbsCached(this.currentPosition());
      event.position = this.events.length;
      if ((_ref3 = this.currentEvent()) != null) {
        _ref3.current = false;
      }
      event.current = true;
      this.events.push(event);
      uh = ui.utilities.history;
      if (event.position % uh.every === 0) {
        return uh.buildThumbs(uh.every, event.position);
      }
    },
    addMapEvent: function(fun, elems, data) {
      return this.addEvent(new MapEvent(fun, elems, data));
    },
    addExistenceEvent: function(elem) {
      return this.addEvent(new ExistenceEvent(elem));
    },
    addPointExistenceEvent: function(elem, point, at) {
      return this.addEvent(new PointExistenceEvent(elem, point, at));
    },
    addAttrEvent: function(indexes, attr, value) {
      if (indexes.length === 0) {
        return;
      }
      return this.addEvent(new AttrEvent(indexes, attr, value));
    },
    addZIndexEvent: function(indexesBefore, indexesAfter, direction) {
      if (indexesBefore.length + indexesAfter === 0) {
        return;
      }
      return this.addEvent(new ZIndexEvent(indexesBefore, indexesAfter, direction));
    },
    goToEvent: function(ep) {
      var currentEvent, diff, oep, position, _i, _j, _ref3, _ref4, _ref5, _ref6;
      oep = this.currentPosition();
      currentEvent = this.currentEvent();
      if (currentEvent) {
        currentEvent.current = false;
      }
      diff = Math.abs(ep - oep);
      if (ep > (this.events.length - 1)) {
        ep = this.events.length - 1;
        this.events[ep].current = true;
      }
      if (ep < 0) {
        ep = 0;
        this.events[0].current = true;
      } else {
        this.events[ep].current = true;
      }
      if (ep > oep) {
        for (position = _i = _ref3 = oep + 1; _ref3 <= ep ? _i <= ep : _i >= ep; position = _ref3 <= ep ? ++_i : --_i) {
          if ((_ref4 = this.events[position]) != null) {
            _ref4["do"]();
          }
        }
      } else if (ep < oep) {
        for (position = _j = oep, _ref5 = ep + 1; oep <= _ref5 ? _j <= _ref5 : _j >= _ref5; position = oep <= _ref5 ? ++_j : --_j) {
          if ((_ref6 = this.events[position]) != null) {
            _ref6.undo();
          }
        }
      }
      if (!this.simulating) {
        return ui.selection.refresh();
      }
    },
    runThrough: function(speed, i) {
      var _this = this;
      if (speed == null) {
        speed = 30;
      }
      if (i == null) {
        i = 0;
      }
      this.goToEvent(i);
      if (i < this.events.length) {
        return setTimeout(function() {
          return _this.runThrough(speed, i + 1);
        }, speed);
      }
    },
    diffState: function() {
      var diff;
      diff = {};
      dom.$main.children().each(function(ind, shape) {
        var attr, _i, _len, _ref3, _results;
        diff[ind] = {};
        _ref3 = shape.attributes;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          attr = _ref3[_i];
          _results.push(diff[ind][attr.name] = attr.value);
        }
        return _results;
      });
      return diff;
    },
    saveDiffState: function() {
      this.lastDiffState = this.diffState();
      return this.atMostRecentEvent = io.makeFile();
    },
    fileAt: function(ep) {
      var cp, file;
      cp = this.currentPosition();
      this.goToEvent(ep);
      file = io.makeFile();
      this.goToEvent(cp);
      return file;
    },
    toJSON: function() {
      if (this.events.length > 1) {
        return {
          f: hex_md5(io.makeFile()),
          e: this.events.slice(1),
          p: this.currentPosition()
        };
      } else {
        return {};
      }
    },
    toString: function() {
      return JSON.stringify(this.toJSON());
    },
    loadFromString: function(saved, checkMD5) {
      var events, i, parsedEvents, _ref3;
      if (checkMD5 == null) {
        checkMD5 = true;
      }
      saved = JSON.parse(saved);
      if (Object.keys(saved).length === 0) {
        return this.setup();
      }
      if (checkMD5) {
        if (saved.f !== hex_md5(ui.file.contents)) {
          console.log("File contents md5 mismatch");
          return this.setup();
        }
      }
      events = saved.e;
      parsedEvents = events.map(function(x) {
        return new Event().fromJSON(x);
      });
      i = 1;
      parsedEvents.map(function(x) {
        x.position = i;
        return i += 1;
      });
      this.setup();
      this.events = this.events.concat(parsedEvents);
      this.events[0].current = false;
      return (_ref3 = this.events[parseInt(saved.p, 10)]) != null ? _ref3.current = true : void 0;
    },
    put: function() {
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/baddeley/put",
        type: "POST",
        dataType: "json",
        data: {
          session_token: ui.account.session_token,
          file_hash: hex_md5(ui.file.contents),
          archive: archive.toString()
        },
        success: function(data) {}
      });
    },
    get: function() {
      var _this = this;
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/baddeley/get",
        data: {
          session_token: ui.account.session_token,
          file_hash: hex_md5(ui.file.contents)
        },
        dataType: "json",
        success: function(data) {
          return _this.loadFromString(data.archive);
        }
      });
    }
  };

  setup.push(function() {
    if (ui.file == null) {
      return archive.setup();
    }
  });

  /*
  
  
    Archive Event
  
    Events are amazing creatures. They are specialized objects for certain types
    of events, obviously, that happen when one is using Mondy.
  
    The best part about them is they are serializable as  string,
    and can be completely restored from one as well.
  
    That means that this is a archive system that doesn't have to die when the session dies.
  
    Let me repeat that: WE CAN PASS AROUND FILE HISTORIES AS BLOBS OF TEXT.
    And it's rather space-efficient as well, given its power.
  
  
    Some key concepts:
  
    Abstraction through mapping
  
      There are different types of Events. Things like nudges and rotations are stored
      as the relevant measurements as opposed to actual changes between points,
      for efficiency's sake.
  
      It's much easier to just say "rotate the element at zindex 3 by 12Â°" than,
      "Find the element with the points "M577.5621054400491,303.51924490455684 C592.3321407555776,35..."
      and update that to "M560.5835302627165,358.31402081341434 C536.5694824830614,406.6805951105095..."
  
    Minimal serialization
  
      These are not meant to be human-readable, when they are stored they use tons of one-character indicators.
      A typical rotation event looks like this:
        {"t":"m:r","i":[0],"args":{"angle":42.278225912417064,"origin":{"x":498.21488701676367,"y":308.96076780376694,"zoomLevel":1}}}
  
     "t" = meaning type
     "m:r" = map: rotate
     "i" = index
  
    For now the args are more reasonably labeled so shit doesn't get TOO confusing
  
    We'll see how this goes and later I might change the grammar/standard if it's worth making more efficient.
  
  
  
  
    types
  
      "m:" = map... MapEvent
        This one has a second argument - which method do we map? It follows the colon.
  
        "r" = rotate
        "n" = nudge
        "s" = scale
  
      "e" = ExistenceEvent
  
      "d" = DiffEvent
  */


  Event = (function() {
    function Event() {}

    Event.prototype.current = false;

    Event.prototype.position = void 0;

    Event.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };

    Event.prototype.fromJSON = function(json) {
      var args, at, ee, elem, funKey, indexes, mode, pe, point;
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      switch (json.t[0]) {
        case "m":
          funKey = {
            n: "nudge",
            s: "scale",
            r: "rotate"
          }[json.t[2]];
          indexes = json.i;
          args = json.a;
          return new MapEvent(funKey, indexes, args);
        case "e":
          ee = new ExistenceEvent(json.a);
          ee.mode = {
            d: "delete",
            c: "create"
          }[json.t[2]];
          return ee;
        case "p":
          point = json.p;
          at = json.i;
          elem = parseInt(json.e, 10);
          mode = {
            d: "delete",
            c: "create"
          }[json.t[2]];
          pe = new PointExistenceEvent(elem, point, at);
          pe.mode = mode;
          return pe;
        case "a":
          return new AttrEvent(json.i, json.c, json.o);
        case "z":
          return new ZIndexEvent(json.ib, json.ia, json.d);
      }
    };

    return Event;

  })();

  window.Event = Event;

  /*
  
  
    MapEvent
  
    An efficient way to store a nudge, scale, or rotate
    of an entire shape's points
  */


  MapEvent = (function(_super) {
    __extends(MapEvent, _super);

    function MapEvent(funKey, indexes, args) {
      var _this = this;
      this.funKey = funKey;
      this.indexes = indexes;
      this.args = args;
      this.operatingOn = this.indexes instanceof Array ? "elems" : "points";
      switch (this.funKey) {
        case "nudge":
          this._undo = function(e) {
            return e.nudge(-_this.args.x, -_this.args.y, true);
          };
          this._do = function(e) {
            return e.nudge(_this.args.x, _this.args.y, true);
          };
          break;
        case "scale":
          this.args.x = Math.max(this.args.x, 1e-5);
          this.args.y = Math.max(this.args.y, 1e-5);
          this._undo = function(e) {
            return e.scale(1 / _this.args.x, 1 / _this.args.y, new Posn(_this.args.origin));
          };
          this._do = function(e) {
            return e.scale(_this.args.x, _this.args.y, new Posn(_this.args.origin));
          };
          break;
        case "rotate":
          this._undo = function(e) {
            return e.rotate(-_this.args.angle, new Posn(_this.args.origin));
          };
          this._do = function(e) {
            return e.rotate(_this.args.angle, new Posn(_this.args.origin));
          };
      }
    }

    MapEvent.prototype.undo = function() {
      return this._execute(this._undo);
    };

    MapEvent.prototype["do"] = function() {
      return this._execute(this._do);
    };

    MapEvent.prototype._execute = function(method) {
      var elem, index, newAngle, oldAngle, point, pointIndex, pointIndexes, _i, _j, _len, _len1, _ref3, _ref4, _results, _results1;
      if (this.operatingOn === "elems") {
        if (!archive.simulating) {
          ui.selection.points.deselectAll();
          ui.selection.elements.deselectAll();
        }
        _ref3 = this.indexes;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          index = _ref3[_i];
          elem = queryElemByZIndex(parseInt(index, 10));
          if (!archive.simulating) {
            ui.selection.elements.selectMore(elem);
          }
          method(elem);
          _results.push(elem.redrawHoverTargets());
        }
        return _results;
      } else {
        _ref4 = this.indexes;
        _results1 = [];
        for (index in _ref4) {
          if (!__hasProp.call(_ref4, index)) continue;
          pointIndexes = _ref4[index];
          elem = queryElemByZIndex(parseInt(index, 10));
          if (!archive.simulating) {
            ui.selection.elements.deselectAll();
            ui.selection.points.deselectAll();
          }
          for (_j = 0, _len1 = pointIndexes.length; _j < _len1; _j++) {
            pointIndex = pointIndexes[_j];
            point = elem.points.at(parseInt(pointIndex, 10));
            if (this.args.antler != null) {
              switch (this.args.antler) {
                case "p2":
                  if (point.antlers.succp2 != null) {
                    oldAngle = point.antlers.succp2.angle360(point);
                    method(point.antlers.succp2);
                    newAngle = point.antlers.succp2.angle360(point);
                    if (point.antlers.lockAngle) {
                      point.antlers.basep3.rotate(newAngle - oldAngle, point);
                    }
                    if (point.antlers.visible) {
                      point.antlers.redraw();
                    }
                  } else {
                    console.log("wtf");
                  }
                  break;
                case "p3":
                  oldAngle = point.antlers.basep3.angle360(point);
                  method(point.antlers.basep3);
                  newAngle = point.antlers.basep3.angle360(point);
                  if (point.antlers.lockAngle) {
                    point.antlers.succp2.rotate(newAngle - oldAngle, point);
                  }
                  if (point.antlers.visible) {
                    point.antlers.redraw();
                  }
              }
              point.antlers.commit();
            } else {
              method(point);
            }
            if (!archive.simulating) {
              ui.selection.points.selectMore(point);
            }
          }
          elem.commit();
          _results1.push(elem.redrawHoverTargets());
        }
        return _results1;
      }
    };

    MapEvent.prototype.toJSON = function() {
      return {
        t: "m:" + {
          nudge: "n",
          scale: "s",
          rotate: "r"
        }[this.funKey],
        i: this.indexes,
        a: this.args
      };
    };

    return MapEvent;

  })(Event);

  /*
  
    AttrEvent
  
    Set the values of various attributes of various elements.
    Very flexible.
  */


  AttrEvent = (function(_super) {
    __extends(AttrEvent, _super);

    function AttrEvent(indexes, changes, oldValues) {
      var attr, createOldValues, elem, firstElem, i, keys, numKeys, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.indexes = indexes;
      this.changes = changes;
      this.oldValues = oldValues;
      if (typeof this.indexes === "number") {
        this.indexes = [this.indexes];
      }
      if (typeof this.changes === "string") {
        this.changes = [this.changes];
      }
      createOldValues = this.oldValues == null;
      if (createOldValues) {
        this.oldValues = {};
      }
      this.attrs = [];
      this.microManMode = false;
      if (this.changes instanceof Array) {
        this.attrs = this.changes;
        this.changes = {};
        firstElem = queryElemByZIndex(this.indexes[0]);
        _ref3 = this.attrs;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          attr = _ref3[_i];
          this.changes[attr] = firstElem.data[attr].toString();
        }
        if (createOldValues) {
          _ref4 = this.indexes;
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            i = _ref4[_j];
            elem = queryElemByZIndex(i);
            this.oldValues[i] = {};
            _ref5 = this.attrs;
            for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
              attr = _ref5[_k];
              this.oldValues[i][attr] = elem.dataArchived[attr].toString();
              elem.updateDataArchived(attr);
            }
          }
        }
      } else if (typeof this.changes === "object") {
        keys = Object.keys(this.changes);
        numKeys = keys.filter(function(k) {
          return /\d+/gi.test(k);
        });
        if (keys.length === numKeys.length) {
          this.microManMode = true;
          if (createOldValues) {
            _ref6 = this.indexes;
            for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
              i = _ref6[_l];
              elem = queryElemByZIndex(i);
              this.oldValues[i] = {};
              _ref7 = this.changes[i];
              for (attr in _ref7) {
                if (!__hasProp.call(_ref7, attr)) continue;
                _ = _ref7[attr];
                this.oldValues[i][attr] = elem.dataArchived[attr].toString();
                elem.updateDataArchived(attr);
              }
            }
          }
        } else {
          this.attrs = Object.keys(this.changes);
          if (createOldValues) {
            _ref8 = this.indexes;
            for (_m = 0, _len4 = _ref8.length; _m < _len4; _m++) {
              i = _ref8[_m];
              elem = queryElemByZIndex(i);
              this.oldValues[i] = {};
              _ref9 = this.attrs;
              for (_n = 0, _len5 = _ref9.length; _n < _len5; _n++) {
                attr = _ref9[_n];
                this.oldValues[i][attr] = elem.dataArchived[attr].toString();
                elem.updateDataArchived(attr);
              }
            }
          }
        }
      }
    }

    AttrEvent.prototype["do"] = function() {
      return this.applyValues(this.changes, this.microManMode);
    };

    AttrEvent.prototype.undo = function() {
      return this.applyValues(this.oldValues, true);
    };

    AttrEvent.prototype.applyValues = function(from, elemSpecific) {
      var attr, elem, i, val, _i, _j, _len, _len1, _ref3, _ref4, _ref5, _results;
      _ref3 = this.indexes;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        i = _ref3[_i];
        elem = queryElemByZIndex(parseInt(i, 10));
        if (elemSpecific) {
          _ref4 = from[i];
          for (attr in _ref4) {
            if (!__hasProp.call(_ref4, attr)) continue;
            val = _ref4[attr];
            elem["set" + (attr.camelCase().capitalize())](val);
          }
        } else {
          _ref5 = this.attrs;
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            attr = _ref5[_j];
            elem["set" + (attr.camelCase().capitalize())](from[attr]);
          }
        }
        _results.push(elem.commit());
      }
      return _results;
    };

    AttrEvent.prototype.toJSON = function() {
      return {
        t: "a",
        i: this.indexes,
        c: this.changes,
        o: this.oldValues
      };
    };

    return AttrEvent;

  })(Event);

  /*
  
    Z-Index event
  
    Shift elements up or down in the z-axis
  */


  ZIndexEvent = (function(_super) {
    __extends(ZIndexEvent, _super);

    function ZIndexEvent(indexesBefore, indexesAfter, direction) {
      var mb, mbb, mf, mff;
      this.indexesBefore = indexesBefore;
      this.indexesAfter = indexesAfter;
      this.direction = direction;
      mf = function(e) {
        return e.moveForward();
      };
      mb = function(e) {
        return e.moveBack();
      };
      mff = function(e) {
        return e.bringToFront();
      };
      mbb = function(e) {
        return e.sendToBack();
      };
      console.log(this.direction);
      switch (this.direction) {
        case "mf":
          this._do = mf;
          this._undo = mb;
          break;
        case "mb":
          this._do = mb;
          this._undo = mf;
          break;
        case "mff":
          this._do = mff;
          this._undo = mbb;
          break;
        case "mbb":
          this._do = mbb;
          this._undo = mff;
      }
    }

    ZIndexEvent.prototype["do"] = function() {
      var index, _i, _len, _ref3;
      _ref3 = this.indexesBefore;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        index = _ref3[_i];
        this._do(queryElemByZIndex(index));
      }
      return ui.elements.sortByZIndex();
    };

    ZIndexEvent.prototype.undo = function() {
      var index, _i, _len, _ref3;
      _ref3 = this.indexesAfter;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        index = _ref3[_i];
        this._undo(queryElemByZIndex(index));
      }
      return ui.elements.sortByZIndex();
    };

    ZIndexEvent.prototype.toJSON = function() {
      return {
        t: "z",
        ib: this.indexesBefore,
        ia: this.indexesAfter,
        d: this.direction
      };
    };

    return ZIndexEvent;

  })(Event);

  /*
  
    ExistenceEvent
  
    Created when a new element is created, or an element is deleted.
    Create and deletes elements in either direction for do/undo.
    Capable of handling many elements in one event.
  */


  ExistenceEvent = (function(_super) {
    __extends(ExistenceEvent, _super);

    function ExistenceEvent(elem) {
      var e, ind, keys, newIndex, numberKeys, onCanvasAlready, serializer, _i, _j, _len, _len1, _ref3, _ref4;
      this.args = {};
      if ((elem instanceof Object) && !(elem instanceof Array)) {
        keys = Object.keys(elem);
        numberKeys = keys.filter(function(k) {
          return k.match(/^[\d]*$/gi) !== null;
        });
        if (keys.length === numberKeys.length) {
          this.args = elem;
          return this;
        }
      }
      if (typeof elem === "number") {
        e = (_ref3 = queryElemByZIndex(elem)) != null ? _ref3.repToString() : void 0;
        if (e != null) {
          this.args[elem] = this.cleanUpStringElem(e);
          this.mode = "delete";
        } else {
          ui.selection.elements.all.map(function(e) {
            return e["delete"]();
          });
          return;
        }
      } else if (!(elem instanceof Array)) {
        if (isSVGElement(elem)) {
          elem = new XMLSerializer().serializeToString(elem);
        }
        this.args[ui.elements.length - 1] = this.cleanUpStringElem(elem);
        this.mode = "create";
      } else {
        if (typeof elem[0] === "number") {
          for (_i = 0, _len = elem.length; _i < _len; _i++) {
            ind = elem[_i];
            e = (_ref4 = queryElemByZIndex(elem)) != null ? _ref4.repToString() : void 0;
            if (e != null) {
              this.args[ind] = this.cleanUpStringElem(e);
              this.mode = "delete";
            } else {
              ui.selection.elements.all.map(function(e) {
                return e["delete"]();
              });
              return;
            }
          }
          this.mode = "delete";
        } else {
          if (isSVGElement(elem[0])) {
            onCanvasAlready = !!elem[0].parentNode;
            serializer = new XMLSerializer();
            elem = elem.map(function(e) {
              return serializer.serializeToString(e);
            });
          }
          newIndex = ui.elements.length;
          if (onCanvasAlready) {
            newIndex -= elem.length;
          }
          for (_j = 0, _len1 = elem.length; _j < _len1; _j++) {
            e = elem[_j];
            this.args[newIndex] = this.cleanUpStringElem(e);
            ++newIndex;
          }
          this.mode = "create";
        }
      }
    }

    ExistenceEvent.prototype.cleanUpStringElem = function(s) {
      s = s.replace(/uuid\=\"\w*\"/gi, "");
      return s;
    };

    ExistenceEvent.prototype.draw = function() {
      var elem, i, index, parsed, zi, _ref3, _results;
      _ref3 = this.args;
      _results = [];
      for (index in _ref3) {
        if (!__hasProp.call(_ref3, index)) continue;
        elem = _ref3[index];
        index = parseInt(index, 10);
        parsed = io.parseElement($(elem));
        parsed.appendTo("#main");
        if (!archive.simulating) {
          ui.selection.elements.deselectAll();
          ui.selection.elements.select([parsed]);
        }
        zi = parsed.zIndex();
        if (zi !== index) {
          if (zi > index) {
            _results.push((function() {
              var _i, _ref4, _results1;
              _results1 = [];
              for (i = _i = 1, _ref4 = zi - index; 1 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 1 <= _ref4 ? ++_i : --_i) {
                _results1.push(parsed.moveBack());
              }
              return _results1;
            })());
          } else if (zi < index) {
            _results.push((function() {
              var _i, _ref4, _results1;
              _results1 = [];
              for (i = _i = 1, _ref4 = index - zi; 1 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 1 <= _ref4 ? ++_i : --_i) {
                _results1.push(parsed.moveForward());
              }
              return _results1;
            })());
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ExistenceEvent.prototype["delete"] = function() {
      var elem, index, plan, _i, _len, _ref3, _ref4;
      plan = {};
      _ref3 = this.args;
      for (index in _ref3) {
        if (!__hasProp.call(_ref3, index)) continue;
        elem = _ref3[index];
        index = parseInt(index, 10);
        plan[index] = queryElemByZIndex(index);
      }
      _ref4 = objectValues(plan);
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        elem = _ref4[_i];
        elem["delete"]();
      }
      if (!archive.simulating) {
        return ui.selection.elements.validate();
      }
    };

    ExistenceEvent.prototype.undo = function() {
      if (this.mode === "delete") {
        return this.draw();
      } else {
        return this["delete"]();
      }
    };

    ExistenceEvent.prototype["do"] = function() {
      if (this.mode === "delete") {
        return this["delete"]();
      } else {
        return this.draw();
      }
    };

    ExistenceEvent.prototype.toJSON = function() {
      return {
        t: "e:" + {
          "delete": "d",
          "create": "c"
        }[this.mode],
        a: this.args
      };
    };

    return ExistenceEvent;

  })(Event);

  /*
  
    PointExistenceEvent
  */


  PointExistenceEvent = (function(_super) {
    __extends(PointExistenceEvent, _super);

    function PointExistenceEvent(ei, point, at) {
      var elem;
      this.ei = ei;
      this.point = point;
      elem = this.getElem();
      if (typeof this.point === "number") {
        this.mode = "remove";
        this.point = elem.points.at(this.point);
        this.pointIndex = this.point;
      } else {
        this.mode = "create";
        if (typeof this.point === "string") {
          this.point = new Point(this.point);
        }
        if (at != null) {
          this.pointIndex = at;
        } else {
          this.pointIndex = elem.points.all().length - 1;
        }
      }
    }

    PointExistenceEvent.prototype["do"] = function() {
      if (this.mode === "remove") {
        return this.remove();
      } else {
        return this.add();
      }
    };

    PointExistenceEvent.prototype.undo = function() {
      if (this.mode === "remove") {
        return this.add();
      } else {
        return this.remove();
      }
    };

    PointExistenceEvent.prototype.getElem = function() {
      return queryElemByZIndex(this.ei);
    };

    PointExistenceEvent.prototype.add = function() {
      var clonedPoint, elem;
      clonedPoint = this.point.clone();
      elem = this.getElem();
      elem.hidePoints();
      elem.points.push(clonedPoint);
      if ((clonedPoint.equal(elem.points.first)) && !(clonedPoint === elem.points.first)) {
        elem.points.close();
      }
      elem.commit();
      clonedPoint.draw();
      if (!archive.simulating) {
        ui.selection.elements.deselectAll();
        ui.selection.points.select(clonedPoint);
      }
      return this.getElem().redrawHoverTargets();
    };

    PointExistenceEvent.prototype.remove = function() {
      var elem;
      elem = this.getElem();
      elem.points.remove(this.pointIndex);
      elem.hidePoints();
      if (!archive.simulating) {
        ui.selection.elements.deselectAll();
        ui.selection.points.select(elem.points.last);
      }
      return elem.commit();
    };

    PointExistenceEvent.prototype.toJSON = function() {
      return {
        t: "p:" + {
          "remove": "d",
          "create": "c"
        }[this.mode],
        e: this.ei,
        p: this.point.toString(),
        i: this.pointIndex
      };
    };

    return PointExistenceEvent;

  })(Event);

  /*
  
    Commonly accessed DOM elements
  */


  dom = {
    setup: function() {
      this.$body = $('body');
      this.body = this.$body[0];
      this.$main = $('#main');
      this.main = this.$main[0];
      this.$ui = $('#ui');
      this.ui = this.$ui[0];
      this.$bg = $('#bg');
      this.bg = this.$bg[0];
      this.$annotations = $('#annotations');
      this.annotations = this.$annotations[0];
      this.$hoverTargets = $('#hover-targets');
      this.hoverTargets = this.$hoverTargets[0];
      this.$grid = $('#grid');
      this.grid = this.$grid[0];
      this.$utilities = $('#utilities');
      this.utilities = this.$utilities[0];
      this.$selectionBox = $('#selection-box');
      this.selectionBox = this.$selectionBox[0];
      this.$dragSelection = $('#drag-selection');
      this.dragSelection = this.$dragSelection[0];
      this.$menuBar = $('#menu-bar');
      this.menuBar = this.$menuBar[0];
      this.$currentSwatches = $('#current-swatches');
      this.currentSwatches = this.$currentSwatches[0];
      this.$toolPalette = $('#tool-palette');
      this.toolPalette = this.$toolPalette[0];
      this.$toolCursorPlaceholder = $('#tool-cursor-placeholder');
      this.toolCursorPlaceholder = this.$toolCursorPlaceholder[0];
      this.$canvas = $('#canvas');
      this.canvas = this.$canvas[0];
      this.$logoLeft = $("#logo #left-bar");
      this.$logoMiddle = $("#logo #middle-bar");
      this.$logoRight = $("#logo #right-bar");
      this.logoLeft = this.$logoLeft[0];
      this.logoMiddle = this.$logoMiddle[0];
      this.logoRight = this.$logoRight[0];
      this.$filename = $("#filename-menu");
      this.filename = this.$filename[0];
      this.$login = $("#login-mg");
      this.login = this.$login[0];
      this.$tmpPaste = $('#tmp-paste');
      this.tmpPaste = this.$tmpPaste[0];
      this.$pngSandbox = $('#png-download-sandbox');
      this.pngSandbox = this.$pngSandbox[0];
      this.$currentService = $('#current-service');
      this.currentService = this.$currentService[0];
      this.$serviceLogo = $('.service-logo');
      this.serviceLogo = this.$serviceLogo[0];
      this.$serviceGallery = $('#service-file-gallery');
      this.serviceGallery = this.$serviceGallery[0];
      this.$serviceGalleryThumbs = $('#service-file-gallery-thumbnails');
      this.serviceGalleryThumbs = this.$serviceGalleryThumbs[0];
      this.$serviceBrowser = $('#service-file-browser');
      this.serviceBrowser = this.$serviceBrowser[0];
      this.$registerButton = $('#register-mg');
      this.registerButton = this.$registerButton[0];
      this.$dialogTitle = $("#dialog-title");
      return this.dialogTitle = this.$dialogTitle[0];
    }
  };

  setup.push(function() {
    return dom.setup();
  });

  /*
  
    UI handling
  
    Handles
      - Mouse event routing
      - UI state memory
    Core UI functions and interface for all events used by the tools.
  */


  window.ui = {
    setup: function() {
      var _this = this;
      this.uistate = new UIState();
      this.uistate.restore();
      ui.window.on('focus', function() {
        return dom.$toolCursorPlaceholder.hide();
      });
      window.scrollTo(0, 0);
      this.fill = new Swatch("5fcda7").appendTo("#fill-color");
      this.stroke = new Swatch("000000").appendTo("#stroke-color");
      this.fill.type = "fill";
      this.stroke.type = "stroke";
      this.changeTo("draw");
      return this.selection.elements.on('change', function() {
        _this.refreshUtilities();
        _this.transformer.refresh();
        return _this.utilities.transform.refresh();
      });
    },
    clear: function() {
      return $("#ui .point.handle").remove();
    },
    importState: function(state) {
      var _this = this;
      this.fill.absorb(new Color(state.fill));
      this.stroke.absorb(new Color(state.stroke));
      this.canvas.setZoom(parseFloat(state.zoom));
      this.refreshAfterZoom();
      this.canvas.normal = new Posn(state.normal);
      this.canvas.refreshPosition();
      if (state.tool != null) {
        return secondRoundSetup.push(function() {
          return _this.switchToTool(objectValues(tools).filter(function(t) {
            return t.id === state.tool;
          })[0]);
        });
      } else {
        return secondRoundSetup.push(function() {
          return _this.switchToTool(tools.cursor);
        });
      }
    },
    "new": function(width, height, normal, zoom) {
      if (normal == null) {
        normal = this.canvas.normal;
      }
      if (zoom == null) {
        zoom = this.canvas.zoom;
      }
      this.canvas.width = width;
      this.canvas.height = height;
      this.canvas.zoom = zoom;
      this.canvas.normal = normal;
      this.canvas.redraw();
      this.canvas.zoom100();
      return this.deleteAll();
    },
    configurations: {
      draw: function() {
        return {
          show: [dom.$canvas, dom.$toolPalette, dom.$menuBar, dom.$filename, dom.$currentSwatches, dom.$utilities]
        };
      },
      gallery: function() {
        return {
          show: [dom.$currentService, dom.$serviceGallery]
        };
      },
      browser: function() {
        return {
          show: [dom.$currentService, dom.$serviceBrowser]
        };
      }
    },
    changeTo: function(config) {
      var util, _base, _base1, _i, _len, _ref3, _ref4;
      if ((_ref3 = this.currentConfig) != null) {
        _ref3.show.map(function(e) {
          return e.hide();
        });
      }
      this.hotkeys.enable().reset();
      if ("config" === "draw") {
        this.refreshUtilities();
      } else {
        _ref4 = this.utilities;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          util = _ref4[_i];
          util.hide();
        }
      }
      this.currentConfig = typeof (_base = this.configurations)[config] === "function" ? _base[config]() : void 0;
      if (this.currentConfig != null) {
        this.currentConfig.show.map(function(e) {
          return e.show();
        });
        if (typeof (_base1 = this.currentConfig).etc === "function") {
          _base1.etc();
        }
        if (this.currentConfig.title != null) {
          dom.$dialogTitle.show().text(this.currentConfig.title);
        } else {
          dom.$dialogTitle.hide();
        }
      }
      this.menu.closeAllDropdowns();
      return this;
    },
    refreshAfterZoom: function() {
      var elem, _i, _len, _ref3;
      _ref3 = this.elements;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        elem.refreshUI();
      }
      this.selection.points.show();
      return this.grid.refreshRadii();
    },
    switchToTool: function(tool) {
      var _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      if (tool === this.uistate.get('tool')) {
        return;
      }
      if ((_ref3 = this.uistate.get('tool')) != null) {
        _ref3.tearDown();
      }
      this.uistate.set('tool', tool);
      if ((_ref4 = dom.$toolCursorPlaceholder) != null) {
        _ref4.hide();
      }
      if ((_ref5 = dom.$body) != null) {
        _ref5.off('mousemove.tool-placeholder');
      }
      if ((_ref6 = dom.body) != null) {
        _ref6.setAttribute('tool', tool.cssid);
      }
      tool.setup();
      if (tool !== tools.paw) {
        if ((_ref7 = q(".tool-button[selected]")) != null) {
          _ref7.removeAttribute('selected');
        }
        if ((_ref8 = q("#" + tool.id + "-btn")) != null) {
          _ref8.setAttribute('selected', '');
        }
        dom.$body.on('mousemove.tool-placeholder', function(e) {
          if ((e.offsetX !== tool.offsetX) || (e.offsetY !== tool.offsetY)) {
            dom.$toolCursorPlaceholder.hide();
            return dom.$body.off('mousemove.tool-placeholder');
          }
        });
      }
      this.refreshUtilities();
      if (this.cursor.currentPosn === void 0) {
        return;
      }
      return dom.$toolCursorPlaceholder.show().attr('tool', tool.cssid).css({
        left: this.cursor.currentPosn.x - tool.offsetX,
        top: this.cursor.currentPosn.y - tool.offsetY
      });
    },
    switchToLastTool: function() {
      return this.switchToTool(this.uistate.get('lastTool'));
    },
    hover: function(e, target) {
      var menu, menus, topUI;
      e.target = target;
      this.uistate.get('tool').dispatch(e, "hover");
      topUI = isOnTopUI(target);
      if (topUI) {
        switch (topUI) {
          case "menu":
            menus = objectValues(this.menu.menus);
            if (menus.filter(function(menu) {
              return menu.dropdownOpen;
            }).length > 0) {
              menu = menus.filter(function(menu) {
                return menu.itemid === target.id;
              })[0];
              if (menu != null) {
                return menu.openDropdown();
              }
            }
        }
      }
    },
    unhover: function(e, target) {
      e.target = target;
      return this.uistate.get('tool').dispatch(e, "unhover");
    },
    click: function(e, target) {
      var t, topUI, _ref3, _ref4;
      if ((target.nodeName.toLowerCase() === "emph") || (target.hasAttribute("buttontext"))) {
        t = $(target).closest(".menu-item")[0];
        if (t == null) {
          t = $(target).closest(".menu")[0];
        }
        target = t;
      }
      topUI = isOnTopUI(target);
      if (topUI) {
        if (e.which !== 1) {
          return;
        }
        switch (topUI) {
          case "menu":
            return (_ref3 = this.menu.menu(target.id)) != null ? _ref3._click(e) : void 0;
          case "menu-item":
            return (_ref4 = this.menu.item(target.id)) != null ? _ref4._click(e) : void 0;
          default:
            return this.topUI.dispatch(e, "click");
        }
      } else {
        if (e.which === 1) {
          return this.uistate.get('tool').dispatch(e, "click");
        } else if (e.which === 3) {
          return this.uistate.get('tool').dispatch(e, "rightClick");
        }
      }
    },
    doubleclick: function(e, target) {
      return this.uistate.get('tool').dispatch(e, "doubleclick");
    },
    mousemove: function(e) {
      var topUI;
      topUI = isOnTopUI(e.target);
      if (topUI) {
        this.topUI.dispatch(e, "mousemove");
      }
      if (this.uistate.get('tool') === tools.paw) {
        return dom.$toolCursorPlaceholder.css({
          left: e.clientX - 8,
          top: e.clientY - 8
        });
      }
    },
    mousedown: function(e) {
      if (!isOnTopUI(e.target)) {
        this.menu.closeAllDropdowns();
        this.refreshUtilities();
        return this.uistate.get('tool').dispatch(e, "mousedown");
      }
    },
    mouseup: function(e) {
      var topUI;
      topUI = isOnTopUI(e.target);
      if (topUI) {
        return this.topUI.dispatch(e, "mouseup");
      } else {
        e.stopPropagation();
        return this.uistate.get('tool').dispatch(e, "mouseup");
      }
    },
    startDrag: function(e) {
      var key, topUI, _i, _len, _ref3, _results;
      topUI = isOnTopUI(e.target);
      if (topUI) {
        return this.topUI.dispatch(e, "startDrag");
      } else {
        this.uistate.get('tool').initialDragPosn = new Posn(e);
        this.uistate.get('tool').dispatch(e, "startDrag");
        _ref3 = this.hotkeys.modifiersDown;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          key = _ref3[_i];
          _results.push(this.uistate.get('tool').activateModifier(key));
        }
        return _results;
      }
    },
    continueDrag: function(e, target) {
      var topUI;
      e.target = target;
      topUI = isOnTopUI(target);
      if (topUI) {
        return this.topUI.dispatch(e, "continueDrag");
      } else {
        return this.uistate.get('tool').dispatch(e, "continueDrag");
      }
    },
    stopDrag: function(e, target) {
      var releaseTarget, topUI, _ref3, _ref4;
      document.onselectstart = function() {
        return true;
      };
      releaseTarget = e.target;
      e.target = target;
      topUI = isOnTopUI(e.target);
      if (topUI) {
        if ((target.nodeName.toLowerCase() === "emph") || (target.hasAttribute("buttontext"))) {
          target = target.parentNode;
        }
        switch (topUI) {
          case "menu":
            if (releaseTarget === target) {
              return (_ref3 = this.menu.menu(target.id)) != null ? _ref3._click(e) : void 0;
            }
            break;
          case "menu-item":
            if (releaseTarget === target) {
              return (_ref4 = this.menu.item(target.id)) != null ? _ref4._click(e) : void 0;
            }
            break;
          default:
            return this.topUI.dispatch(e, "stopDrag");
        }
      } else {
        this.uistate.get('tool').dispatch(e, "stopDrag");
        this.uistate.get('tool').initialDragPosn = null;
        return this.snap.toNothing();
      }
    },
    fill: null,
    stroke: null,
    elements: [],
    queryElement: function(svgelem) {
      var elem, _i, _len, _ref3;
      _ref3 = this.elements;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        if (elem.rep === svgelem) {
          return elem;
        }
      }
    },
    hoverTargetsHighlighted: [],
    unhighlightHoverTargets: function() {
      var hoverTarget, _i, _len, _ref3;
      _ref3 = this.hoverTargetsHighlighted;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        hoverTarget = _ref3[_i];
        hoverTarget.unhighlight();
      }
      return this.hoverTargetsHighlighted = [];
    },
    refreshUtilities: function() {
      var key, utility, _ref3, _results;
      if (!appLoaded) {
        return;
      }
      _ref3 = this.utilities;
      _results = [];
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        utility = _ref3[key];
        if (!utility.shouldBeOpen()) {
          _results.push(utility.hide());
        } else {
          _results.push(utility.show());
        }
      }
      return _results;
    },
    deleteAll: function() {
      var elem, _i, _len, _ref3;
      _ref3 = this.elements;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        elem["delete"]();
      }
      this.elements = [];
      dom.main.removeChildren();
      return this.selection.refresh();
    },
    colors: {
      transparent: new Color(0, 0, 0, 0),
      white: new Color(255, 255, 255),
      black: new Color(0, 0, 0),
      red: new Color(255, 0, 0),
      yellow: new Color(255, 255, 0),
      green: new Color(0, 255, 0),
      teal: new Color(0, 255, 255),
      blue: new Color(0, 0, 255),
      pink: new Color(255, 0, 255),
      "null": new Color(null, null, null),
      logoRed: new Color("#E03F4A"),
      logoYellow: new Color("#F1CF2E"),
      logoBlue: new Color("#3FB2E0")
    }
  };

  setup.push(function() {
    return ui.setup();
  });

  /*
  
    Animated Mondy logo for indicating progress
  */


  ui.logo = {
    animate: function() {
      var _this = this;
      this._animateRequests += 1;
      if (this._animateRequests === 1) {
        clearInterval(this.animateLogoInterval);
        return this.animateLogoInterval = setInterval(function() {
          var a, vals;
          if (_this._animateRequests === 0) {
            return _this._reset();
          } else {
            vals = [ui.colors.logoRed, ui.colors.logoYellow, ui.colors.logoBlue];
            a = parseInt(Math.random() * 3);
            dom.$logoLeft.css("background-color", vals[a]);
            vals = vals.slice(0, a).concat(vals.slice(a + 1));
            a = parseInt(Math.random() * 2);
            dom.$logoMiddle.css("background-color", vals[a]);
            vals = vals.slice(0, a).concat(vals.slice(a + 1));
            return dom.$logoRight.css("background-color", vals[0]);
          }
        }, 170);
      }
    },
    stopAnimating: function() {
      this._animateRequests -= 1;
      if (this._animateRequests < 0) {
        return this._animateRequests = 0;
      }
    },
    _animateRequests: 0,
    _reset: function() {
      clearInterval(this.animateLogoInterval);
      dom.$logoLeft.css("background-color", ui.colors.logoRed);
      dom.$logoMiddle.css("background-color", ui.colors.logoYellow);
      return dom.$logoRight.css("background-color", ui.colors.logoBlue);
    }
  };

  /*
  
    JSON Serializable UI State
  */


  UIState = (function() {
    function UIState(attributes) {
      var _this = this;
      this.attributes = attributes != null ? attributes : this.DEFAULTS();
      this.on('change', function() {
        return _this.saveLocally();
      });
    }

    UIState.prototype.restore = function() {
      var storedState;
      storedState = localStorage.getItem('uistate');
      if (storedState != null) {
        this.importJSON(JSON.parse(storedState));
      }
      return this;
    };

    UIState.prototype.set = function(key, val) {
      if (this.attributes[key] === val) {
        return;
      }
      switch (key) {
        case 'tool':
          this.attributes.lastTool = this.attributes.tool;
          this.attributes.tool = val;
          break;
        default:
          this.attributes[key] = val;
      }
      this.trigger('change', key, val);
      return this.trigger("change:" + key, val);
    };

    UIState.prototype.get = function(key) {
      return this.attributes[key];
    };

    UIState.prototype.saveLocally = function() {
      return localStorage.setItem('uistate', this.toJSON());
    };

    UIState.prototype.apply = function() {
      ui.fill.absorb(this.get('fill'));
      return ui.stroke.absorb(this.get('stroke'));
    };

    UIState.prototype.toJSON = function() {
      return {
        fill: this.attributes.fill.hex,
        stroke: this.attributes.stroke.hex,
        strokeWidth: this.attributes.strokeWidth,
        zoom: this.attributes.zoom,
        normal: this.attributes.normal.toJSON(),
        tool: this.attributes.tool.id,
        lastTool: this.attributes.lastTool.id
      };
    };

    UIState.prototype.importJSON = function(attributes) {
      this.attributes = {
        fill: new Color(attributes.fill),
        stroke: new Color(attributes.stroke),
        strokeWidth: attributes.strokeWidth,
        zoom: attributes.zoom,
        normal: Posn.fromJSON(attributes.normal),
        tool: tools[attributes.tool],
        lastTool: tools[attributes.lastTool]
      };
      return this.trigger('change');
    };

    UIState.prototype.DEFAULTS = function() {
      return {
        fill: new Color("#5fcda7"),
        stroke: new Color("#000000"),
        strokeWidth: 1.0,
        zoom: 1.0,
        normal: new Posn(-1, -1),
        tool: tools.cursor,
        lastTool: tools.cursor
      };
    };

    return UIState;

  })();

  $.extend(UIState.prototype, mixins.events);

  window.UIState = UIState;

  /*
  
    Manages elements being selected
  
    API:
  
    All selected elements:
    ui.selection.elements.all
  
    All selected points:
    ui.selection.points.all
  
    Both ui.selection.elements and ui.selection.points
    have the following methods:
  
    select(elems)
    selectMore(elems)
    selectAll
    deselect(elems)
    deselectAll
  */


  ui.selection = {
    elements: {
      all: [],
      clone: function() {
        return this.all.map(function(elem) {
          return elem.clone();
        });
      },
      empty: function() {
        return this.all.length === 0;
      },
      exists: function() {
        return !this.empty();
      },
      select: function(elems) {
        ui.selection.points.deselectAll();
        if (elems instanceof Array) {
          this.all = elems;
        } else {
          this.all = [elems];
        }
        return this.trigger('change');
      },
      selectMore: function(elems) {
        var elem, _i, _len;
        ui.selection.points.deselectAll();
        if (elems instanceof Array) {
          for (_i = 0, _len = elems.length; _i < _len; _i++) {
            elem = elems[_i];
            this.all.ensure(elem);
          }
        } else {
          this.all.ensure(elems);
        }
        return this.trigger('change');
      },
      selectAll: function() {
        ui.selection.points.deselectAll();
        this.all = ui.elements;
        return this.trigger('change');
      },
      selectWithinBounds: function(bounds) {
        var rect;
        ui.selection.points.deselectAll();
        rect = bounds.toRect();
        this.all = ui.elements.filter(function(elem) {
          return elem.overlaps(rect);
        });
        return this.trigger('change');
      },
      deselect: function(elems) {
        this.all.remove(elems);
        return this.trigger('change');
      },
      deselectAll: function() {
        if (this.all.length === 0) {
          return;
        }
        this.all = [];
        return this.trigger('change');
      },
      each: function(func) {
        return this.all.forEach(func);
      },
      map: function(func) {
        return this.all.map(func);
      },
      filter: function(func) {
        return this.all.filter(func);
      },
      zIndexes: function() {
        var e, _i, _len, _ref3, _results;
        _ref3 = this.all;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          e = _ref3[_i];
          _results.push(e.zIndex());
        }
        return _results;
      },
      ofType: function(type) {
        return this.filter(function(e) {
          return e.type === type;
        });
      },
      validate: function() {
        this.all = this.filter(function(elem) {
          return ui.elements.has(elem);
        });
        return this.trigger('change');
      },
      "export": function(opts) {
        var svg;
        if (this.empty()) {
          return "";
        }
        opts = $.extend({
          trim: false
        }, opts);
        svg = new SVG(this.clone());
        if (opts.trim) {
          svg.trim();
        }
        return svg.toString();
      },
      exportAsDataURI: function() {
        return "data:image/svg+xml;base64," + (btoa(this["export"]()));
      },
      exportAsPNG: function(opts) {
        return new PNG(this["export"](opts));
      },
      asDataURI: function() {}
    },
    points: {
      all: [],
      empty: function() {
        return this.all.length === 0;
      },
      exists: function() {
        return !this.empty();
      },
      select: function(points) {
        ui.selection.elements.deselectAll();
        if (points instanceof Array) {
          this.all = points;
        } else {
          this.all = [points];
        }
        this.all.forEach(function(p) {
          return p.select();
        });
        return this.trigger('change');
      },
      selectMore: function(points) {
        var _this = this;
        ui.selection.elements.deselectAll();
        if (points instanceof Array) {
          points.forEach(function(point) {
            _this.all.ensure(point);
            return point.select();
          });
        } else {
          this.all.ensure(points);
          points.select();
        }
        return this.trigger('change');
      },
      deselect: function(points) {
        points.forEach(function(point) {
          return point.deselect();
        });
        this.all.remove(points);
        return this.trigger('change');
      },
      deselectAll: function() {
        if (this.all.length === 0) {
          return;
        }
        this.all.forEach(function(point) {
          return point.deselect();
        });
        this.all = [];
        return this.trigger('change');
      },
      zIndexes: function() {
        var point, zIndexes, zi, _i, _len, _ref3;
        zIndexes = {};
        _ref3 = this.all;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          point = _ref3[_i];
          zi = point.owner.zIndex();
          if (zIndexes[zi] == null) {
            zIndexes[zi] = [];
          }
          zIndexes[zi].push(point.at);
        }
        return zIndexes;
      },
      show: function() {
        return this.all.map(function(p) {
          return p.show;
        });
      },
      hide: function() {
        return this.all.map(function(p) {
          return p.hide(true);
        });
      },
      each: function(func) {
        return this.all.forEach(func);
      },
      filter: function(func) {
        return this.all.filter(func);
      },
      validate: function() {
        this.all = this.filter(function(pt) {
          return ui.elements.has(pt.owner);
        });
        return this.trigger('changed');
      }
    },
    refresh: function() {
      return this.elements.validate();
    }
  };

  $.extend(ui.selection.elements, mixins.events);

  $.extend(ui.selection.points, mixins.events);

  $.extend(ui.selection, {
    macro: function(actions) {
      if (actions.elements != null) {
        this.elements.each(function(e) {
          return actions.elements.call(e);
        });
      }
      if (actions.points != null) {
        this.points.each(function(p) {
          return actions.points.call(p);
        });
      }
      if ((actions.transformer != null) && this.elements.exists()) {
        actions.transformer.call(ui.transformer);
      }
      return ui.utilities.transform.refreshValues();
    },
    nudge: function(x, y, makeEvent) {
      if (makeEvent == null) {
        makeEvent = true;
      }
      this.macro({
        elements: function() {
          return this.nudge(x, y);
        },
        points: function() {
          var _ref3;
          this.nudge(x, y);
          if ((_ref3 = this.antlers) != null) {
            _ref3.refresh();
          }
          return this.owner.commit();
        },
        transformer: function() {
          return this.nudge(x, -y).redraw();
        }
      });
      if (makeEvent) {
        archive.addMapEvent('nudge', this.elements.zIndexes(), {
          x: x,
          y: y
        });
        return this.elements.each(function(e) {
          return e.refreshUI();
        });
      }
    },
    scale: function(x, y, origin) {
      if (origin == null) {
        origin = ui.transformer.center();
      }
      return this.macro({
        elements: function() {
          return this.scale(x, y, origin);
        }
      });
    },
    rotate: function(a, origin) {
      if (origin == null) {
        origin = ui.transformer.center();
      }
      return this.macro({
        elements: function() {
          return this.rotate(a, origin);
        },
        transformer: function() {
          return this.rotate(a, origin).redraw();
        }
      });
    },
    "delete": function() {
      return this.macro({
        elements: function() {
          return this["delete"]();
        }
      });
    }
  });

  ui.window = {
    setup: function() {
      var _this = this;
      window.onfocus = function(e) {
        return _this.trigger('focus', [e]);
      };
      window.onblur = function(e) {
        return _this.trigger('blur', [e]);
      };
      window.onerror = function(msg, url, ln) {
        return _this.trigger('error', [msg, url, ln]);
      };
      window.onresize = function(e) {
        return _this.trigger('resize', [e]);
      };
      window.onscroll = function(e) {
        return _this.trigger('scroll', [e]);
      };
      return window.onmousewheel = function(e) {
        return _this.trigger('mousewheel', [e]);
      };
    },
    listeners: {},
    listenersOne: {},
    on: function(event, action) {
      var listeners;
      listeners = this.listeners[event];
      if (listeners === void 0) {
        listeners = this.listeners[event] = [];
      }
      return listeners.push(action);
    },
    one: function(event, action) {
      var listeners;
      listeners = this.listenersOne[event];
      if (listeners === void 0) {
        listeners = this.listenersOne[event] = [];
      }
      return listeners.push(action);
    },
    trigger: function(event, args) {
      var a, l, lo, _i, _j, _len, _len1;
      l = this.listeners[event];
      if (l != null) {
        for (_i = 0, _len = l.length; _i < _len; _i++) {
          a = l[_i];
          a.apply(this, args);
        }
      }
      lo = this.listenersOne[event];
      if (lo != null) {
        for (_j = 0, _len1 = lo.length; _j < _len1; _j++) {
          a = lo[_j];
          a.apply(this, args);
        }
        return delete this.listenersOne[event];
      }
    },
    width: function() {
      return window.innerWidth;
    },
    height: function() {
      return window.innerHeight;
    },
    halfw: function() {
      return this.width() / 2;
    },
    halfh: function() {
      return this.height() / 2;
    },
    center: function() {
      return new Posn(this.width() / 2, this.height() / 2);
    },
    centerOn: function(p) {
      var x, y;
      x = this.width() / 2 - (p.x * ui.canvas.zoom);
      y = this.height() / 2 - (p.y * ui.canvas.zoom);
      ui.canvas.normal = new Posn(x, y);
      return ui.canvas.refreshPosition();
    }
  };

  setup.push(function() {
    return ui.window.setup();
  });

  /*
  
  
    In-app Clipboard
  
    Cut, Copy, and Paste
  */


  ui.clipboard = {
    data: void 0,
    cut: function() {
      var elem, _i, _len, _ref3, _results;
      if (ui.selection.elements.all.length === 0) {
        return;
      }
      this.copy();
      _ref3 = ui.selection.elements.all;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        _results.push(elem["delete"]());
      }
      return _results;
    },
    copy: function() {
      if (ui.selection.elements.all.length === 0) {
        return;
      }
      return this.data = ui.selection.elements["export"]();
    },
    paste: function() {
      var adjust, bounds, elem, fit, p, parsed, _i, _len;
      if (this.data == null) {
        return;
      }
      parsed = io.parseAndAppend(this.data, false);
      bounds = new Bounds((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parsed.length; _i < _len; _i++) {
          p = parsed[_i];
          _results.push(p.bounds());
        }
        return _results;
      })());
      fit = bounds.clone();
      fit.centerOn(ui.canvas.posnInCenterOfWindow());
      adjust = bounds.adjustElemsTo(fit);
      for (_i = 0, _len = parsed.length; _i < _len; _i++) {
        elem = parsed[_i];
        adjust(elem);
      }
      ui.selection.elements.select(parsed);
      return archive.addExistenceEvent(parsed.map(function(p) {
        return p.rep;
      }));
    }
  };

  setup.push(function() {
    return ui.window.on("error", function(msg, url, ln) {
      return trackEvent("Javascript", "Error", "" + msg);
    });
  });

  /*
  
    Keeping track of when the user is away from keyboard.
    We can do calculations and stuff when this happens, and
    not bother doing certain things like re-saving the browser file state.
  */


  ui.afk = {
    active: false,
    activate: function() {
      this.active = true;
      return this.startTasks();
    },
    activateTimerId: void 0,
    reset: function() {
      var _this = this;
      this.active = false;
      clearTimeout(this.activateTimerId);
      return this.activateTimerId = setTimeout(function() {
        return _this.activate();
      }, 2000);
    },
    tasks: {},
    "do": function(key, fun) {
      return this.tasks[key] = fun;
    },
    stop: function(key) {
      return delete this.tasks[key];
    },
    startTasks: function(tasks) {
      var hd;
      if (tasks == null) {
        tasks = objectValues(this.tasks);
      }
      hd = tasks[0];
      if (typeof hd === "function") {
        hd();
      }
      if (tasks.length > 1 && this.active) {
        return this.startTasks(tasks.slice(1));
      }
    }
  };

  /*
  
    TopUI
  
    An agnostic sort of "tool" that doesn't care what tool is selected.
    Specifically for dealing with top UI elements like utilities.
  
    Operates much like a Tool object, but the keys are classnames of top UI objects.
  */


  ui.topUI = {
    dispatch: function(e, event) {
      var cl, _base, _base1, _i, _len, _name, _name1, _ref3;
      _ref3 = e.target.className.split(" ");
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        cl = _ref3[_i];
        if (typeof (_base = this[event])[_name = "." + cl] === "function") {
          _base[_name](e);
        }
      }
      return typeof (_base1 = this[event])[_name1 = "#" + e.target.id] === "function" ? _base1[_name1](e) : void 0;
    },
    hover: {
      "slider knob": function(e) {}
    },
    unhover: {
      "slider knob": function() {}
    },
    click: {
      ".swatch": function(e) {
        var $swatch, offset;
        if (e.target.parentNode.className === "swatch-duo") {
          return;
        }
        $swatch = $(e.target);
        offset = $swatch.offset();
        ui.utilities.color.setting = e.target;
        return ui.utilities.color.toggle().position(offset.left + 41, offset.top).ensureVisibility();
      },
      "#transparent-permanent-swatch": function() {
        ui.utilities.color.set(ui.colors["null"]);
        ui.utilities.color.updateIndicator();
        if (ui.selection.elements.all.length) {
          return archive.addAttrEvent(ui.selection.elements.zIndexes(), ui.utilities.color.setting.getAttribute("type"));
        }
      },
      ".tool-button": function(e) {
        return ui.switchToTool(tools[e.target.id.replace("-btn", "")]);
      },
      ".slider": function(e) {
        return $(e.target).trigger("release");
      }
    },
    mousemove: {
      "slider knob": function() {}
    },
    mousedown: {
      "slider knob": function() {}
    },
    mouseup: {
      "#color-pool": function(e) {
        ui.utilities.color.selectColor(e);
        trackEvent("Color", "Choose", ui.utilities.color.selectedColor.toString());
        if (ui.selection.elements.all.length > 0) {
          return archive.addAttrEvent(ui.selection.elements.zIndexes(), ui.utilities.color.setting.getAttribute("type"));
        }
      }
    },
    startDrag: {
      ".slider-container": function(e) {
        console.log(5);
        return ui.cursor.lastDownTarget = $(e.target).find(".knob")[0];
      }
    },
    continueDrag: {
      "#color-pool": function(e) {
        return ui.utilities.color.selectColor(e);
      },
      ".knob": function(e) {
        var change;
        change = new Posn(e).subtract(ui.cursor.lastPosn);
        return $(e.target).nudge(change.x, 0);
      }
    },
    stopDrag: {
      ".knob": function(e) {
        return $(e.target).trigger("stopDrag");
      }
    }
  };

  /*
  
    Swatch is to Color as Point is to Posn
  */


  Swatch = (function(_super) {
    __extends(Swatch, _super);

    function Swatch(r, g, b, a) {
      var _this = this;
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a != null ? a : 1.0;
      if (this.r instanceof Color) {
        this.g = this.r.g;
        this.b = this.r.b;
        this.a = this.r.a;
        this.r = this.r.r;
      }
      Swatch.__super__.constructor.call(this, this.r, this.g, this.b, this.a);
      this.$rep = $("<div class=\"swatch\"></div>");
      this.rep = this.$rep[0];
      this.refresh();
      this.$rep.on("set", function(event, color) {
        _this.absorb(color);
        return _this.refresh();
      });
      this;
    }

    Swatch.prototype.refresh = function() {
      var elem, tiedTo, _i, _len, _ref3, _results;
      if (this.r === null) {
        this.rep.style.backgroundColor = "";
        this.rep.style.border = "";
        this.rep.setAttribute("empty", "");
        this.rep.setAttribute("val", "empty");
      } else {
        this.rep.style.backgroundColor = this.toString();
        this.rep.style.border = "1px solid " + (this.clone().darken(1.5).toHexString());
        this.rep.removeAttribute("empty");
        this.rep.setAttribute("val", this.toString());
      }
      if (this.type != null) {
        this.rep.setAttribute("type", this.type);
        tiedTo = this.tiedTo();
        if (tiedTo instanceof Array) {
          _ref3 = this.tiedTo();
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            elem = _ref3[_i];
            elem.data[this.type] = this.clone();
            _results.push(elem.commit());
          }
          return _results;
        } else {
          tiedTo.data[this.type] = this.clone();
          return tiedTo.commit();
        }
      }
    };

    Swatch.prototype.tiedTo = function() {
      return ui.selection.elements.all;
    };

    Swatch.prototype.type = null;

    Swatch.prototype.appendTo = function(selector) {
      q(selector).appendChild(this.rep);
      return this;
    };

    return Swatch;

  })(Color);

  window.Swatch = Swatch;

  SwatchDuo = (function() {
    function SwatchDuo(fill, stroke) {
      this.fill = fill;
      this.stroke = stroke;
      if (this.fill instanceof Monsvg) {
        if (this.fill.data.stroke === void 0) {
          this.stroke = new Swatch(null);
        } else {
          this.stroke = new Swatch(this.fill.data.stroke);
        }
        if (this.fill.data.fill === void 0) {
          this.fill = new Swatch(null);
        } else {
          this.fill = new Swatch(this.fill.data.fill);
        }
      }
      this.fill.type = "fill";
      this.stroke.type = "stroke";
      this.$rep = $("<div class=\"swatch-duo\"></div>");
      this.$rep.append(this.fill.$rep);
      this.$rep.append(this.stroke.$rep);
      this.$rep.attr("key", this.toString());
      this.rep = this.$rep[0];
    }

    SwatchDuo.prototype.tiedTo = function() {};

    SwatchDuo.prototype.toString = function() {
      return "" + (this.fill.toHexString()) + "/" + (this.stroke.toHexString());
    };

    return SwatchDuo;

  })();

  /*
  
    Snapping
  
          /
         /
        O
       /    o
      /
     /
    /
  
    Provides four main endpoints:
      toAnyOf
      toOneOf
      toThis
      toNothing
  
    ...with which you should be able to implement any sort of snapping behavior.
  
    Call any of these within a tool use snapping. Usually within the tool's activateModifier method.
  
    NOTE: toNothing gets called in all tearDown methods, so undoing snapping is usually already taken care of.
          It's more the calling it to begin with that has to be done.
  */


  ui.snap = {
    toNothing: function() {
      this.removeAnnotationLine();
      return this.supplementEvent = function(e) {
        return e;
      };
    },
    toAnyOf: function(lines, tolerance, onUpdate) {
      if (onUpdate == null) {
        onUpdate = function() {};
      }
      this.removeAnnotationLine();
      return this.supplementEvent = function(e) {
        return e;
      };
    },
    toOneOf: function(lines, posnLevel, onUpdate) {
      if (posnLevel == null) {
        posnLevel = "client";
      }
      if (onUpdate == null) {
        onUpdate = function() {};
      }
      this.removeAnnotationLine();
      return this.supplementEvent = function(e) {
        var distances, snap;
        e = cloneObject(e);
        distances = {};
        lines.map(function(l) {
          var perpDist;
          perpDist = new Posn(e["" + posnLevel + "X"], e["" + posnLevel + "Y"]).perpendicularDistanceFrom(l);
          if (perpDist != null) {
            return distances[perpDist[0]] = perpDist[1];
          }
        });
        snap = distances[Math.min.apply(this, Object.keys(distances).map(parseFloat))];
        e["" + posnLevel + "X"] = snap.x;
        e["" + posnLevel + "Y"] = snap.y;
        ui.cursor.currentPosn = snap;
        onUpdate(e);
        return e;
      };
    },
    supplementForGrid: function(e) {
      var cp;
      e = cloneObject(e);
      cp = e.canvasPosnZoomed;
      cp = this.snapPointToGrid(cp);
      return e;
    },
    snapPointToGrid: function(p) {
      var freq;
      freq = ui.grid.frequency;
      p.x = p.x.toNearest(freq.x, freq.x / 3);
      p.y = p.y.toNearest(freq.y, freq.y / 3);
      return p;
    },
    toThis: function(line, onUpdate) {
      if (onUpdate == null) {
        onUpdate = function() {};
      }
      return this.removeAnnotationLine();
    },
    annotationLine: null,
    removeAnnotationLine: function() {
      var _ref3;
      if ((_ref3 = this.annotationLine) != null) {
        _ref3.remove();
      }
      return this.annotationLine = null;
    },
    updateAnnotationLine: function(a, b) {
      if (this.annotationLine == null) {
        return this.annotationLine = ui.annotations.drawLine(a, b, 'rgba(73,130,224,0.3)');
      } else {
        this.annotationLine.absorbA(a);
        this.annotationLine.absorbB(b);
        return this.annotationLine.commit();
      }
    },
    presets: {
      every45: function(op, posnLevel) {
        return ui.snap.toOneOf([new Ray(op, 0), new Ray(op, 45), new Ray(op, 90), new Ray(op, 135), new Ray(op, 180), new Ray(op, 225), new Ray(op, 270), new Ray(op, 315)], posnLevel);
      }
    }
  };

  /*
  
    The canvas
  
     _______________
    |               |
    |               |
    |               |
    |               |
    |               |
    |_______________|
  
    Manages canvas panning/zooming
  */


  ui.canvas = {
    /*
    
    A note about zoom:
    
    There are three categories of elements in Mondrian regarding zoom:
    
    
    1 Annotation
      Elements who scale with zoom, but retain certain aesthetic features.
      They don't literally stretch with the zoom.
    
      Examples:
        HoverTargets: their position and size changes, but not their strokeWidth
        Points:       their position changes, but stay the same size
        The canvas:   its size changes but its 1px outline remains 1px
    
    
    2 Canvas
      Elements who scale with zoom entirely, meaning "real" zoom. Their stroke gets
      thicker, their position gets larger.
    
      Examples:
        The actual SVG elements being drawn.
    
    
    3 Client
      Elements who don't give a flying fuck how far you've zoomed in.
      These guys still alter their functionality a bit but 10,10 will always
      mean 10,10 visually. Sole difference between this and Annotation
      is the position of this relies not on the SVG Elements but the cursor/client.
    
      Examples:
        Drag selection
        Cursor
    */

    zoom: 1.0,
    width: 1000,
    height: 800,
    panLimitX: function() {
      return Math.max(500, ((ui.window.width() - this.width * this.zoom) / 2) + ui.window.width() / 3);
    },
    panLimitY: function() {
      return Math.max(500, ((ui.window.height() - this.height * this.zoom) / 2) + ui.window.height() / 3);
    },
    origin: new Posn(0, 0),
    normal: new Posn(-1, -1),
    show: function() {
      return dom.canvas.style.display = "block";
    },
    hide: function() {
      return dom.canvas.style.display = "none";
    },
    redraw: function(centering) {
      var diff, stretch, transformScaleRule, wh, ww, _ref10, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      if (centering == null) {
        centering = false;
      }
      if ((_ref3 = dom.main) != null) {
        _ref3.style.width = this.width.px();
      }
      if ((_ref4 = dom.main) != null) {
        _ref4.style.height = this.height.px();
      }
      if ((_ref5 = dom.main) != null) {
        _ref5.setAttribute("width", this.width);
      }
      if ((_ref6 = dom.main) != null) {
        _ref6.setAttribute("height", this.height);
      }
      if ((_ref7 = dom.main) != null) {
        _ref7.setAttribute("viewbox", "0 0 " + this.width + " " + this.height);
      }
      if ((_ref8 = dom.main) != null) {
        _ref8.setAttribute("enable-background", "new 0 0 " + this.width + " " + this.height);
      }
      if ((_ref9 = dom.grid) != null) {
        _ref9.setAttribute("width", this.width);
      }
      if ((_ref10 = dom.grid) != null) {
        _ref10.setAttribute("height", this.height);
      }
      transformScaleRule = {
        "transform": "scale(" + ui.canvas.zoom + ")",
        "-webkit-transform": "scale(" + ui.canvas.zoom + ")",
        "-moz-transform": "scale(" + ui.canvas.zoom + ")"
      };
      dom.$main.css(transformScaleRule);
      dom.$grid.css(transformScaleRule);
      stretch = function(e) {
        e.style.width = (_this.width * ui.canvas.zoom).px();
        return e.style.height = (_this.height * ui.canvas.zoom).px();
      };
      [dom.bg, dom.annotations, dom.hoverTargets].map(stretch);
      ww = ui.window.width();
      wh = ui.window.height();
      if (centering) {
        if (this.width < ww) {
          diff = ww - this.width;
          this.normal.x = diff / 2;
        }
        if (this.height < wh) {
          diff = wh - this.height;
          this.normal.y = diff / 2;
        }
      }
      this.refreshPosition();
      return this;
    },
    nudge: function(x, y) {
      this.normal = this.normal.add(new Posn(x, -y));
      this.ensureVisibility();
      this.snapToIntegers();
      return this.refreshPosition();
    },
    snapToIntegers: function() {
      this.normal.x = Math.round(this.normal.x);
      return this.normal.y = Math.round(this.normal.y);
    },
    ensureVisibility: function() {
      var height, limitX, limitY, width;
      limitX = this.panLimitX();
      limitY = this.panLimitY();
      width = ui.window.width();
      height = ui.window.height();
      if (this.normal.x > limitX) {
        this.normal.x = limitX;
      }
      if (this.normal.x < -limitX - (this.width * this.zoom) + width) {
        this.normal.x = -limitX - (this.width * this.zoom) + width;
      }
      if (this.normal.y > limitY) {
        this.normal.y = limitY;
      }
      if (this.normal.y < -limitY - (this.height * this.zoom) + height) {
        this.normal.y = -limitY - (this.height * this.zoom) + height;
      }
      return this.refreshPosition();
    },
    refreshPosition: function() {
      var _ref3, _ref4;
      if ((_ref3 = dom.canvas) != null) {
        _ref3.style.left = this.normal.x;
      }
      if ((_ref4 = dom.canvas) != null) {
        _ref4.style.top = this.normal.y;
      }
      ui.uistate.set('normal', this.normal);
      return this;
    },
    setZoom: function(zoom) {
      var prevCenter;
      ui.selection.points.hide();
      prevCenter = ui.window.centerRelativeToCanvas();
      this.zoom = zoom;
      this.redraw();
      ui.transformer.redraw(true);
      ui.window.centerOn(prevCenter);
      return this.ensureVisibility();
    },
    center: function() {
      return this.normal.add(new Posn((this.width * this.zoom) / 2, (this.height * this.zoom) / 2));
    },
    centerOn: function(posn) {
      posn = posn.subtract(this.center());
      this.normal.x += posn.x;
      this.normal.y += posn.y;
      return this.refreshPosition();
    },
    posnInCenterOfWindow: function() {
      return ui.window.center().subtract(this.normal).setZoom(ui.canvas.zoom);
    },
    zoomIn: function(amt) {
      if (amt == null) {
        amt = 1.15;
      }
      return this.setZoom(this.zoom * amt);
    },
    zoomOut: function(amt) {
      if (amt == null) {
        amt = 0.85;
      }
      return this.setZoom(this.zoom * amt);
    },
    zoom100: function() {
      this.setZoom(1);
      return this.centerOn(ui.window.center());
    },
    zoomToFit: function(bounds) {
      var center, heightChange, oldnormal, widthChange, zoomAmt,
        _this = this;
      oldnormal = this.normal.clone();
      center = bounds.center();
      widthChange = (ui.window.width() / this.zoom) / bounds.width;
      heightChange = (ui.window.height() / this.zoom) / bounds.height;
      zoomAmt = Math.min(widthChange, heightChange);
      this.setZoom(ui.canvas.zoom * zoomAmt);
      ui.window.centerOn(center);
      return async(function() {
        return ui.refreshAfterZoom();
      });
    },
    petrified: false,
    petrify: function() {
      var $mainpetrified;
      this.petrified = true;
      $mainpetrified = dom.$main.clone();
      $mainpetrified.attr('id', 'main-petrified');
      dom.$hoverTargets.hide();
      dom.$annotations.hide();
      return dom.$main.hide().after($mainpetrified);
    },
    depetrify: function() {
      this.petrified = false;
      dom.$hoverTargets.show();
      dom.$annotations.show();
      return dom.$main.show().next().remove();
    }
  };

  setup.push(function() {
    return ui.canvas.redraw();
  });

  /*
  
    Cursor event overriding :D
  
    This shit tracks exactly what the cursor is doing and implements some
    custom cursor functions like dragging, which are dispatched via the ui object.
  */


  ui.cursor = {
    reset: function() {
      this.down = false;
      this.wasDownLast = false;
      this.downOn = void 0;
      this.dragging = false;
      this.draggingJustBegan = false;
      this.currentPosn = void 0;
      this.lastPosn = void 0;
      this.lastEvent = void 0;
      this.lastDown = void 0;
      this.lastDownTarget = void 0;
      this.lastUp = void 0;
      this.lastUpTarget = void 0;
      this.inHoverState = void 0;
      this.lastHoverState = void 0;
      this.resetOnNext = false;
      this.doubleclickArmed = false;
      return true;
    },
    snapChangeAccum: {
      x: 0,
      y: 0
    },
    resetSnapChangeAccumX: function() {
      return this.snapChangeAccum.x = 0;
    },
    resetSnapChangeAccumY: function() {
      return this.snapChangeAccum.y = 0;
    },
    dragAccum: function() {
      var s;
      s = this.lastPosn.subtract(this.lastDown);
      return {
        x: s.x,
        y: s.y
      };
    },
    armDoubleClick: function() {
      var _this = this;
      this.doubleclickArmed = true;
      return setTimeout(function() {
        return _this.doubleclickArmed = false;
      }, SETTINGS.DOUBLE_CLICK_THRESHOLD);
    },
    setup: function() {
      var _this = this;
      this.reset();
      this._click = function(e) {
        if (isDefaultQuarantined(e.target)) {
          return true;
        } else {
          return e.stopPropagation();
        }
      };
      this._mousedown = function(e) {
        ui.afk.reset();
        if (isDefaultQuarantined(e.target)) {
          if (!allowsHotkeys(e.target)) {
            ui.hotkeys.disable();
          }
          _this.reset();
          return true;
        } else {
          e.stopPropagation();
          $('input:focus').blur();
          $('[contenteditable]').blur();
          ui.hotkeys.use("app");
          e.originalEvent.preventDefault();
          ui.mousedown(e, e.target);
          _this.down = true;
          _this.lastDown = new Posn(e);
          _this.downOn = e.target;
          return _this.lastDownTarget = e.target;
        }
      };
      this._mouseup = function(e) {
        if (isDefaultQuarantined(e.target)) {
          if (!allowsHotkeys(e.target)) {
            ui.hotkeys.disable();
          }
          ui.dragSelection.end((function() {}), true);
          return true;
        } else {
          ui.hotkeys.use("app");
          ui.mouseup(e, e.target);
          if (_this.dragging && !_this.draggingJustBegan) {
            ui.stopDrag(e, _this.lastDownTarget);
          } else {
            if (_this.doubleclickArmed) {
              _this.doubleclickArmed = false;
              ui.doubleclick(_this.lastEvent, _this.lastDownTarget);
              if (isDefaultQuarantined(e.target)) {
                if (!allowsHotkeys(e.target)) {
                  ui.hotkeys.disable();
                }
                ui.dragSelection.end((function() {}), true);
              }
            } else {
              ui.click(e, e.target);
              if (e.target.nodeName === "text") {
                _this.armDoubleClick();
              }
            }
          }
          _this.dragging = false;
          _this.down = false;
          _this.lastUp = new Posn(e);
          _this.lastUpTarget = e.target;
          return _this.draggingJustBegan = false;
        }
      };
      this._mousemove = function(e) {
        _this.doubleclickArmed = false;
        ui.afk.reset();
        _this.lastPosn = _this.currentPosn;
        _this.currentPosn = new Posn(e);
        if (isDefaultQuarantined(e.target)) {
          if (!allowsHotkeys(e.target)) {
            ui.hotkeys.disable();
          }
          return true;
        } else {
          if (true) {
            ui.mousemove(e, e.target);
            e.preventDefault();
            _this.wasDownLast = _this.down;
            _this.lastEvent = e;
            _this.currentPosn = new Posn(e);
            if (_this.down) {
              if (_this.dragging) {
                ui.continueDrag(e, _this.lastDownTarget);
                return _this.draggingJustBegan = false;
              } else if (_this.currentPosn.distanceFrom(_this.lastDown) > SETTINGS.DRAG_THRESHOLD) {
                ui.startDrag(_this.lastEvent, _this.lastDownTarget);
                return _this.dragging = _this.draggingJustBegan = true;
              }
            }
          }
        }
      };
      this._mouseover = function(e) {
        if (_this.dragging) {
          return;
        }
        _this.lastHoverState = _this.inHoverState;
        _this.inHoverState = e.target;
        if (_this.lastHoverState != null) {
          ui.unhover(e, _this.lastHoverState);
        }
        return ui.hover(e, _this.inHoverState);
      };
      $('body').click(function(e) {
        return _this._click(e);
      }).mousemove(function(e) {
        return _this._mousemove(e);
      }).mousedown(function(e) {
        return _this._mousedown(e);
      }).mouseup(function(e) {
        return _this._mouseup(e);
      }).mouseover(function(e) {
        return _this._mouseover(e);
      }).on('contextmenu', function(e) {
        return e.preventDefault();
      });
      return ui.window.on('focus', function() {
        return _this.currentPosn = new Posn(-100, -100);
      });
    }
  };

  setup.push(function() {
    return ui.cursor.setup();
  });

  ui.dragSelection = {
    origin: {
      x: 0,
      y: 0
    },
    tl: {
      x: 0,
      y: 0
    },
    width: 0,
    height: 0,
    asRect: function() {
      return new Rect({
        x: dom.$dragSelection.css('left').toFloat() - ui.canvas.normal.x,
        y: dom.$dragSelection.css('top').toFloat() - ui.canvas.normal.y,
        width: this.width,
        height: this.height
      });
    },
    bounds: function() {
      return new Bounds(dom.$dragSelection.css('left').toFloat() - ui.canvas.normal.x, dom.$dragSelection.css('top').toFloat() - ui.canvas.normal.y, this.width, this.height);
    },
    start: function(posn) {
      this.origin.x = posn.x;
      this.origin.y = posn.y;
      return dom.$dragSelection.show();
    },
    move: function(posn) {
      this.tl = new Posn(Math.min(posn.x, this.origin.x), Math.min(posn.y, this.origin.y));
      this.width = Math.max(posn.x, this.origin.x) - this.tl.x - 1;
      this.height = Math.max(posn.y, this.origin.y) - this.tl.y;
      return dom.$dragSelection.css({
        top: this.tl.y,
        left: this.tl.x,
        width: this.width,
        height: this.height
      });
    },
    end: function(resultFunc, fuckingStopRightNow) {
      var iz;
      if (fuckingStopRightNow == null) {
        fuckingStopRightNow = false;
      }
      dom.$dragSelection.hide();
      if (fuckingStopRightNow) {
        return;
      }
      if (this.width < 3 && this.height < 3) {
        return ui.selection.elements.deselectAll();
      }
      iz = 1 / ui.canvas.zoom;
      resultFunc(this.bounds().scale(iz, iz, ui.canvas.origin));
      return dom.$dragSelection.hide().css({
        left: '',
        top: '',
        width: '',
        height: ''
      });
    }
  };

  /*
  
    UI selected elements transformer
  */


  ui.transformer = {
    angle: 0,
    resetAccum: function() {
      this.accumX = 1.0;
      this.accumY = 1.0;
      this.accumA = 0.0;
      this.origin = void 0;
      return this;
    },
    hide: function() {
      var i, r, _ref3, _results;
      _ref3 = this.reps;
      _results = [];
      for (i in _ref3) {
        if (!__hasProp.call(_ref3, i)) continue;
        r = _ref3[i];
        _results.push(r.style.display = "none");
      }
      return _results;
    },
    show: function() {
      var i, r, _ref3, _results;
      this.resetAccum();
      _ref3 = this.reps;
      _results = [];
      for (i in _ref3) {
        if (!__hasProp.call(_ref3, i)) continue;
        r = _ref3[i];
        _results.push(r.style.display = "block");
      }
      return _results;
    },
    center: function() {
      return new LineSegment(this.tl, this.br).midPoint();
    },
    refresh: function() {
      var angles, center, elem, toAngle, _i, _j, _len, _len1, _ref3, _ref4;
      this.deriveCorners(ui.selection.elements.all);
      center = this.center();
      if (ui.selection.elements.all.length === 0) {
        return this.hide();
      } else {
        this.show();
      }
      angles = new Set(ui.selection.elements.all.map(function(elem) {
        return elem.metadata.angle;
      }));
      if (angles.length === 1) {
        this.angle = parseFloat(angles[0]);
      } else {
        ui.selection.elements.all.map(function(elem) {
          return elem.metadata.angle = 0;
        });
      }
      _ref3 = ui.selection.elements.all;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        if (this.angle !== 0) {
          elem.rotate(360 - this.angle, center);
          elem.clearCachedObjects();
        }
        elem.clearCachedObjects();
        elem.lineSegments();
      }
      this.deriveCorners(ui.selection.elements.all);
      if (this.angle !== 0) {
        _ref4 = ui.selection.elements.all;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          elem = _ref4[_j];
          elem.rotate(this.angle, center);
        }
        toAngle = this.angle;
        this.angle = 0;
        this.rotate(toAngle, center);
      }
      this.redraw();
      return this;
    },
    deriveCorners: function(shapes) {
      var elem, getMax, getMin, xMax, xMin, xRanges, yMax, yMin, yRanges;
      if (shapes.length === 0) {
        this.tl = this.tr = this.br = this.bl = new Posn(0, 0);
        this.width = this.height = 0;
        return;
      }
      xRanges = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = shapes.length; _i < _len; _i++) {
          elem = shapes[_i];
          _results.push(elem.xRange());
        }
        return _results;
      })();
      yRanges = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = shapes.length; _i < _len; _i++) {
          elem = shapes[_i];
          _results.push(elem.yRange());
        }
        return _results;
      })();
      getMin = function(rs) {
        return Math.min.apply(this, rs.map(function(a) {
          return a.min;
        }));
      };
      getMax = function(rs) {
        return Math.max.apply(this, rs.map(function(a) {
          return a.max;
        }));
      };
      xMin = getMin(xRanges);
      xMax = getMax(xRanges);
      yMin = getMin(yRanges);
      yMax = getMax(yRanges);
      this.tl = new Posn(xMin, yMin);
      this.tr = new Posn(xMax, yMin);
      this.br = new Posn(xMax, yMax);
      this.bl = new Posn(xMin, yMax);
      this.lc = new Posn(xMin, yMin + (yMax - yMin) / 2);
      this.rc = new Posn(xMax, yMin + (yMax - yMin) / 2);
      this.tc = new Posn(xMin + (xMax - xMin) / 2, yMin);
      this.bc = new Posn(xMin + (xMax - xMin) / 2, yMax);
      this.width = xMax - xMin;
      this.height = yMax - yMin;
      if (this.width === 0) {
        this.width = 1;
      }
      if (this.height === 0) {
        return this.height = 1;
      }
    },
    pixelToFloat: function(amt, length) {
      if (amt === 0) {
        return 1;
      }
      return 1 + (amt / length);
    },
    redraw: function() {
      var center, corner, cp, tl, zl, _i, _len, _ref3;
      if (ui.selection.elements.all.length === 0) {
        return this.hide();
      }
      tl = this.correctAngle(this.tl);
      zl = ui.canvas.zoom;
      center = this.center().zoomed();
      _ref3 = ["tl", "tr", "br", "bl", "tc", "rc", "bc", "lc"];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        corner = _ref3[_i];
        cp = this[corner].zoomedc();
        this.reps[corner].style.left = Math.floor(cp.x, 10);
        this.reps[corner].style.top = Math.floor(cp.y, 10);
        this.reps[corner].style.WebkitTransform = "rotate(" + this.angle + "deg)";
        this.reps[corner].style.MozTransform = "rotate(" + this.angle + "deg)";
      }
      this.reps.outline.style.width = "" + (Math.ceil(this.width * zl, 10)) + "px";
      this.reps.outline.style.height = "" + (Math.ceil(this.height * zl, 10)) + "px";
      tl.zoomed();
      this.reps.outline.style.left = "" + (Math.floor(tl.x, 10)) + "px";
      this.reps.outline.style.top = "" + (Math.floor(tl.y, 10)) + "px";
      this.reps.outline.style.WebkitTransform = "rotate(" + this.angle + "deg)";
      this.reps.outline.style.MozTransform = "rotate(" + this.angle + "deg)";
      this.reps.c.style.left = "" + (Math.ceil(center.x, 10)) + "px";
      this.reps.c.style.top = "" + (Math.ceil(center.y, 10)) + "px";
      return this;
    },
    correctAngle: function(p) {
      return p.clone().rotate(360 - this.angle, this.center());
    },
    drag: function(e) {
      var center, change, cursor, direction, opposites, origin, origins, x, y;
      change = {
        x: 0,
        y: 0
      };
      center = this.center();
      cursor = e.canvasPosnZoomed.clone().rotate(360 - this.angle, center);
      direction = e.target.className.replace('transform handle ', '').split(' ')[1];
      origins = {
        tl: this.br,
        tr: this.bl,
        br: this.tl,
        bl: this.tr,
        top: this.bc,
        right: this.lc,
        bottom: this.tc,
        left: this.rc
      };
      origin = origins[direction];
      if (["tr", "right", "br"].has(direction)) {
        change.x = cursor.x - this.correctAngle(this.rc).x;
      }
      if (["tl", "left", "bl"].has(direction)) {
        change.x = this.correctAngle(this.lc).x - cursor.x;
      }
      if (["tl", "top", "tr"].has(direction)) {
        change.y = this.correctAngle(this.tc).y - cursor.y;
      }
      if (["bl", "bottom", "br"].has(direction)) {
        change.y = cursor.y - this.correctAngle(this.bc).y;
      }
      x = this.pixelToFloat(change.x, this.width);
      y = this.pixelToFloat(change.y, this.height);
      if (x < 0) {
        opposites = {
          tl: this.reps.tr,
          tr: this.reps.tl,
          br: this.reps.bl,
          bl: this.reps.br,
          top: this.reps.bc,
          right: this.reps.lc,
          bottom: this.reps.tc,
          left: this.reps.rc
        };
        ui.cursor.lastDownTarget = opposites[direction];
        switch (direction) {
          case "left":
          case "bl":
          case "tl":
            return this._flipOver("R");
          case "right":
          case "br":
          case "tr":
            return this._flipOver("L");
        }
      }
      if (y < 0) {
        opposites = {
          tl: this.reps.bl,
          tr: this.reps.br,
          br: this.reps.tr,
          bl: this.reps.tl,
          top: this.reps.bc,
          right: this.reps.lc,
          bottom: this.reps.tc,
          left: this.reps.rc
        };
        ui.cursor.lastDownTarget = opposites[direction];
        switch (direction) {
          case "bottom":
          case "bl":
          case "br":
            return this._flipOver("T");
          case "top":
          case "tl":
          case "tr":
            return this._flipOver("B");
        }
      }
      if (ui.hotkeys.modifiersDown.has("shift")) {
        if (direction[0] === "side") {
          if (x === 1) {
            x = y;
          } else if (y === 1) {
            y = x;
          }
        }
        if (x < y) {
          y = x;
        } else {
          x = y;
        }
      }
      if (ui.hotkeys.modifiersDown.has("alt")) {
        origin = center;
        x = x * x;
        y = y * y;
      }
      x = x.ensureRealNumber();
      y = y.ensureRealNumber();
      x = Math.max(1e-5, x);
      y = Math.max(1e-5, y);
      this.scale(x, y, origin);
      this.redraw();
      return ui.selection.scale(x, y, origin);
    },
    clonedPosns: function() {
      return [this.tl, this.tc, this.tr, this.rc, this.br, this.bc, this.bl, this.lc].map(function(p) {
        return p.clone();
      });
    },
    _flipOver: function(side) {
      var bc, bl, br, lc, rc, tc, tl, tr, _ref3;
      _ref3 = this.clonedPosns(), tl = _ref3[0], tc = _ref3[1], tr = _ref3[2], rc = _ref3[3], br = _ref3[4], bc = _ref3[5], bl = _ref3[6], lc = _ref3[7];
      switch (side) {
        case "T":
          this.tl = this.bl.reflect(tl);
          this.tc = this.bc.reflect(tc);
          this.tr = this.br.reflect(tr);
          this.rc = this.rc.reflect(tr);
          this.lc = this.lc.reflect(tl);
          this.bc = tc;
          this.bl = tl;
          this.br = tr;
          ui.selection.scale(1, -1, this.bc);
          break;
        case "B":
          this.bl = this.tl.reflect(bl);
          this.bc = this.tc.reflect(bc);
          this.br = this.tr.reflect(br);
          this.rc = this.rc.reflect(br);
          this.lc = this.lc.reflect(bl);
          this.tc = bc;
          this.tl = bl;
          this.tr = br;
          ui.selection.scale(1, -1, this.tc);
          break;
        case "L":
          this.tl = this.tr.reflect(tl);
          this.lc = this.rc.reflect(lc);
          this.bl = this.br.reflect(bl);
          this.tc = this.tc.reflect(tl);
          this.bc = this.bc.reflect(bl);
          this.rc = lc;
          this.br = bl;
          this.tr = tl;
          ui.selection.scale(-1, 1, this.rc);
          break;
        case "R":
          this.tr = this.tl.reflect(tr);
          this.rc = this.lc.reflect(rc);
          this.br = this.bl.reflect(br);
          this.tc = this.tc.reflect(tr);
          this.bc = this.bc.reflect(br);
          this.lc = rc;
          this.bl = br;
          this.tl = tr;
          ui.selection.scale(-1, 1, this.lc);
      }
      return this.redraw();
    },
    flipOriginHorizontally: function(o) {
      switch (o) {
        case this.tl:
          return this.tr;
        case this.tr:
          return this.tl;
        case this.br:
          return this.bl;
        case this.bl:
          return this.br;
        case this.rc:
          return this.lc;
        case this.lc:
          return this.rc;
      }
    },
    flipOriginVertically: function(o) {
      switch (o) {
        case this.tl:
          return this.tr;
        case this.tr:
          return this.tl;
        case this.br:
          return this.bl;
        case this.bl:
          return this.br;
        case this.rc:
          return this.lc;
        case this.lc:
          return this.rc;
      }
    },
    scale: function(x, y, origin) {
      var center, p, _i, _len, _ref3;
      this.origin = origin;
      center = this.center();
      _ref3 = this.pointsToScale(this.origin);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        if (this.angle !== 0) {
          p.rotate(360 - this.angle, center);
        }
        p.scale(x, y, this.origin.clone().rotate(360 - this.angle, center));
        if (this.angle !== 0) {
          p.rotate(this.angle, center);
        }
      }
      this;
      this.width *= x;
      this.height *= y;
      if (this.width === 0) {
        this.width = 1;
      }
      if (this.height === 0) {
        this.height = 1;
      }
      this.accumX *= x;
      this.accumY *= y;
      return this;
    },
    pointsToScale: function(origin) {
      switch (origin) {
        case this.tc:
          return [this.bl, this.bc, this.br, this.rc, this.lc];
        case this.rc:
          return [this.bl, this.lc, this.tl, this.tc, this.bc];
        case this.bc:
          return [this.tl, this.tc, this.tr, this.rc, this.lc];
        case this.lc:
          return [this.br, this.rc, this.tr, this.bc, this.tc];
        case this.tl:
          return [this.tr, this.br, this.bl, this.tc, this.rc, this.bc, this.lc];
        case this.tr:
          return [this.tl, this.br, this.bl, this.tc, this.rc, this.bc, this.lc];
        case this.br:
          return [this.tl, this.tr, this.bl, this.tc, this.rc, this.bc, this.lc];
        case this.bl:
          return [this.tl, this.tr, this.br, this.tc, this.rc, this.bc, this.lc];
        default:
          return [this.tl, this.tr, this.br, this.bl, this.tc, this.rc, this.bc, this.lc];
      }
    },
    nudge: function(x, y) {
      var p, _i, _len, _ref3;
      _ref3 = [this.tl, this.tr, this.br, this.bl, this.tc, this.rc, this.bc, this.lc];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        p.nudge(x, -y);
      }
      return this;
    },
    rotate: function(a, origin) {
      var p, _i, _len, _ref3;
      this.origin = origin;
      this.angle += a;
      this.angle %= 360;
      this.accumA += a;
      this.accumA %= 360;
      _ref3 = [this.tl, this.tr, this.br, this.bl, this.tc, this.rc, this.bc, this.lc];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        p.rotate(a, this.origin);
      }
      return this;
    },
    setup: function() {
      this.resetAccum();
      return this.reps = {
        tl: q("#trfm-tl"),
        tr: q("#trfm-tr"),
        br: q("#trfm-br"),
        bl: q("#trfm-bl"),
        tc: q("#trfm-tc"),
        rc: q("#trfm-rc"),
        bc: q("#trfm-bc"),
        lc: q("#trfm-lc"),
        c: q("#trfm-c"),
        outline: q("#trfm-outline")
      };
    },
    tl: new Posn(0, 0),
    tr: new Posn(0, 0),
    br: new Posn(0, 0),
    bl: new Posn(0, 0),
    tc: new Posn(0, 0),
    rc: new Posn(0, 0),
    bc: new Posn(0, 0),
    lc: new Posn(0, 0),
    onRotatingMode: function() {
      return $(this.reps.c).hide();
    },
    offRotatingMode: function() {
      if (ui.selection.elements.all.length === 0) {
        return;
      }
      return $(this.reps.c).show();
    }
  };

  setup.push(function() {
    return ui.transformer.setup();
  });

  /*
  
    Mondrian.io hotkeys management
  
    This has to be way more fucking complicated than it should.
    Problems:
      â€¢ Holding down CMD on Mac mutes all successive keyups.
      â€¢ Pushing down key A and key B, then releasing key B, ceases to register key A continuing to be pressed
        so this uses a simulated keypress interval to get around that by storing all keys that are pressed
        and while there are any, executing them all on a 100 ms interval. It feels native, but isn't.
  */


  ui.hotkeys = {
    sets: {
      root: {
        context: ui,
        down: {
          'cmd-S': function(e) {
            e.preventDefault();
            return this.file.save();
          },
          'cmd-N': function(e) {
            e.preventDefault();
            return console.log("new");
          },
          'cmd-O': function(e) {
            e.preventDefault();
            if (this.file.service != null) {
              return this.file.service.open();
            }
          }
        },
        up: {}
      },
      app: {
        context: ui,
        ignoreAllOthers: false,
        down: {
          'V': function(e) {
            return this.switchToTool(tools.cursor);
          },
          'P': function(e) {
            return this.switchToTool(tools.pen);
          },
          'C': function(e) {
            return this.switchToTool(tools.crayon);
          },
          '\\': function(e) {
            return this.switchToTool(tools.line);
          },
          'L': function(e) {
            return this.switchToTool(tools.ellipse);
          },
          'T': function(e) {
            return this.switchToTool(tools.type);
          },
          'M': function(e) {
            return this.switchToTool(tools.rectangle);
          },
          'R': function(e) {
            return this.switchToTool(tools.rotate);
          },
          'Z': function(e) {
            return this.switchToTool(tools.zoom);
          },
          'I': function(e) {
            return this.switchToTool(tools.eyedropper);
          },
          'space': function(e) {
            e.preventDefault();
            return this.switchToTool(tools.paw);
          },
          'shift-X': function() {
            var f;
            f = ui.fill.clone();
            ui.fill.absorb(ui.stroke);
            return ui.stroke.absorb(f);
          },
          'cmd-.': function(e) {
            e.preventDefault();
            ui.selection.elements.ofType('text').map(function(t) {
              t.data['font-size'] += 1;
              return t.commit();
            });
            return ui.transformer.refresh();
          },
          'cmd-shift-.': function(e) {
            e.preventDefault();
            ui.selection.elements.ofType('text').map(function(t) {
              t.data['font-size'] += 10;
              return t.commit();
            });
            return ui.transformer.refresh();
          },
          'cmd-,': function(e) {
            e.preventDefault();
            ui.selection.elements.ofType('text').map(function(t) {
              t.data['font-size'] -= 1;
              return t.commit();
            });
            return ui.transformer.refresh();
          },
          'cmd-shift-,': function(e) {
            e.preventDefault();
            ui.selection.elements.ofType('text').map(function(t) {
              t.data['font-size'] -= 10;
              return t.commit();
            });
            return ui.transformer.refresh();
          },
          'cmd-F': function(e) {
            return e.preventDefault();
          },
          'U': function(e) {
            e.preventDefault();
            return pathfinder.merge(this.selection.elements.all);
          },
          'cmd-D': function(e) {
            return e.preventDefault();
          },
          'cmd-S': function(e) {
            e.preventDefault();
            return ui.file.save();
          },
          'ctrl-L': function() {
            return ui.annotations.clear();
          },
          'leftArrow': function() {
            return this.selection.nudge(-1, 0);
          },
          'rightArrow': function() {
            return this.selection.nudge(1, 0);
          },
          'upArrow': function() {
            return this.selection.nudge(0, 1);
          },
          'downArrow': function() {
            return this.selection.nudge(0, -1);
          },
          'shift-leftArrow': function() {
            return this.selection.nudge(-10, 0);
          },
          'shift-rightArrow': function() {
            return this.selection.nudge(10, 0);
          },
          'shift-upArrow': function() {
            return this.selection.nudge(0, 10);
          },
          'shift-downArrow': function() {
            return this.selection.nudge(0, -10);
          }
        },
        up: {
          'space': function() {
            return this.switchToLastTool();
          },
          '+': function() {
            return this.refreshAfterZoom();
          },
          '-': function() {
            return this.refreshAfterZoom();
          }
        }
      }
    },
    use: function(set) {
      var key, val, _ref3;
      if (typeof set === "string") {
        this.using = this.sets[set];
      } else if (typeof set === "object") {
        this.using = set;
      }
      _ref3 = this.sets.root.down;
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        val = _ref3[key];
        if (this.using.down[key] == null) {
          this.using.down[key] = val;
        }
      }
      return this.enable();
    },
    reset: function() {
      this.lastKeystroke = '';
      this.modifiersDown = [];
      return this.keysDown = [];
    },
    disable: function() {
      if (this.using === this.sets.app) {
        this.disabled = true;
      }
      return this;
    },
    enable: function() {
      this.disabled = false;
      this.cmdDown = false;
      return this;
    },
    modifiersDown: [],
    registerModifier: function(modifier) {
      if (!this.modifiersDown.has(modifier)) {
        this.modifiersDown.push(modifier);
        return ui.uistate.get('tool').activateModifier(modifier);
      }
    },
    registerModifierUp: function(modifier) {
      if (this.modifiersDown.has(modifier)) {
        this.modifiersDown = this.modifiersDown.remove(modifier);
        return ui.uistate.get('tool').deactivateModifier(modifier);
      }
    },
    keysDown: [],
    cmdDown: false,
    simulatedKeypressInterval: null,
    beginSimulatedKeypressTimeout: null,
    keypressIntervals: [],
    lastKeystroke: '',
    lastEvent: {},
    /*
      Strategy:
    
      Basically, don't persist keystrokes repeatedly if CMD is down. While CMD is down,
      anything else that happens just happens once and that's it.
    
      So CMD + A + C will select all and copy once, even is C is held down forever.
      Holding down Shift + LefArrow however will repeatedly nudge the selection left 10px.
    
      So we save all modifiers being held down, and loop all keys unless CMD is down.
    */

    setup: function() {
      var _this = this;
      this.use("app");
      ui.window.on('focus', function() {
        _this.modifiersDown = [];
        return _this.keysDown = [];
      });
      return $(document).on('keydown', function(e) {
        var character, chars, fullKeystroke, key, keystroke, newStroke, _i, _len, _ref3, _ref4, _ref5, _ref6, _ref7;
        if (isDefaultQuarantined(e.target)) {
          if (!e.target.hasAttribute("h")) {
            return true;
          }
        }
        ui.afk.reset();
        if (_this.disabled) {
          return true;
        }
        keystroke = _this.parseKeystroke(e);
        if (keystroke === null) {
          return false;
        }
        _this.lastEvent = e;
        if (!e.metaKey) {
          _this.cmdDown = false;
          _this.registerModifierUp("cmd");
        } else {
          _this.registerModifier("cmd");
        }
        if (keystroke === 'cmd') {
          if (!_this.cmdDown) {
            _this.cmdDown = true;
            _this.registerModifier("cmd");
          }
          return;
        } else if (keystroke === 'shift' || keystroke === 'alt' || keystroke === 'ctrl') {
          _this.registerModifier(keystroke);
          _ref3 = _this.keysDown;
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            key = _ref3[_i];
            if ((_ref4 = _this.using.up) != null) {
              if ((_ref5 = _ref4[_this.fullKeystroke(key, "")]) != null) {
                _ref5.call(_this.using.context, e);
              }
            }
          }
          return;
        } else {
          if (!_this.keysDown.has(keystroke)) {
            newStroke = true;
            _this.keysDown.push(keystroke);
          } else {
            newStroke = false;
          }
        }
        if (_this.using == null) {
          _this.use("app");
        }
        fullKeystroke = _this.fullKeystroke(keystroke);
        if (fullKeystroke === "cmd-O") {
          e.preventDefault();
        }
        if ((((_ref6 = _this.using.down) != null ? _ref6[fullKeystroke] : void 0) != null) || (((_ref7 = _this.using.up) != null ? _ref7[fullKeystroke] : void 0) != null)) {
          if (_this.keypressIntervals.length === 0) {
            _this.simulatedKeypress();
            _this.keypressIntervals = [];
            if (_this.cmdDown) {
              return;
            }
            _this.keypressIntervals = [0];
            if (_this.beginSimulatedKeypressTimeout != null) {
              clearTimeout(_this.beginSimulatedKeypressTimeout);
            }
            return _this.beginSimulatedKeypressTimeout = setTimeout(function() {
              return _this.keypressIntervals.push(setInterval((function() {
                return _this.simulatedKeypress();
              }), 100));
            }, 350);
          } else if (_this.keypressIntervals.length > 0) {
            /*
              Allow new single key presses while the interval is getting set up.
              (This becomes obvious when you try nudging an element diagonally
              with upArrow + leftArrow, for example)
            */

            if (newStroke) {
              _this.simulatedKeypress();
            }
            return false;
          } else {
            return false;
          }
        } else {
          if (_this.using.ignoreAllOthers) {
            return false;
          } else {
            if ((_this.using.blacklist != null) && _this.using.blacklist !== null) {
              chars = _this.using.blacklist;
              character = fullKeystroke;
              if (character.match(chars)) {
                if (_this.using.inheritFromApp.has(character)) {
                  _this.sets.app.down[character].call(ui);
                  _this.using.context.$rep.blur();
                  _this.use("app");
                }
                return false;
              } else {
                return true;
              }
            }
          }
        }
      }).on('keyup', function(e) {
        var action, hotkey, key, keystroke, _i, _len, _ref10, _ref11, _ref12, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        if (_this.disabled) {
          return true;
        }
        keystroke = _this.parseKeystroke(e);
        if (_this.keysDown.length === 1) {
          _this.clearAllIntervals();
        }
        if (keystroke === null) {
          return false;
        }
        if ((_ref3 = _this.using.up) != null) {
          if ((_ref4 = _ref3[keystroke]) != null) {
            _ref4.call(_this.using.context, e);
          }
        }
        if (_this.modifiersDown.length > 0) {
          if ((_ref5 = _this.using.up) != null) {
            if ((_ref6 = _ref5[_this.fullKeystroke(keystroke)]) != null) {
              _ref6.call(_this.using.context, e);
            }
          }
        }
        if (_this.isModifier(keystroke)) {
          _ref7 = _this.keysDown;
          for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
            key = _ref7[_i];
            if ((_ref8 = _this.using.up) != null) {
              if ((_ref9 = _ref8[_this.fullKeystroke(key, keystroke)]) != null) {
                _ref9.call(_this.using.context, e);
              }
            }
          }
        }
        if ((_ref10 = _this.using.up) != null) {
          if ((_ref11 = _ref10.always) != null) {
            _ref11.call(_this.using.context, _this.lastEvent);
          }
        }
        if (keystroke === 'cmd') {
          _this.modifiersDown = _this.modifiersDown.remove('cmd');
          ui.uistate.get('tool').deactivateModifier('cmd');
          _this.keysDown = [];
          _this.cmdDown = false;
          _ref12 = _this.using.up;
          for (hotkey in _ref12) {
            if (!__hasProp.call(_ref12, hotkey)) continue;
            action = _ref12[hotkey];
            if (hotkey.mentions("cmd")) {
              action.call(_this.using.context, e);
            }
          }
          _this.lastKeystroke = '';
          return _this.maintainInterval();
        } else if (keystroke === 'shift' || keystroke === 'alt' || keystroke === 'ctrl') {
          _this.modifiersDown = _this.modifiersDown.remove(keystroke);
          ui.uistate.get('tool').deactivateModifier(keystroke);
          return _this.maintainInterval();
        } else {
          _this.keysDown = _this.keysDown.remove(keystroke);
          return _this.maintainInterval();
        }
      });
    },
    clearAllIntervals: function() {
      var id, _i, _len, _ref3;
      _ref3 = this.keypressIntervals;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        id = _ref3[_i];
        clearInterval(id);
      }
      return this.keypressIntervals = [];
    },
    simulatedKeypress: function() {
      /*
        Since we delay the simulated keypress interval, often a key will be pushed and released before the interval starts,
        and the interval will start after and continue running in the background.
      
        If it's running invalidly, it won't be obvious because no keys will be down so nothing
        will happen, but we don't want an empty loop running in the background for god knows
        how long and eating up resources.
      
        This prevents that from happening by ALWAYS checking that this simulated press is valid
        and KILLING IT IMMEDIATELY if not.
      */

      var fullKeystroke, key, _i, _len, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
      this.maintainInterval();
      if (this.keysDown.length === 0) {
        return;
      }
      _ref3 = this.keysDown;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        key = _ref3[_i];
        fullKeystroke = this.fullKeystroke(key);
        if (this.cmdDown) {
          if (this.lastKeystroke === fullKeystroke) {
            4;
          }
        }
        if (((_ref4 = this.using.down) != null ? _ref4[fullKeystroke] : void 0) != null) {
          if ((_ref5 = this.using.down) != null) {
            _ref5[fullKeystroke].call(this.using.context, this.lastEvent);
          }
          this.lastKeystroke = fullKeystroke;
        }
        _results.push((_ref6 = this.using.down) != null ? (_ref7 = _ref6.always) != null ? _ref7.call(this.using.context, this.lastEvent) : void 0 : void 0);
      }
      return _results;
    },
    maintainInterval: function() {
      if (this.keysDown.length === 0) {
        return this.clearAllIntervals();
      }
    },
    isModifier: function(key) {
      switch (key) {
        case "shift":
        case "cmd":
        case "alt":
          return true;
        default:
          return false;
      }
    },
    parseKeystroke: function(e) {
      var accepted, keystroke, modifiers, remaps;
      modifiers = {
        8: 'backspace',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        91: 'cmd',
        92: 'cmd',
        224: 'cmd'
      };
      if (modifiers[e.which] != null) {
        return modifiers[e.which];
      }
      accepted = [new Range(9, 9), new Range(13, 13), new Range(65, 90), new Range(32, 32), new Range(37, 40), new Range(48, 57), new Range(187, 190), new Range(219, 222)];
      if (accepted.map(function(x) {
        return x.containsInclusive(e.which);
      }).filter(function(x) {
        return x === true;
      }).length === 0) {
        return null;
      }
      remaps = {
        13: 'enter',
        32: 'space',
        37: 'leftArrow',
        38: 'upArrow',
        39: 'rightArrow',
        40: 'downArrow',
        187: '+',
        188: ',',
        189: '-',
        190: '.',
        219: '[',
        220: '\\',
        221: ']',
        222: "'"
      };
      keystroke = remaps[e.which] || String.fromCharCode(e.which);
      return keystroke;
    },
    fullKeystroke: function(key, mods) {
      if (mods == null) {
        mods = this.modifiersPrefix();
      }
      return "" + mods + (mods.length > 0 ? '-' : '') + key;
    },
    /*
      Returns a string line 'cmd-shift-' or 'alt-cmd-shift-' or 'shift-'
      Always in ALPHABETICAL order. Modifier prefix order must match that of hotkey of the hotkey won't work.
      This is done so we can compare single strings and not arrays or strings, which is faster.
    */

    modifiersPrefix: function() {
      var mods;
      mods = this.modifiersDown.sort().join('-');
      if (/Win/.test(navigator.platform)) {
        mods = mods.replace('ctrl', 'cmd');
      }
      return mods;
    }
  };

  setup.push(function() {
    return ui.hotkeys.setup();
  });

  /*
  
    File Gallery
  
    Plugs into Dropbox to showcase SVG files available for editing lets user open any by clicking it.
    Made to be able to plug into any other service later on given a standard, simple API. :)
  */


  ui.gallery = {
    service: void 0,
    open: function(service) {
      var $loadingIndicator, serviceNames,
        _this = this;
      this.service = service;
      ui.changeTo("gallery");
      $('.service-logo').attr("class", "service-logo " + (this.service.name.toLowerCase()));
      $(".file-listing").css("opacity", "1.0");
      $('#service-search-input').attr('placeholder', 'Search for files');
      $('#cancel-open-file').one('click', function() {
        ui.clear();
        ui.file.load();
        return ui.changeTo("draw");
      });
      $loadingIndicator = dom.$serviceGallery.find('.loading');
      serviceNames = ui.account.services.map(function(s) {
        return services[s].name;
      });
      $loadingIndicator.text("Connecting to " + (serviceNames.join(', ')) + "...").show();
      dom.$serviceGalleryThumbs.empty();
      return async(function() {
        var _i, _len, _ref3, _results;
        _ref3 = ui.account.services;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          service = _ref3[_i];
          _results.push(services[service].getSVGs(function(response) {
            $loadingIndicator.hide();
            dom.$currentService.find('input:text').val("").focus();
            $('#service-file-gallery-message').text("" + response.length + " SVG files found");
            if (response.length > 0) {
              return _this.draw(response);
            }
          }));
        }
        return _results;
      });
    },
    choose: function($fileListing) {
      var $file, file, key, name, path, service, _i, _len, _ref3, _results;
      path = $fileListing.attr("path");
      name = $fileListing.attr("name");
      key = $fileListing.attr("key");
      service = $fileListing.attr("service");
      ui.clear();
      new File().fromService(services[service])(key).use(true);
      ui.changeTo("draw");
      _ref3 = $(".file-listing");
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        file = _ref3[_i];
        $file = $(file);
        if (($file.attr("name") !== name) || ($file.attr("path") !== path)) {
          _results.push($file.css("opacity", 0.2).unbind("click"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    draw: function(response) {
      var $fileListing, file, _i, _len;
      ui.canvas.setZoom(1.0);
      for (_i = 0, _len = response.length; _i < _len; _i++) {
        file = response[_i];
        $fileListing = this.fileListing(file);
        dom.$serviceGalleryThumbs.append($fileListing);
        $fileListing.one("click", function() {
          return ui.gallery.choose($(this));
        });
      }
      return this.drawThumbnails(response[0], response.slice(1));
    },
    drawThumbnails: function(hd, tl) {
      var $thumb, img,
        _this = this;
      $thumb = $(".file-listing[key=\"" + hd.key + "\"] .file-thumbnail-img");
      if (hd.thumbnail != null) {
        img = new Image();
        img.onload = function() {
          return _this.appendThumbnail(hd.thumbnail, $thumb);
        };
        img.src = hd.thumbnail;
      } else {
        hd.service.get("" + hd.path + hd.name, function(response) {
          var bounds, contents, dimen, png, shit;
          contents = response.contents;
          shit = dom.$main.children().length;
          bounds = io.getBounds(contents);
          dimen = bounds.fitTo(new Bounds(0, 0, 260, 260));
          png = io.makePNGURI(contents, 260);
          if (dom.$main.children().length !== shit) {
            debugger;
          }
          _this.appendThumbnail(png, $thumb, dimen);
          if (hd.service !== services.local) {
            return $.ajax({
              url: "" + SETTINGS.MEOWSET.ENDPOINT + "/files/thumbnails/put",
              type: "POST",
              data: {
                session_token: ui.account.session_token,
                full_path: "" + hd.path + hd.name,
                last_modified: "" + hd.modified,
                content: png
              }
            });
          }
        });
      }
      if (tl.length > 0) {
        return this.drawThumbnails(tl[0], tl.slice(1));
      }
    },
    fileListing: function(file) {
      var $l;
      return $l = $("<div class=\"file-listing\" service=\"" + (file.service.name.toLowerCase()) + "\" path=\"" + file.path + "\" name=\"" + file.name + "\" key=\"" + file.key + "\" quarantine>\n  <div class=\"file-thumbnail\">\n    <div class=\"file-thumbnail-img\"></div>\n  </div>\n  <div class=\"file-name\">" + file.name + "</div>\n  <div class=\"file-path\">in " + file.displayLocation + "</div>\n</div>");
    },
    appendThumbnail: function(png, $thumb, dimen) {
      var img;
      img = new Image();
      img.onload = function() {
        var $img;
        $thumb.append(this);
        $img = $(img);
        return img.style.margin = "" + ((300 - $img.height()) / 2) + "px " + ((300 - $img.width()) / 2) + "px";
      };
      return img.src = png;
    }
  };

  setup.push(function() {
    return $("#service-search-input").on("keyup.gs", function(e) {
      var $self, val;
      $self = $(this);
      val = $self.val().toLowerCase();
      if (val === "") {
        return $(".file-listing").show();
      } else {
        return $(".file-listing").each(function() {
          var $fl, key, name, path;
          $fl = $(this);
          path = $fl.attr("path");
          name = $fl.attr("name");
          key = $fl.attr("key");
          if (name.toLowerCase().indexOf(val) > -1) {
            return $fl.show();
          } else {
            return $fl.hide();
          }
        });
      }
    });
  });

  /*
  
    File location browser/chooser
    Used for Save as
  */


  ui.browser = {
    service: void 0,
    saveToPath: '/',
    open: function(service) {
      var $loadingIndicator, $so, _i, _len, _ref3,
        _this = this;
      this.service = service;
      this.saveToPath = '/';
      $so = dom.$serviceBrowser.find("#service-options");
      $so.empty();
      this.removeDirectoryColumnsAfter(1);
      _ref3 = ui.account.services;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        service = _ref3[_i];
        $so.append(this.serviceButton(service));
      }
      ui.changeTo("browser");
      $('#current-file-saving-name-input').val(ui.file.name.replace(".svg", "")).fitToVal(20);
      $('#service-search-input').attr('placeholder', 'Search for folder');
      $('#cancel-save-file').unbind('click').on('click', function() {
        return ui.changeTo("draw");
      });
      $('#confirm-save-file').unbind('click').on('click', function() {
        return _this.save();
      });
      $loadingIndicator = dom.$serviceBrowser.find('.loading');
      $loadingIndicator.hide();
      if (this.service != null) {
        $so.addClass("has-selection");
        $so.find("." + this.service.name).addClass("selected");
        $('.service-logo').attr("class", "service-logo " + (this.service.name.toLowerCase()));
        $loadingIndicator.text("Conecting to " + this.service.name + "...").show();
        return this.addDirectoryColumn("/", 1, function() {
          return $loadingIndicator.hide();
        });
      }
    },
    save: function() {
      var fn,
        _this = this;
      fn = "" + ($("#current-file-saving-name-input").val()) + ".svg";
      ui.changeTo("draw");
      return this.service.put("" + this.saveToPath + fn, io.makeFile(), function(response) {
        debugger;
        return new File().fromService(_this.service)(fn).use();
      });
    },
    addDirectoryColumn: function(path, index, success) {
      var _this = this;
      if (success == null) {
        success = function() {};
      }
      this.removeDirectoryColumnsAfter(index);
      return this.service.getSaveLocations(path, function(folders, files) {
        success();
        return $("#browser-directory").append(_this.directoryColumn(folders, files, index));
      });
    },
    recursivePreload: function(folders) {
      var _this = this;
      return this.service.getSaveLocations(folders[0].path, function() {
        if (folders.length > 1) {
          return _this.recursivePreload(folders.slice(1));
        }
      });
    },
    removeDirectoryColumnsAfter: function(index) {
      return $(".scrollbar-screen-directory-col").each(function() {
        var $self;
        $self = $(this);
        if (parseInt($self.attr("index"), 10) >= index) {
          return $self.remove();
        }
      });
    },
    directoryColumn: function(directories, files, index) {
      var $col, $colContainer, dir, file, _i, _j, _len, _len1;
      $colContainer = $("<div class=\"scrollbar-screen-directory-col\" index=\"" + index + "\">\n  <div class=\"directory-col\"></div>\n</div>").css({
        left: "" + (201 * index) + "px"
      });
      $col = $colContainer.find('.directory-col');
      if (directories.length > 0) {
        $col.append($("<div folders></div>"));
        for (_i = 0, _len = directories.length; _i < _len; _i++) {
          dir = directories[_i];
          $col.find("[folders]").append(this.directoryButton(dir.path, dir.path.match(/\/[^\/]*$/)[0].substring(1), index));
        }
      }
      if (files.length > 0) {
        $col.append($("<div files></div>"));
        for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
          file = files[_j];
          $col.find("[files]").append(this.fileButton(file.path, file.path.match(/\/[^\/]*$/)[0].substring(1), index));
        }
      }
      return $colContainer;
    },
    directoryButton: function(path, name, index) {
      return $("<div class=\"directory-button\">" + name + "</div>").on("click", function() {
        var $self;
        $self = $(this);
        if (!$self.hasClass("selected")) {
          ui.browser.saveToPath = "" + path + "/";
          ui.browser.addDirectoryColumn("" + path, index + 1);
          $("#current-file-saving-directory-path").text("" + path + "/");
          $self.parent().parent().find('.directory-button').removeClass('selected');
          return $self.addClass("selected").parent().parent().addClass("has-selection");
        } else {
          $self.removeClass("selected").parent().parent().removeClass("has-selection");
          return ui.browser.removeDirectoryColumnsAfter(index + 1);
        }
      });
    },
    fileButton: function(path, name, index) {
      return $("<div class=\"file-button\">" + name + "</div>").on("click", function() {
        return $('#current-file-saving-name-input').val(name.replace(".svg", "")).trigger("keyup");
      });
    },
    serviceButton: function(name) {
      var _this = this;
      return $("<div class=\"service-button " + name + "\">" + (name[0].toUpperCase() + name.substring(1)) + " </div>").on("click", function() {
        return _this.open(services[name]);
      });
    }
  };

  /*
  
    UI Control
  
    A superclass for custom input controls such as smart text boxes and sliders.
  */


  Control = (function() {
    function Control(attrs) {
      var key, val,
        _this = this;
      for (key in attrs) {
        val = attrs[key];
        this[key] = val;
      }
      this;
      this.$rep = $(this.rep);
      this.$rep.bind("focus", function() {
        return _this.focus();
      });
      this.$rep.bind("blur", function() {
        return _this.blur();
      });
      this.$rep.bind("read", function(callback) {
        return callback(_this.read());
      });
      this.$rep.bind("set", function(value) {
        return _this.set(value);
      });
      this.commitFunc = attrs.commit;
      this.commit = function() {
        return this.commitFunc(this.read());
      };
    }

    Control.prototype.focused = false;

    Control.prototype.value = null;

    Control.prototype.valueWhenFocused = void 0;

    Control.prototype.appendTo = function(selector) {
      return q(selector).appendChild(this.rep);
    };

    Control.prototype.focus = function() {
      var _ref3;
      if ((_ref3 = ui.controlFocused) != null) {
        _ref3.blur();
      }
      this.valueWhenFocused = this.read();
      this.focused = true;
      ui.controlFocused = this;
      return ui.hotkeys.use(this.hotkeys);
    };

    Control.prototype.blur = function() {
      ui.controlFocused = void 0;
      this.focused = false;
      if (this.read() !== this.valueWhenFocused) {
        return this.commit();
      }
    };

    Control.prototype.update = function() {
      return this.rep.setAttribute("value", this.value);
    };

    Control.prototype.commit = function() {};

    Control.prototype.build = function() {};

    Control.prototype.read = function() {};

    Control.prototype.write = function(value) {};

    Control.prototype.set = function(value) {
      this.value = value;
      this.write(this.value);
      return this.update();
    };

    Control.prototype.hotkeys = {};

    return Control;

  })();

  /*
  
    Dropdown control
  */


  Dropdown = (function(_super) {
    __extends(Dropdown, _super);

    function Dropdown(attrs) {
      var _this = this;
      Dropdown.__super__.constructor.call(this, attrs);
      this.$chosen = this.$rep.find('.dropdown-chosen');
      this.$list = this.$rep.find('.dropdown-list');
      this.options.map(function(o) {
        return _this.$list.append(o.$rep);
      });
      if (attrs["default"] != null) {
        this.$chosen.empty().append();
      }
      this.select(this.options[0]);
      this.close();
      this.$chosen.click(function() {
        return _this.toggle();
      });
    }

    Dropdown.prototype.select = function(selected) {
      this.selected = selected;
      this.$chosen.children().first().appendTo(this.$list);
      this.$chosen.append(this.selected.$rep);
      this.refreshListeners();
      return this.callback(this.selected.val);
    };

    Dropdown.prototype.opened = false;

    Dropdown.prototype.open = function() {
      this.$list.find('div').tsort();
      this.opened = true;
      this.$list.show();
      return this.refreshListeners();
    };

    Dropdown.prototype.close = function() {
      this.opened = false;
      return this.$list.hide();
    };

    Dropdown.prototype.refreshListeners = function() {
      var _this = this;
      this.$list.find('div').off('click');
      return this.$list.find('div').on('click', function(e) {
        _this.select(_this.getOption(e.target.innerHTML));
        return _this.close();
      });
    };

    Dropdown.prototype.toggle = function() {
      if (this.opened) {
        return this.close();
      } else {
        return this.open();
      }
    };

    Dropdown.prototype.getOption = function(value) {
      return this.options.filter(function(o) {
        return o.val === value;
      })[0];
    };

    return Dropdown;

  })(Control);

  DropdownOption = (function() {
    function DropdownOption(val) {
      this.val = val;
      this.$rep = $("<div class=\"dropdown-item\">" + this.val + "</div>");
    }

    return DropdownOption;

  })();

  FontFaceOption = (function(_super) {
    __extends(FontFaceOption, _super);

    function FontFaceOption(name) {
      this.name = name;
      FontFaceOption.__super__.constructor.apply(this, arguments);
      this.$rep.css({
        'font-family': this.name,
        'font-size': '14px'
      });
    }

    return FontFaceOption;

  })(DropdownOption);

  /*
  
    NumberBox
  
    _______________
    | 542.3402 px |
    ---------------
  
    An input:text that only accepts floats and can be adjusted with
    up/down arrows (alt/shift modifiers to change rate)
  */


  NumberBox = (function(_super) {
    __extends(NumberBox, _super);

    function NumberBox(attrs) {
      NumberBox.__super__.constructor.call(this, attrs);
      if (attrs.addVal != null) {
        this.addVal = attrs.addVal;
      } else {
        this.addVal = this._addVal;
      }
      this.rep.setAttribute("h", "");
      this.hotkeys = $.extend({
        context: this,
        down: {
          always: function(e) {
            return typeof this.onDown === "function" ? this.onDown(e, this.read()) : void 0;
          },
          enter: function(e) {
            this.write(this.read());
            this.commit();
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          upArrow: function(e) {
            return this.addVal(e, 1);
          },
          downArrow: function(e) {
            return this.addVal(e, -1);
          },
          "shift-upArrow": function(e) {
            return this.addVal(e, 10);
          },
          "shift-downArrow": function(e) {
            return this.addVal(e, -10);
          },
          "alt-upArrow": function(e) {
            return this.addVal(e, 0.1);
          },
          "alt-downArrow": function(e) {
            return this.addVal(e, -0.1);
          }
        },
        up: {
          upArrow: function(e) {
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          downArrow: function(e) {
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          "shift-upArrow": function(e) {
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          "shift-downArrow": function(e) {
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          "alt-upArrow": function(e) {
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          "alt-downArrow": function(e) {
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          },
          always: function(e) {
            return typeof this.onUp === "function" ? this.onUp(e, this.read()) : void 0;
          }
        },
        blacklist: /^[A-Z]$/gi,
        inheritFromApp: ['V', 'P', 'M', 'L', '\\', 'O', 'R']
      }, attrs.hotkeys);
    }

    NumberBox.prototype.read = function() {
      return parseFloat(this.$rep.val());
    };

    NumberBox.prototype.write = function(value) {
      this.value = value;
      if (this.places != null) {
        this.value = parseFloat(this.value).places(this.places);
      }
      if (this.max != null) {
        this.value = Math.min(this.max, this.value);
      }
      if (this.min != null) {
        this.value = Math.max(this.min, this.value);
      }
      return this.$rep.val(this.value);
    };

    NumberBox.prototype._addVal = function(e, amt) {
      var newVal, oldVal;
      e.preventDefault();
      oldVal = this.read();
      if (oldVal == null) {
        oldVal = 0;
      }
      newVal = this.read() + amt;
      this.write(newVal);
      return this.commit();
    };

    return NumberBox;

  })(Control);

  window.NumberBox = NumberBox;

  /*
  
    TestBox
  
    ___________
    | #FF0000 |
    -----------
  */


  TextBox = (function(_super) {
    __extends(TextBox, _super);

    function TextBox(attrs) {
      TextBox.__super__.constructor.call(this, attrs);
      this.rep.setAttribute("h", "");
      if (attrs.maxLength != null) {
        this.rep.setAttribute("maxLength", attrs.maxLength);
      }
      this.hotkeys = $.extend({
        context: this,
        down: {
          always: function(e) {
            return typeof this.onDown === "function" ? this.onDown(e, this.read()) : void 0;
          },
          enter: function(e) {
            this.write(this.read());
            this.commit();
            return typeof this.onDone === "function" ? this.onDone(e, this.read()) : void 0;
          }
        },
        up: {
          always: function(e) {
            return typeof this.onUp === "function" ? this.onUp(e, this.read()) : void 0;
          }
        },
        blacklist: null,
        inheritFromApp: ['V', 'P', 'M', 'L', '\\', 'O', 'R']
      }, attrs.hotkeys);
    }

    TextBox.prototype.read = function() {
      return this.$rep.val();
    };

    TextBox.prototype.write = function(value) {
      this.value = value;
      return this.$rep.val(this.value);
    };

    return TextBox;

  })(Control);

  window.TextBox = TextBox;

  Slider = (function(_super) {
    __extends(Slider, _super);

    function Slider(attrs) {
      var _this = this;
      Slider.__super__.constructor.call(this, attrs);
      this.hotkeys = {};
      this.$knob = this.$rep.find('.knob');
      this.$track = this.$rep.find('.track');
      if (this.valueTipFormatter != null) {
        this.$knob.append(this.$tip = $("<div class=\"slider tip\"></div>"));
      }
      this.knobWidth = this.$knob.width();
      this.trackMin = parseFloat(this.$track.css("left"));
      this.trackWidth = parseFloat(this.$track.css("width")) - this.knobWidth;
      this.trackMax = this.trackMin + this.trackWidth;
      this.$knob.on("nudge", function() {
        var _ref3;
        _this.commit();
        return (_ref3 = _this.$tip) != null ? _ref3.show().text(_this.valueTipFormatter(_this.read())) : void 0;
      }).on("stopDrag", function() {
        var _ref3;
        if (typeof _this.onRelease === "function") {
          _this.onRelease(_this.read());
        }
        return (_ref3 = _this.$tip) != null ? _ref3.hide() : void 0;
      }).attr("drag-x", "" + this.trackMin + " " + this.trackMax);
      this.set(0.0);
      this.$iconLeft = this.$rep.find(".left-icon");
      this.$iconRight = this.$rep.find(".right-icon");
      this.$knob.on("click", function(e) {
        return e.stopPropagation();
      });
      this.$iconLeft.on("click", function(e) {
        e.stopPropagation();
        _this.set(0.0);
        return _this.commit();
      });
      this.$iconRight.on("click", function(e) {
        e.stopPropagation();
        _this.set(1.0);
        return _this.commit();
      });
      this.$track = this.$rep.find(".track");
      this.$rep.on("release", function() {
        return typeof _this.onRelease === "function" ? _this.onRelease(_this.read()) : void 0;
      });
    }

    Slider.prototype.read = function() {
      return this.leftCSSToFloat(parseFloat(this.$knob.css("left")));
    };

    Slider.prototype.write = function(value) {
      return this.$knob.css("left", this.floatToLeftCSS(value));
    };

    Slider.prototype.floatToLeftCSS = function(value) {
      var l;
      value = Math.min(1.0, Math.max(0.0, value));
      if (this.inverse) {
        value = 1.0 - value;
      }
      return l = ((this.trackWidth * value) + this.trackMin).px();
    };

    Slider.prototype.leftCSSToFloat = function(left) {
      var f;
      f = (parseFloat(left) - this.trackMin) / this.trackWidth;
      if (this.inverse) {
        return 1.0 - f;
      } else {
        return f;
      }
    };

    return Slider;

  })(Control);

  /*
  
    Menubar, which manage MenuItems
  */


  ui.menu = {
    menus: {},
    items: {},
    menu: function(id) {
      return objectValues(this.menus).filter(function(menu) {
        return menu.itemid === id;
      })[0];
    },
    item: function(id) {
      return objectValues(this.items).filter(function(item) {
        return item.itemid === id;
      })[0];
    },
    closeAllDropdowns: function() {
      var item, k, _ref3, _results;
      _ref3 = this.menus;
      _results = [];
      for (k in _ref3) {
        if (!__hasProp.call(_ref3, k)) continue;
        item = _ref3[k];
        _results.push(item.closeDropdown());
      }
      return _results;
    },
    refresh: function() {
      var key, menu, _ref3, _results;
      _ref3 = this.menus;
      _results = [];
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        menu = _ref3[key];
        _results.push(menu.refresh());
      }
      return _results;
    }
  };

  /*
  
    MenuItem
  
    An item on the top program menu, like Open, Save... etc
    Template.
  */


  Menu = (function() {
    function Menu(attrs) {
      var i, x;
      for (i in attrs) {
        x = attrs[i];
        this[i] = x;
      }
      this.$rep = $("#" + this.itemid);
      this.rep = this.$rep[0];
      this.$dropdown = $("#" + this.itemid + "-dropdown");
      this.dropdown = this.$dropdown[0];
      this.dropdownSetup();
      if (this.onlineOnly) {
        this.bindOnlineListeners();
      }
    }

    Menu.prototype.refresh = function() {
      return this.items().map(function() {
        return this._refresh();
      });
    };

    Menu.prototype.refreshEnabledItems = function() {
      return this.items().map(function() {
        if (this.enableWhen != null) {
          if (this.enableWhen()) {
            return this.enable();
          } else {
            return this.disable();
          }
        }
      });
    };

    Menu.prototype.refreshAfterVisible = function() {
      return this.items().map(function() {
        return typeof this.refreshAfterVisible === "function" ? this.refreshAfterVisible() : void 0;
      });
    };

    Menu.prototype.items = function() {
      return this.$rep.find('.menu-item').map(function() {
        return ui.menu.item(this.id);
      });
    };

    Menu.prototype.disabled = false;

    Menu.prototype.dropdownOpen = false;

    Menu.prototype.bindOnlineListeners = function() {
      if (!navigator.onLine) {
        this.hide();
      }
      window.addEventListener("offline", this.hide.bind(this));
      return window.addEventListener("online", this.show.bind(this));
    };

    Menu.prototype.text = function(val) {
      this.$rep.find("> [buttontext]").text(val);
      return this;
    };

    Menu.prototype._click = function() {
      this.toggleDropdown();
      ui.refreshUtilities();
      return typeof this.click === "function" ? this.click() : void 0;
    };

    Menu.prototype.openDropdown = function() {
      var _this = this;
      if (this.dropdownOpen) {
        return;
      }
      ui.menu.closeAllDropdowns();
      this.$rep.attr("selected", "");
      this.refresh();
      this.$dropdown.show();
      this.dropdownOpen = true;
      trackEvent("Menu " + this.itemid, "Action (click)");
      async(function() {
        return _this.refreshAfterVisible();
      });
      return this;
    };

    Menu.prototype.closeDropdown = function() {
      if (!this.dropdownOpen) {
        return;
      }
      this.$rep.removeAttr("selected");
      this.$rep.find("input:focus").blur();
      this.$dropdown.hide();
      this.dropdownOpen = false;
      if (typeof this.onClose === "function") {
        this.onClose();
      }
      return this;
    };

    Menu.prototype.toggleDropdown = function() {
      if (this.dropdownOpen) {
        return this.closeDropdown();
      } else {
        return this.openDropdown();
      }
    };

    Menu.prototype.show = function() {
      var _ref3;
      if (this.onlineOnly && !navigator.onLine) {
        return this;
      }
      if ((_ref3 = this.$rep) != null) {
        _ref3.removeClass("hidden");
      }
      return this;
    };

    Menu.prototype.hide = function() {
      var _ref3;
      if ((_ref3 = this.$rep) != null) {
        _ref3.addClass("hidden");
      }
      return this;
    };

    Menu.prototype.dropdownSetup = function() {};

    Menu.prototype.group = function() {
      return this.$rep.closest(".menu-group");
    };

    Menu.prototype.groupHide = function() {
      var _ref3;
      return (_ref3 = this.group()) != null ? _ref3.hide() : void 0;
    };

    Menu.prototype.groupShow = function() {
      var _ref3;
      return (_ref3 = this.group()) != null ? _ref3.css("display", "inline-block") : void 0;
    };

    return Menu;

  })();

  /*
  
    A button in a menu dropdown.
  
    Simple shit. Just has a handful of methods.
  
      text
        Change what it says.
  
      action
        Change what it does.
  
      refresh
        Change other things about it
        when its dropdown gets opened.
  
      disable
        Disable it
  
      enable
        Enable it
  */


  MenuItem = (function() {
    function MenuItem(attrs) {
      var i, x,
        _this = this;
      for (i in attrs) {
        x = attrs[i];
        this[i] = x;
      }
      this.$rep = $("#" + this.itemid);
      this.rep = this.$rep[0];
      if (this.hotkey != null) {
        ui.hotkeys.sets.app.down[this.hotkey] = function(e) {
          var _ref3, _ref4;
          e.preventDefault();
          _this._refresh();
          if (_this.disabled) {
            return;
          }
          _this.action(e);
          trackEvent("Menu item " + _this.itemid, "Action (hotkey)");
          if ((_ref3 = _this.owner()) != null) {
            _ref3.refresh();
          }
          _this.$rep.addClass("down");
          if ((_ref4 = _this.owner()) != null) {
            _ref4.$rep.addClass("down");
          }
          if (_this.hotkey.mentions("cmd")) {
            return setTimeout(function() {
              var _ref5;
              _this.$rep.removeClass("down");
              if ((_ref5 = _this.owner()) != null) {
                _ref5.$rep.removeClass("down");
              }
              return _this._refresh();
            }, 50);
          }
        };
        if (!(this.hotkey.mentions("cmd"))) {
          if (this.disabled) {
            return;
          }
          ui.hotkeys.sets.app.up[this.hotkey] = function(e) {
            var _ref3;
            _this.$rep.removeClass("down");
            if ((_ref3 = _this.owner()) != null) {
              _ref3.$rep.removeClass("down");
            }
            if (typeof _this.after === "function") {
              _this.after();
            }
            return _this._refresh();
          };
        }
      }
    }

    MenuItem.prototype._click = function(e) {
      var _ref3, _ref4, _ref5;
      this._refresh();
      if (this.disabled) {
        return;
      }
      if (this.closeOnClick) {
        if ((_ref3 = this.owner()) != null) {
          _ref3.closeDropdown();
        }
      }
      if ((_ref4 = this.owner()) != null) {
        _ref4.$rep.find("[selected]").removeAttr("selected");
      }
      if (typeof this.action === "function") {
        this.action(e);
      }
      if ((_ref5 = this.owner()) != null) {
        _ref5.refreshEnabledItems();
      }
      return trackEvent("Menu item " + this.itemid, "Action (click)");
    };

    MenuItem.prototype.closeOnClick = true;

    MenuItem.prototype.save = function() {};

    MenuItem.prototype._refresh = function() {
      if (typeof this.refresh === "function") {
        this.refresh();
      }
      if (this.enableWhen != null) {
        if (this.enableWhen()) {
          return this.enable();
        } else {
          return this.disable();
        }
      }
    };

    MenuItem.prototype.refresh = function() {};

    MenuItem.prototype.owner = function() {
      return ui.menu.menu(this.$rep.closest(".menu").attr("id"));
    };

    MenuItem.prototype.show = function() {
      this.$rep.show();
      $(".separator[visiblewith=\"" + this.itemid + "\"]").show();
      return this;
    };

    MenuItem.prototype.hide = function() {
      this.$rep.hide();
      $(".separator[visiblewith=\"" + this.itemid + "\"]").hide();
      return this;
    };

    MenuItem.prototype.disable = function() {
      this.disabled = true;
      this.$rep.addClass("disabled");
      return this;
    };

    MenuItem.prototype.enable = function() {
      this.disabled = false;
      this.$rep.removeClass("disabled");
      return this;
    };

    MenuItem.prototype.text = function(val) {
      return this.$rep.find("[buttontext]").text(val);
    };

    MenuItem.prototype.group = function() {
      return this.$rep.closest(".menu-group");
    };

    MenuItem.prototype.groupHide = function() {
      var _ref3;
      return (_ref3 = this.group()) != null ? _ref3.hide() : void 0;
    };

    MenuItem.prototype.groupShow = function() {
      var _ref3;
      return (_ref3 = this.group()) != null ? _ref3.css("display", "inline-block") : void 0;
    };

    return MenuItem;

  })();

  setup.push(function() {
    return ui.menu.menus.file = new Menu({
      itemid: "file-menu"
    });
  });

  setup.push(function() {
    ui.menu.menus.edit = new Menu({
      itemid: "edit-menu"
    });
    ui.menu.items.undo = new MenuItem({
      itemid: "undo-item",
      action: function(e) {
        e.preventDefault();
        return archive.undo();
      },
      hotkey: "cmd-Z",
      closeOnClick: false,
      enableWhen: function() {
        return !archive.currentlyAtBeginning();
      }
    });
    ui.menu.items.redo = new MenuItem({
      itemid: "redo-item",
      action: function(e) {
        e.preventDefault();
        return archive.redo();
      },
      hotkey: "cmd-shift-Z",
      closeOnClick: false,
      enableWhen: function() {
        return !archive.currentlyAtEnd();
      }
    });
    ui.menu.items.visualHistory = new MenuItem({
      itemid: "visual-history",
      action: function(e) {
        return ui.utilities.history.toggle();
      },
      hotkey: "0",
      closeOnClick: false,
      enableWhen: function() {
        return archive.events.length > 0;
      }
    });
    ui.menu.items.selectAll = new MenuItem({
      itemid: "select-all-item",
      action: function(e) {
        e.preventDefault();
        return ui.selection.elements.selectAll();
      },
      hotkey: "cmd-A",
      closeOnClick: false,
      enableWhen: function() {
        return ui.elements.length > 0;
      }
    });
    ui.menu.items.cut = new MenuItem({
      itemid: "cut-item",
      action: function(e) {
        e.preventDefault();
        return ui.clipboard.cut();
      },
      hotkey: "cmd-X",
      closeOnClick: false,
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      }
    });
    ui.menu.items.copy = new MenuItem({
      itemid: "copy-item",
      action: function(e) {
        e.preventDefault();
        return ui.clipboard.copy();
      },
      hotkey: "cmd-C",
      closeOnClick: false,
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      }
    });
    ui.menu.items.paste = new MenuItem({
      itemid: "paste-item",
      action: function(e) {
        e.preventDefault();
        return ui.clipboard.paste();
      },
      hotkey: "cmd-V",
      closeOnClick: false,
      enableWhen: function() {
        return ui.clipboard.data != null;
      }
    });
    return ui.menu.items["delete"] = new MenuItem({
      itemid: "delete-item",
      action: function(e) {
        e.preventDefault();
        archive.addExistenceEvent(ui.selection.elements.all.map(function(e) {
          return e.zIndex();
        }));
        ui.selection["delete"]();
        return ui.selection.elements.validate();
      },
      hotkey: "backspace",
      closeOnClick: false,
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      }
    });
  });

  setup.push(function() {
    ui.menu.menus.view = new Menu({
      itemid: "view-menu"
    });
    ui.menu.items.zoomOut = new MenuItem({
      itemid: "zoom-out-item",
      action: function(e) {
        e.preventDefault();
        ui.canvas.zoomOut();
        return false;
      },
      after: function() {
        return ui.refreshAfterZoom();
      },
      hotkey: "-",
      closeOnClick: false
    });
    ui.menu.items.zoomIn = new MenuItem({
      itemid: "zoom-in-item",
      action: function(e) {
        e.preventDefault();
        ui.canvas.zoomIn();
        return false;
      },
      after: function() {
        return ui.refreshAfterZoom();
      },
      hotkey: "+",
      closeOnClick: false
    });
    ui.menu.items.zoom100 = new MenuItem({
      itemid: "zoom-100-item",
      action: function(e) {
        e.preventDefault();
        ui.canvas.zoom100();
        return false;
      },
      after: function() {
        return ui.refreshAfterZoom();
      },
      hotkey: "1",
      closeOnClick: false
    });
    return ui.menu.items.grid = new MenuItem({
      itemid: "show-grid-item",
      hotkey: "shift-'",
      action: function() {
        return ui.grid.toggle();
      },
      closeOnClick: false
    });
  });

  setup.push(function() {
    return ui.menu.menus.about = new Menu({
      itemid: "about-menu",
      refreshAfterVisible: function() {}
    });
  });

  setup.push(function() {
    ui.menu.menus.login = new Menu({
      itemid: "login-menu",
      onlineOnly: true,
      refreshAfterVisible: function() {
        return $("#login-email-input").focus();
      },
      submit: function($self) {
        var email, passwd;
        email = $("#login-email-input").val();
        passwd = $("#login-passwd-input").val();
        if (email === "") {
          return $self.error("email required");
        } else if (passwd === "") {
          return $self.error("password required");
        } else {
          return ui.account.login(email, passwd);
        }
      }
    });
    $("#submit-login").click(function() {
      return ui.menu.menus.login.submit($(this));
    });
    return $("#login-passwd-input").hotkeys({
      down: {
        enter: function() {
          return ui.menu.menus.login.submit();
        }
      }
    });
  });

  setup.push(function() {
    ui.menu.menus.register = new Menu({
      itemid: "register-menu",
      onlineOnly: true,
      refreshAfterVisible: function() {
        return $("#register-name").focus();
      },
      submit: function() {
        var email, name, passwd;
        name = $("#register-name").val();
        email = $("#register-email").val();
        passwd = $("#register-passwd").val();
        return ui.account.create(name, email, passwd, function(data) {});
      }
    });
    $("#submit-registration").click(function() {
      return ui.menu.menus.register.submit();
    });
    return $("#register-passwd").hotkeys({
      down: {
        enter: function() {
          return ui.menu.menus.register.submit();
        }
      }
    });
  });

  setup.push(function() {
    return ui.menu.menus.geometry = new Menu({
      itemid: "geometry-menu"
    });
  });

  setup.push(function() {
    return ui.menu.menus.account = new Menu({
      itemid: "account-menu",
      onlineOnly: true,
      showAndFillIn: function(email) {
        this.group().style.display = "inline-block";
        return this.$rep.find("span#logged-in-email").text(email);
      },
      onClose: function() {
        return this.$dropdown.attr("mode", "normal");
      }
    });
  });

  setup.push(function() {
    ui.menu.menus.share = new Menu({
      itemid: "share-menu",
      onlineOnly: true
    });
    return ui.menu.items.shareAsLink = new MenuItem({
      itemid: "share-permalink-item",
      action: function() {
        return services.permalink.put();
      }
    });
  });

  setup.push(function() {
    return ui.menu.menus.embed = new Menu({
      itemid: "embed-menu",
      template: function() {
        var height;
        height = ((ui.canvas.height / ui.canvas.width) * this.width) + 31;
        height = Math.ceil(height);
        return "<iframe width=\"" + this.width + "\" height=\"" + height + "\" frameborder=\"0\" src=\"" + SETTINGS.EMBED.ENDPOINT + "/files/permalinks/" + ui.file.key + "/embed\"></iframe>";
      },
      onlineOnly: true,
      refreshAfterVisible: function() {
        var _this = this;
        if (ui.file.constructor === PermalinkFile) {
          this.generateCode();
          return this.$textarea.select();
        } else {
          this.$textarea.val("Saving, please wait...");
          this.$textarea.disable();
          return services.permalink.put(void 0, io.makeFile(), function() {
            _this.generateCode();
            _this.$textarea.enable();
            return _this.$textarea.select();
          });
        }
      },
      dropdownSetup: function() {
        var _this = this;
        this.width = 500;
        this.$textarea = this.$rep.find("textarea");
        return this.widthControl = new NumberBox({
          rep: this.$rep.find('input')[0],
          value: this.width,
          min: 100,
          max: 1600,
          places: 0,
          hotkeys: {
            up: {
              always: function() {
                return this.commit();
              }
            }
          },
          commit: function(val) {
            _this.width = val;
            return _this.generateCode();
          }
        });
      },
      generateCode: function() {
        return this.$textarea.val(this.template());
      }
    });
  });

  setup.push(function() {
    return ui.menu.items.filename = new MenuItem({
      itemid: "filename-item",
      refresh: function(name, path, service) {
        this.$rep.find("#file-name-with-extension").text(ui.file.name);
        this.$rep.find("#service-logo-for-filename").show().attr("class", "service-logo-small " + ui.file.service.name);
        return this.$rep.find("#service-path-for-filename").html(ui.file.path);
      },
      action: function(e) {
        return e.stopPropagation();
      }
    });
  });

  setup.push(function() {
    ui.menu.items.save = new MenuItem({
      itemid: "save-item",
      action: function(e) {
        var _this = this;
        if (e != null) {
          e.preventDefault();
        }
        ui.file.save(function() {
          _this.enable();
          return _this.text("Save");
        });
        trackEvent("Local files", "Save");
        this.disable();
        return this.text("Saving...");
      },
      hotkey: 'cmd-S',
      refresh: function() {
        if (ui.file.readonly) {
          this.disable();
          return this.text("This file is read-only");
        } else {
          if (ui.file.hasChanges()) {
            this.enable();
            return this.text("Save");
          } else {
            this.disable();
            return this.text("All changes saved");
          }
        }
      }
    });
    return ui.menu.items.saveAs = new MenuItem({
      itemid: "save-as-item",
      action: function(e) {
        if (e != null) {
          e.preventDefault();
        }
        return ui.browser.open();
      },
      hotkey: 'cmd-shift-S',
      refresh: function() {
        return this.enable();
      }
    });
  });

  setup.push(function() {
    return ui.menu.items["new"] = new MenuItem({
      itemid: "new-item",
      action: function(e) {
        var f;
        ui["new"](1000, 750, new Posn(0, 0), 1.0);
        switch (ui.file.service) {
          case services.permalink:
          case services.local:
            f = new LocalFile(services.local.nextDefaultName()).use();
            ui.file.save();
            return archive.setup();
          case services.dropbox:
            return services.dropbox.defaultName(ui.file.path, function(name) {
              return new DropboxFile("" + ui.file.path + name).use();
            });
        }
      },
      hotkey: 'N'
    });
  });

  setup.push(function() {
    return ui.menu.items.logout = new MenuItem({
      itemid: "logout-item",
      action: function() {
        return ui.account.logout();
      }
    });
  });

  setup.push(function() {
    ui.menu.items.open = new MenuItem({
      itemid: "open-item",
      action: function() {
        return ui.file.service.open();
      }
    });
    ui.menu.items.openHD = new MenuItem({
      itemid: "open-from-hd-item",
      action: function() {},
      refresh: function() {
        var $input, name, reader,
          _this = this;
        $input = $("#hd-file-loader");
        reader = new FileReader;
        name = null;
        reader.onload = function(e) {
          new LocalFile(name).set(e.target.result).use(true).save();
          return _this.owner().closeDropdown();
        };
        return $input.change(function() {
          var file;
          this.setAttribute("value", "");
          file = this.files[0];
          if (file == null) {
            return;
          }
          name = file.name;
          reader.readAsText(file);
          return trackEvent("Local files", "Open from HD");
        });
      }
    });
    return ui.menu.items.openURL = new MenuItem({
      itemid: "open-from-url-item",
      action: function() {
        this.inputMode();
        return setTimeout(function() {
          return ui.cursor.reset();
        }, 1);
      },
      openURL: function(url) {
        var name;
        name = url.match(/[^\/]*\.svg$/gi);
        name = name ? name[0] : services.local.nextDefaultName();
        return $.ajax({
          url: "" + SETTINGS.BONITA.ENDPOINT + "/curl/?url=" + url,
          type: 'GET',
          data: {},
          success: function(data) {
            var file;
            data = new XMLSerializer().serializeToString(data);
            file = new LocalFile(name).set(data).use(true);
            return trackEvent("Local files", "Open from URL");
          },
          error: function(data) {
            return console.log("error");
          }
        });
      },
      clickMeMode: function() {
        this.$rep.find("input").blur();
        this.$rep.removeClass("input-mode");
        return this.$rep.removeAttr("selected");
      },
      inputMode: function() {
        var self,
          _this = this;
        self = this;
        this.$rep.addClass("input-mode");
        this.$rep.attr("selected", "");
        return this.$rep.find('input').val("").focus().on("paste", function(e) {
          return setTimeout((function() {
            _this.openURL($(e.target).val());
            _this.clickMeMode();
            return _this.owner().closeDropdown();
          }), 10);
        });
      },
      closeOnClick: false,
      refresh: function() {
        return this.clickMeMode();
      }
    });
  });

  setup.push(function() {
    return ui.menu.items.dropboxConnect = new MenuItem({
      itemid: "connect-to-dropbox-item",
      enableWhen: function() {
        return navigator.onLine;
      },
      refresh: function() {
        if (ui.account.session_token) {
          this.enable();
          this.rep.parentNode.setAttribute("href", "" + SETTINGS.MEOWSET.ENDPOINT + "/poletto/connect-to-dropbox?session_token=" + ui.account.session_token);
          return this.$rep.parent().off('click').on('click', function() {
            return ui.window.one("focus", function() {
              ui.menu.menus.file.closeDropdown();
              ui.account.checkServices();
              return trackEvent("Dropbox", "Connect Account");
            });
          });
        } else {
          this.disable();
          return this.$rep.parent().click(function(e) {
            return e.preventDefault();
          });
        }
      }
    });
  });

  setup.push(function() {
    ui.menu.items.downloadSVG = new MenuItem({
      itemid: "download-as-SVG-item",
      refreshAfterVisible: function() {
        var $link;
        $link = q("#download-svg-link");
        if (this.disabled) {
          $link.removeAttribute("href");
          $link.removeAttribute("download");
        } else {
          $link.setAttribute("href", io.makeBase64URI());
          $link.setAttribute("download", ui.file.name);
        }
        return $($link).one('click', function() {
          return trackEvent("Download", "SVG", ui.file.name);
        });
      }
    });
    return ui.menu.items.downloadPNG = new MenuItem({
      itemid: "download-as-PNG-item",
      refreshAfterVisible: function() {
        var $link;
        $link = q("#download-png-link");
        if (this.disabled) {
          $link.removeAttribute("href");
          $link.removeAttribute("download");
        } else {
          $link.setAttribute("href", io.makePNGURI());
          $link.setAttribute("download", ui.file.name.replace("svg", "png"));
        }
        return $($link).one('click', function() {
          return trackEvent("Download", "PNG", ui.file.name);
        });
      }
    });
  });

  setup.push(function() {
    ui.menu.items.moveBack = new MenuItem({
      itemid: 'move-back-item',
      hotkey: '[',
      action: function() {
        var zIndexesBefore;
        zIndexesBefore = ui.selection.elements.zIndexes();
        ui.selection.elements.all.map(function(e) {
          return e.moveBack();
        });
        return archive.addZIndexEvent(zIndexesBefore, ui.selection.elements.zIndexes(), 'mb');
      },
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      },
      closeOnClick: false
    });
    ui.menu.items.moveForward = new MenuItem({
      itemid: 'move-forward-item',
      hotkey: ']',
      action: function() {
        var zIndexesBefore;
        zIndexesBefore = ui.selection.elements.zIndexes();
        ui.selection.elements.all.map(function(e) {
          return e.moveForward();
        });
        return archive.addZIndexEvent(zIndexesBefore, ui.selection.elements.zIndexes(), 'mf');
      },
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      },
      closeOnClick: false
    });
    ui.menu.items.sendToBack = new MenuItem({
      itemid: 'send-to-back-item',
      hotkey: 'shift-[',
      action: function() {
        var zIndexesBefore;
        zIndexesBefore = ui.selection.elements.zIndexes();
        ui.selection.elements.all.map(function(e) {
          return e.sendToBack();
        });
        return archive.addZIndexEvent(zIndexesBefore, ui.selection.elements.zIndexes(), 'mbb');
      },
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      },
      closeOnClick: false
    });
    return ui.menu.items.bringToFront = new MenuItem({
      itemid: 'bring-to-front-item',
      hotkey: 'shift-]',
      action: function() {
        var zIndexesBefore;
        zIndexesBefore = ui.selection.elements.zIndexes();
        ui.selection.elements.all.map(function(e) {
          return e.bringToFront();
        });
        return archive.addZIndexEvent(zIndexesBefore, ui.selection.elements.zIndexes(), 'mff');
      },
      enableWhen: function() {
        return ui.selection.elements.all.length > 0;
      },
      closeOnClick: false
    });
  });

  ui.utilities = {};

  Utility = (function() {
    function Utility(attrs) {
      var i, x,
        _this = this;
      for (i in attrs) {
        if (!__hasProp.call(attrs, i)) continue;
        x = attrs[i];
        this[i] = x;
      }
      if (this.setup != null) {
        setup.push(function() {
          return _this.setup();
        });
      }
      this.$rep = $(this.root);
      setup.push(function() {
        if (_this.shouldBeOpen()) {
          return _this.show();
        } else {
          return _this.hide();
        }
      });
    }

    Utility.prototype.shouldBeOpen = function() {};

    Utility.prototype.show = function() {
      var _ref3;
      if (ui.canvas.petrified) {
        return;
      }
      this.visible = true;
      if ((_ref3 = this.rep) != null) {
        _ref3.style.display = "block";
      }
      if (typeof this.onshow === "function") {
        this.onshow();
      }
      return this;
    };

    Utility.prototype.hide = function() {
      var _ref3;
      this.visible = false;
      this.$rep.find('input').blur();
      if ((_ref3 = this.rep) != null) {
        _ref3.style.display = "none";
      }
      return this;
    };

    Utility.prototype.toggle = function() {
      if (this.visible) {
        return this.hide();
      } else {
        return this.show();
      }
    };

    Utility.prototype.position = function(x, y) {
      var _ref3, _ref4;
      this.x = x;
      this.y = y;
      if ((_ref3 = this.rep) != null) {
        _ref3.style.left = x.px();
      }
      if ((_ref4 = this.rep) != null) {
        _ref4.style.top = y.px();
      }
      return this;
    };

    Utility.prototype.saveOffset = function() {
      this.offset = new Posn($(this.rep).offset());
      return this;
    };

    return Utility;

  })();

  /*
  
    Color picker
  */


  ui.utilities.color = new Utility({
    setup: function() {
      var _this = this;
      this.rep = q("#color-picker-ut");
      this.poolContainer = q("#pool-container");
      this.poolContext = q("#color-picker-ut canvas#color-pool").getContext("2d");
      this.saturationSliderContainer = q("#saturation-slider");
      this.currentIndicator1 = q("#color-marker1");
      this.currentIndicator2 = q("#color-marker2");
      this.inputs = {
        r: q("#color-r"),
        g: q("#color-g"),
        b: q("#color-b"),
        hex: q("#color-hex")
      };
      this.hide();
      this.drawPool();
      this.poolContainer.onscroll = function(e) {
        if (this.scrollTop === 0) {
          this.scrollTop = 1530;
        } else if (this.scrollTop === 3060 - 260) {
          this.scrollTop = 1530 - 260;
        }
        if (ui.cursor.down) {
          return ui.utilities.color.selectColor(ui.cursor.lastEvent);
        }
      };
      this.saturationSlider = new Slider({
        rep: this.saturationSliderContainer,
        commit: function(val) {
          _this.drawPool(val);
          _this.set(_this.getColorAt(_this.selected));
          return _this.center;
        }
      });
      this.rControl = new NumberBox({
        rep: this.inputs.r,
        min: 0,
        max: 255,
        value: 0,
        commit: function(val) {
          return _this.alterVal("r", val);
        }
      });
      this.gControl = new NumberBox({
        rep: this.inputs.g,
        min: 0,
        max: 255,
        value: 0,
        commit: function(val) {
          return _this.alterVal("g", val);
        }
      });
      this.gControl = new NumberBox({
        rep: this.inputs.b,
        min: 0,
        max: 255,
        value: 0,
        commit: function(val) {
          return _this.alterVal("b", val);
        }
      });
      return this.hexControl = new TextBox({
        rep: this.inputs.hex,
        value: 0,
        commit: function(val) {
          _this.set(new Color(val));
          _this.refresh();
          _this.selectedColor.updateHex();
          return _this.hexControl.write(_this.selectedColor.hex);
        },
        hotkeys: {
          blacklist: null
        },
        maxLength: 6
      });
    },
    alterVal: function(which, val) {
      this.selectedColor[which] = val;
      this.selectedColor.recalculateHex();
      this.set(this.selectedColor);
      return this.refresh();
    },
    refresh: function() {
      this.drawPool(this.selectedColor.saturation());
      this.saturationSlider.write(this.selectedColor.saturation());
      this.selected = this.getPositionOf(this.selectedColor);
      return this.updateIndicator().centerOnIndicator();
    },
    shouldBeOpen: function() {
      return false;
    },
    onshow: function() {
      this.poolContainer.scrollTop = 600;
      this.selectedColor = new Color(this.setting.getAttribute("val"));
      this.selected = this.getPositionOf(this.selectedColor);
      this.saturationSlider.set(this.selectedColor.saturation());
      this.drawPool(this.selectedColor.saturation());
      this.updateIndicator();
      this.centerOnIndicator();
      return trackEvent("Color", "Open picker");
    },
    ensureVisibility: function() {
      this.rep.style.top = "" + (Math.min(ui.window.height() - 360, parseFloat(this.rep.style.top))) + "px";
      return this.saveOffset();
    },
    centerOnIndicator: function() {
      this.poolContainer.scrollTop = parseFloat(this.currentIndicator1.style.top) - 130;
      return this;
    },
    setting: null,
    set: function(color) {
      this.selectedColor = color;
      $(this.setting).trigger("set", [color]);
      $(this.inputs.r).val(color.r);
      $(this.inputs.g).val(color.g);
      $(this.inputs.b).val(color.b);
      return $(this.inputs.hex).val(color.hex);
    },
    selectColor: function(e) {
      var color;
      this.selected = new Posn(e).subtract(this.offset).subtract(new Posn(10, 12));
      this.selected.y += this.poolContainer.scrollTop;
      color = this.getColorAt(this.selected);
      this.set(color);
      return this.updateIndicator();
    },
    updateIndicator: function() {
      if (this.selectedColor.toString() === "none") {
        this.hideIndicator(this.currentIndicator1);
        return this.hideIndicator(this.currentIndicator2);
      } else {
        this.showIndicator(this.currentIndicator1);
        this.showIndicator(this.currentIndicator2);
        this.positionIndicator(this.currentIndicator1, this.selected);
        this.selected.y = (this.selected.y + 1530) % 3060;
        this.positionIndicator(this.currentIndicator2, this.selected);
        return this;
      }
    },
    showIndicator: function(indicator) {
      return indicator.style.display = "block";
    },
    hideIndicator: function(indicator) {
      return indicator.style.display = "none";
    },
    getColorAt: function(posn) {
      var data;
      data = this.poolContext.getImageData(posn.x, posn.y, 1, 1);
      return new Color(data.data[0], data.data[1], data.data[2]);
    },
    getPositionOf: function(color) {
      var primary, secondary, tertiary, x, y;
      primary = color.max();
      secondary = color.mid();
      tertiary = color.min();
      switch (primary) {
        case color.r:
          y = 0;
          switch (secondary) {
            case color.g:
              y += secondary;
              break;
            case color.b:
              y -= secondary;
          }
          break;
        case color.g:
          y = 510;
          switch (secondary) {
            case color.b:
              y += secondary;
              break;
            case color.r:
              y -= secondary;
          }
          break;
        case color.b:
          y = 1020;
          switch (secondary) {
            case color.r:
              y += secondary;
              break;
            case color.g:
              y -= secondary;
          }
      }
      if (y < 0) {
        y += 1530;
      }
      y %= 1530;
      x = 260 - (color.lightness() * 260);
      return new Posn(x, y);
    },
    positionIndicator: function(indicator, posn) {
      indicator.className = posn.x < 130 ? "indicator black" : "indicator white";
      indicator.style.left = posn.x.px();
      return indicator.style.top = posn.y.px();
    },
    sample: function(elem) {
      this.setting = ui.fill.rep;
      this.set(elem.data.fill != null ? elem.data.fill : ui.colors["null"]);
      this.setting = ui.stroke.rep;
      return this.set(elem.data.stroke != null ? elem.data.stroke : ui.colors["null"]);
    },
    drawPool: function(saturation) {
      var colors, gradient, i, wb, _i;
      if (saturation == null) {
        saturation = 1.0;
      }
      gradient = this.poolContext.createLinearGradient(0, 0, 0, 3060);
      colors = [ui.colors.red, ui.colors.yellow, ui.colors.green, ui.colors.teal, ui.colors.blue, ui.colors.pink];
      for (i = _i = 0; _i <= 12; i = ++_i) {
        gradient.addColorStop((1 / 12) * i, colors[i % 6].clone().desaturate(1.0 - saturation).toHexString());
      }
      this.poolContext.fillStyle = gradient;
      this.poolContext.fillRect(0, 0, 260, 3060);
      wb = this.poolContext.createLinearGradient(0, 0, 260, 0);
      wb.addColorStop(0.02, "#FFFFFF");
      wb.addColorStop(0.5, "rgba(255, 255, 255, 0.0)");
      wb.addColorStop(0.5, "rgba(0, 0, 0, 0.0)");
      wb.addColorStop(0.98, "#000000");
      this.poolContext.fillStyle = wb;
      return this.poolContext.fillRect(0, 0, 260, 3060);
    }
  });

  ui.utilities.currentSwatches = new Utility({
    setup: function() {
      var _this = this;
      this.$rep = $("#current-swatches-ut");
      this.rep = this.$rep[0];
      return ui.selection.elements.on('change', function() {
        _this.generateSwatches();
        if (ui.selection.elements.empty()) {
          return _this.clear();
        } else if (ui.selection.elements.all.length === 1) {
          return ui.utilities.color.sample(ui.selection.elements.all[0]);
        }
      });
    },
    shouldBeOpen: function() {
      return ui.selection.elements.all.length > 0;
    },
    clear: function() {
      return this.rep.innerHTML = "";
    },
    generateSwatches: function() {
      var swatch, _i, _len, _ref3, _results;
      this.clear();
      this.getSelectedSwatches();
      if (this.swatches.length === 1) {
        ui.utilities.color.sample(ui.selection.elements.all[0]);
        return this.clear();
      } else {
        _ref3 = this.swatches;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          swatch = _ref3[_i];
          if (swatch.fill.equal(ui.fill) && swatch.stroke.equal(ui.stroke)) {
            _results.push(this.$rep.prepend(swatch.rep));
          } else {
            _results.push(this.$rep.append(swatch.rep));
          }
        }
        return _results;
      }
    },
    getSelectedSwatches: function() {
      var $srep, add, elem, key, swatchDuo, _i, _len, _ref3, _results,
        _this = this;
      this.swatches = [];
      this.swatchMap = {};
      add = function(key, val) {
        if (_this.swatchMap[key] != null) {
          return _this.swatchMap[key].push(val);
        } else {
          return _this.swatchMap[key] = [val];
        }
      };
      _ref3 = ui.selection.elements.all;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        swatchDuo = new SwatchDuo(elem);
        key = swatchDuo.toString();
        if (this.swatchMap[key] == null) {
          this.swatches.push(swatchDuo);
        }
        add(key, elem);
        $srep = swatchDuo.$rep;
        _results.push($srep.click(function() {
          return ui.selection.elements.select(ui.utilities.currentSwatches.swatchMap[this.getAttribute("key")]);
        }).mouseover(function(e) {
          var _j, _len1, _ref4, _results1;
          e.stopPropagation();
          _ref4 = ui.utilities.currentSwatches.swatchMap[this.getAttribute("key")];
          _results1 = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            elem = _ref4[_j];
            _results1.push(elem.showPoints());
          }
          return _results1;
        }).mouseout(function(e) {
          var _j, _len1, _ref4, _results1;
          _ref4 = ui.utilities.currentSwatches.swatchMap[this.getAttribute("key")];
          _results1 = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            elem = _ref4[_j];
            _results1.push(elem.removePoints().hidePoints());
          }
          return _results1;
        }));
      }
      return _results;
    }
  });

  /*
  
    Transform utility
  
    Allows you to read and input changes to
    selected elements' dimensions and position.
  */


  ui.utilities.transform = new Utility({
    setup: function() {
      var _this = this;
      this.rep = q("#transform-ut");
      this.canvas = q("#transform-ut canvas#preview-canvas");
      this.$canvas = $(this.canvas);
      this.origin = q("#transform-ut #origin-icon");
      this.$origin = $(this.origin);
      this.widthBracket = q("#transform-ut #width-bracket");
      this.$widthBracket = $(this.widthBracket);
      this.heightBracket = q("#transform-ut #height-bracket");
      this.$heightBracket = $(this.heightBracket);
      this.outline = q("#transform-ut #subtle-blue-outline");
      this.$outline = $(this.outline);
      this.inputs = {
        originX: q("#transform-ut #origin-x-val"),
        originY: q("#transform-ut #origin-y-val"),
        width: q("#transform-ut #width-val"),
        height: q("#transform-ut #height-val")
      };
      this.context = this.canvas.getContext("2d");
      this.widthControl = new NumberBox({
        rep: this.inputs.width,
        value: 0,
        min: 0.00001,
        places: 5,
        commit: function(val) {
          return _this.alterVal("width", val);
        }
      });
      this.heightControl = new NumberBox({
        rep: this.inputs.height,
        value: 0,
        min: 0.00001,
        places: 5,
        commit: function(val) {
          return _this.alterVal("height", val);
        }
      });
      this.originXControl = new NumberBox({
        rep: this.inputs.originX,
        value: 0,
        commit: function(val) {
          return _this.alterVal("origin-x", val);
        }
      });
      this.originYControl = new NumberBox({
        rep: this.inputs.originY,
        value: 0,
        commit: function(val) {
          return _this.alterVal("origin-y", val);
        }
      });
      return this.hide();
    },
    shouldBeOpen: function() {
      return ui.selection.elements.all.length > 0;
    },
    trueVals: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    alterVal: function(which, val) {
      var center, change, scale;
      center = ui.transformer.tl;
      switch (which) {
        case "width":
          scale = val / this.trueVals.width;
          scale = scale.ensureRealNumber();
          ui.transformer.scale(scale, 1, center).redraw();
          ui.selection.scale(scale, 1, center);
          archive.addMapEvent("scale", ui.selection.elements.zIndexes(), {
            x: scale,
            y: 1,
            origin: center
          });
          return this.trueVals.width = val;
        case "height":
          scale = val / this.trueVals.height;
          scale = scale.ensureRealNumber();
          ui.transformer.scale(1, scale, center).redraw();
          ui.selection.scale(1, scale, center);
          archive.addMapEvent("scale", ui.selection.elements.zIndexes(), {
            x: 1,
            y: scale,
            origin: center
          });
          return this.trueVals.height = val;
        case "origin-x":
          change = val - this.trueVals.x;
          ui.selection.nudge(change, 0);
          archive.addMapEvent("nudge", ui.selection.elements.zIndexes(), {
            x: change,
            y: 0
          });
          return this.trueVals.x = val;
        case "origin-y":
          change = val - this.trueVals.y;
          ui.selection.nudge(0, -change);
          archive.addMapEvent("nudge", ui.selection.elements.zIndexes(), {
            x: 0,
            y: -change
          });
          return this.trueVals.y = val;
      }
    },
    refresh: function() {
      var png;
      if (ui.selection.elements.empty()) {
        return;
      }
      png = ui.selection.elements.exportAsPNG({
        trim: true
      });
      this.drawPreview(png.maxDimension(105).exportAsDataURI());
      return png.destroy();
    },
    refreshValues: function() {
      if (!this.visible) {
        return;
      }
      this.trueVals.x = ui.transformer.tl.x;
      this.trueVals.y = ui.transformer.tl.y;
      this.trueVals.width = ui.transformer.width;
      this.trueVals.height = ui.transformer.height;
      $(this.inputs.originX).val(this.trueVals.x.places(4));
      $(this.inputs.originY).val(this.trueVals.y.places(4));
      $(this.inputs.width).val(this.trueVals.width.places(4));
      return $(this.inputs.height).val(this.trueVals.height.places(4));
    },
    onshow: function() {
      return this.refreshValues();
    },
    clearPreview: function() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.origin.style.display = "none";
      this.widthBracket.style.display = "none";
      return this.heightBracket.style.display = "none";
    },
    drawPreview: function(datauri, bounds) {
      var img, leftOffset, scale, theight, topOffset, twidth,
        _this = this;
      this.clearPreview();
      if (datauri === "data:image/svg+xml;base64,") {
        return this.hide();
      }
      this.show();
      img = new Image();
      img.onload = function() {
        return _this.context.drawImage(img, 0, 0);
      };
      img.src = datauri;
      twidth = ui.transformer.width + 2;
      theight = ui.transformer.height + 2;
      this.refreshValues();
      scale = Math.min(105 / twidth, 105 / theight);
      topOffset = (125 - (theight * scale)) / 2;
      leftOffset = (125 - (twidth * scale)) / 2;
      this.$canvas.css({
        top: "" + topOffset + "px",
        left: "" + leftOffset + "px"
      }).attr({
        height: theight * scale + 2,
        width: twidth * scale + 2
      });
      this.$origin.show().css({
        top: "" + (Math.round(topOffset) - 3) + "px",
        left: "" + (Math.round(leftOffset) - 3) + "px"
      });
      this.$widthBracket.show().css({
        left: "" + (Math.round(leftOffset)) + "px",
        width: "" + (twidth * scale - 2) + "px"
      });
      this.$heightBracket.show().css({
        top: "" + (Math.round(topOffset)) + "px",
        height: "" + (theight * scale - 2) + "px"
      });
      return this.$outline.show().css({
        top: "" + (Math.round(topOffset)) + "px",
        left: "" + (Math.round(leftOffset)) + "px",
        height: theight * scale - 2,
        width: twidth * scale - 2
      });
    }
  });

  /*
  
    Stroke thickness utility
  */


  ui.utilities.strokeWidth = new Utility({
    setup: function() {
      var _this = this;
      this.$rep = $("#stroke-width-ut");
      this.rep = this.$rep[0];
      this.$preview = this.$rep.find("#stroke-width-preview");
      this.$noStroke = this.$rep.find("#no-stroke-width-hint");
      return this.strokeControl = new NumberBox({
        rep: this.$rep.find('input')[0],
        value: 1,
        min: 0,
        max: 100,
        places: 2,
        commit: function(val) {
          _this.alterVal(val);
          return _this.drawPreview();
        },
        onDone: function() {
          return archive.addAttrEvent(ui.selection.elements.zIndexes(), "stroke-width");
        }
      });
    },
    alterVal: function(val) {
      var elem, _i, _len, _ref3;
      if (isNaN(val)) {
        return;
      }
      val = Math.max(val, 0).places(2);
      _ref3 = ui.selection.elements.all;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        elem.data['stroke-width'] = val;
        if ((elem.data.stroke == null) || elem.data.stroke.hex === "none") {
          elem.data.stroke = ui.colors.black;
        }
        elem.commit();
      }
      this.drawPreview();
      return ui.uistate.set('strokeWidth', parseInt(val, 10));
    },
    drawPreview: function() {
      var preview;
      preview = Math.min(20, Math.max(0, this.strokeControl.value));
      this.$preview.css({
        opacity: Math.min(preview, 1.0),
        height: "" + (Math.max(1, preview)) + "px",
        top: "" + (Math.ceil(30 - Math.round(preview / 2))) + "px"
      });
      if (this.strokeControl.value === 0) {
        return this.$noStroke.css("opacity", "0.4");
      } else {
        return this.$noStroke.css("opacity", "0.0");
      }
    },
    onshow: function() {
      return this.refresh();
    },
    refresh: function() {
      var width;
      if (ui.selection.elements.all.length === 1) {
        width = ui.selection.elements.all[0].data['stroke-width'];
        ui.uistate.set('strokeWidth', parseInt(width, 10));
      } else {
        width = ui.uistate.get('strokeWidth');
      }
      if (width != null) {
        this.strokeControl.set(width);
      } else {
        this.strokeControl.set(0);
      }
      return this.drawPreview();
    },
    shouldBeOpen: function() {
      return (ui.selection.elements.all.length > 0) || ([tools.pen, tools.line, tools.ellipse, tools.rectangle, tools.crayon, tools.type].has(ui.uistate.get('tool')));
    }
  });

  setup.push(function() {
    return ui.utilities.strokeWidth.alterVal(1);
  });

  ui.utilities.typography = new Utility({
    setup: function() {
      var _this = this;
      this.$rep = $("#typography-ut");
      this.rep = this.$rep[0];
      this.$faces = this.$rep.find("#font-faces-dropdown");
      this.$size = this.$rep.find("#font-size-val");
      this.sizeControl = new NumberBox({
        rep: this.$size[0],
        value: 24,
        min: 1,
        max: 1000,
        places: 2,
        commit: function(val) {
          return _this.setSize(val);
        }
      });
      return this.faceControl = new Dropdown({
        options: this.faces,
        rep: this.$faces[0],
        callback: function(val) {
          return _this.setFace(val);
        }
      });
    },
    faces: (function() {
      var _i, _len, _ref3, _results;
      _ref3 = ['Arial', 'Arial Black', 'Cooper Black', 'Georgia', 'Monaco', 'Verdana', 'Impact', 'Gill Sans'];
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        fontFace = _ref3[_i];
        _results.push(new FontFaceOption(fontFace));
      }
      return _results;
    })(),
    setFace: function(face) {
      ui.selection.elements.ofType("text").map(function(t) {
        t.setFace(face);
        return t.commit();
      });
      return ui.transformer.refresh();
    },
    setSize: function(val) {
      ui.selection.elements.ofType("text").map(function(t) {
        t.setSize(val);
        return t.commit();
      });
      return ui.transformer.refresh();
    },
    refresh: function() {
      var sizes;
      sizes = [];
      ui.selection.elements.ofType("text").map(function(t) {
        var fs;
        fs = t.data['font-size'];
        if (!sizes.has(fs)) {
          return sizes.push(fs);
        }
      });
      if (sizes.length === 1) {
        this.sizeControl.write(sizes[0]);
      }
      return this.faceControl.close();
    },
    onshow: function() {
      return this.refresh();
    },
    shouldBeOpen: function() {
      return (ui.selection.elements.ofType("text").length > 0) || (ui.uistate.get('tool') === tools.type);
    }
  });

  ui.utilities.history = new Utility({
    setup: function() {
      var _this = this;
      this.$rep = $("#archive-ut");
      this.rep = this.$rep[0];
      this.$container = $("#archive-thumbs");
      this.container = this.$container[0];
      this.$controls = $("#archive-controls");
      this.controls = this.$controls[0];
      return this.stepsSlider = new Slider({
        rep: $("#archive-steps-slider")[0],
        commit: function(val) {},
        valueTipFormatter: function(val) {
          return "" + (Math.round(_this.maxSteps * val) + 1);
        },
        onRelease: function(val) {
          return _this.build(Math.round(_this.maxSteps * val) + 1);
        },
        inverse: true
      });
    },
    thumbsCache: {},
    deleteThumbsCached: function(after) {
      var key, thumb, toDelete, _i, _len, _ref3;
      toDelete = [];
      _ref3 = this.thumbsCache;
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        thumb = _ref3[key];
        if (parseInt(key, 10) > after) {
          toDelete.push(key);
        }
      }
      for (_i = 0, _len = toDelete.length; _i < _len; _i++) {
        key = toDelete[_i];
        delete this.thumbsCache[key];
      }
      return this;
    },
    shouldBeOpen: function() {
      return false;
    },
    open: function() {
      var _this = this;
      this.show();
      this.shouldBeOpen = function() {
        return true;
      };
      return async(function() {
        return _this.build();
      });
    },
    close: function() {
      this.$container.empty();
      this.shouldBeOpen = function() {
        return false;
      };
      return this.hide();
    },
    toggle: function() {
      if (this.visible) {
        return this.close();
      } else {
        return this.open();
      }
    },
    build: function(every) {
      var _this = this;
      this.every = every;
      if (archive.events.length < 3) {
        this.$controls.hide();
        this.every = 1;
        return this.$container.html('<div empty>Make changes to this file to get a visual history of it.</div>');
      }
      this.$controls.show();
      this.maxSteps = Math.round(archive.events.length / 4);
      if (this.every == null) {
        this.every = Math.round(this.maxSteps / 2);
        this.stepsSlider.write(0.5);
      }
      this.$container.html('<div empty>Processing <br> file history... <br> <span percentage></span></div>');
      return async(function() {
        return _this.buildThumbs(_this.every);
      });
    },
    buildThumbs: function(every, startingAt) {
      var cp, cs,
        _this = this;
      this.every = every;
      if (startingAt == null) {
        startingAt = 0;
      }
      if (startingAt < 2) {
        this.$container.empty();
      }
      cp = archive.currentPosition();
      cs = ui.selection.elements.zIndexes();
      ui.canvas.petrify();
      archive.simulating = true;
      archive.goToEvent(startingAt);
      this.thumbs = [];
      return this._buildRecursive(archive.currentPosition(), this.every, function() {
        var zi, _i, _len;
        archive.goToEvent(cp);
        archive.simulating = false;
        ui.canvas.depetrify();
        ui.selection.elements.deselectAll();
        for (_i = 0, _len = cs.length; _i < _len; _i++) {
          zi = cs[_i];
          ui.selection.elements.selectMore(queryElemByZIndex(zi));
        }
        if (startingAt === 0) {
          _this.$container.empty();
        }
        _this.thumbs.map(function($thumb) {
          return _this.$container.prepend($thumb);
        });
        return _this.refreshThumbs(archive.currentPosition());
      });
    },
    _buildRecursive: function(i, every, done) {
      var $thumb, contents, img, percentage, src,
        _this = this;
      this.every = every;
      percentage = Math.min(Math.round((i / archive.events.length) * 100), 100);
      this.$container.find('[percentage]').text("" + percentage + "%");
      archive.goToEvent(i);
      if (this.thumbsCache[i] != null) {
        src = this.thumbsCache[i];
      } else {
        contents = io.makeFile();
        src = io.makePNGURI(ui.elements, 150);
        this.thumbsCache[i] = src;
      }
      img = new Image();
      img.src = src;
      $thumb = $("<div class=\"archive-thumb\" position=\"" + i + "\"></div>");
      $thumb.prepend(img);
      $thumb.off("click").on("click", function() {
        var $self;
        $self = $(this);
        i = parseInt($self.attr("position"), 10);
        archive.goToEvent(i);
        return ui.utilities.history.refreshThumbs.call($thumb, i);
      });
      this.thumbs.push($thumb);
      return async(function() {
        if (i < archive.events.length - 1) {
          return _this._buildRecursive(Math.min(i + _this.every, archive.events.length - 1), _this.every, done);
        } else {
          return done();
        }
      });
    },
    refreshThumbs: function(i) {
      $(".archive-thumb").removeClass("future");
      return $(".archive-thumb").each(function() {
        var $self;
        $self = $(this);
        if (parseInt($self.attr("position"), 10) > i) {
          return $self.addClass("future");
        }
      });
    }
  });

  /*
  
    Tools class and organization object.
    Higher-level tool event method dispatcher and event augmentation.
    Includes template for all possible methods.
  */


  window.tools = {};

  Tool = (function() {
    function Tool(attrs) {
      var i, x;
      for (i in attrs) {
        x = attrs[i];
        this[i] = x;
      }
    }

    Tool.prototype.tearDown = function() {};

    Tool.prototype.setup = function() {};

    Tool.prototype.activateModifier = function(modifier) {};

    Tool.prototype.deactivateModifier = function(modifier) {};

    Tool.prototype.followingAngle = false;

    Tool.prototype.typeOf = function(target) {
      if (isSVGElementInMain(target)) {
        return "elem";
      } else if (isBezierControlHandle(target)) {
        return "antlerPoint";
      } else if (isPointHandle(target)) {
        return "point";
      } else if (isTransformerHandle(target)) {
        return "transformerHandle";
      } else if (isHoverTarget(target)) {
        return "hoverTarget";
      } else {
        return "background";
      }
    };

    Tool.prototype.buildEvent = function(e) {
      e.clientPosn = new Posn(e.clientX, e.clientY);
      e.canvasX = (e.clientX - ui.canvas.normal.x) / ui.canvas.zoom;
      e.canvasY = (e.clientY - ui.canvas.normal.y) / ui.canvas.zoom;
      e.canvasPosn = lab.conversions.posn.clientToCanvas(e.clientPosn);
      e.canvasPosnZoomed = lab.conversions.posn.clientToCanvasZoomed(e.clientPosn);
      if (ui.grid.visible()) {
        e = ui.snap.supplementForGrid(e);
      }
      if (ui.snap.supplementEvent != null) {
        e = ui.snap.supplementEvent(e);
      }
      e.modifierKeys = e.shiftKey || e.metaKey || e.ctrlKey || e.altKey;
      if (ui.cursor.lastPosn != null) {
        e.changeX = e.clientX - ui.cursor.lastPosn.x;
        e.changeY = -(e.clientY - ui.cursor.lastPosn.y);
        e.changeX /= ui.canvas.zoom;
        e.changeY /= ui.canvas.zoom;
        e.changeXSnapped = e.changeX + ui.cursor.snapChangeAccum.x;
        e.changeYSnapped = e.changeY + ui.cursor.snapChangeAccum.y;
      }
      e.typeOfTarget = this.typeOf(e.target);
      switch (e.typeOfTarget) {
        case "elem":
          e.elem = ui.queryElement(e.target);
          break;
        case "point":
          e.elem = queryElemByUUID(e.target.getAttribute("owner"));
          e.point = e.elem.points.at(e.target.getAttribute("at"));
          break;
        case "antlerPoint":
          e.elem = queryElemByUUID(e.target.getAttribute("owner"));
          e.point = e.elem.queryAntlerPoint(e.target);
          break;
        case "hoverTarget":
          e.elem = queryElemByUUID(e.target.getAttribute("owner"));
          e.pointA = e.elem.points.at(parseInt(e.target.getAttribute('a')));
          e.pointB = e.elem.points.at(parseInt(e.target.getAttribute('b')));
          e.hoverTarget = e.pointB.hoverTarget;
      }
      return e;
    };

    Tool.prototype.dispatch = function(e, eventType) {
      var args, key, modifier, value, _i, _len, _ref3, _ref4, _ref5;
      e = this.buildEvent(e);
      args = [e];
      if (eventType === 'startDrag') {
        _ref3 = ui.hotkeys.modifiersDown;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          modifier = _ref3[_i];
          this.activateModifier(modifier);
        }
        this.draggingType = e.typeOfTarget;
      }
      if (eventType === "doubleclick" && this.ignoreDoubleclick) {
        eventType = "click";
      }
      if (this[eventType] != null) {
        if (this[eventType][e.typeOfTarget] != null) {
          return (_ref4 = this[eventType][e.typeOfTarget]) != null ? _ref4.apply(this, args) : void 0;
        }
        _ref5 = this[eventType];
        for (key in _ref5) {
          if (!__hasProp.call(_ref5, key)) continue;
          value = _ref5[key];
          if (key.mentions(e.typeOfTarget)) {
            return value.apply(this, args);
          }
        }
        if (this[eventType].all != null) {
          return this[eventType].all.apply(this, args);
        }
      }
    };

    Tool.prototype.recalculateLastDrag = function() {
      if (ui.cursor.dragging) {
        return ui.cursor._mousemove(ui.cursor.lastEvent);
      }
    };

    return Tool;

  })();

  noop = {
    background: function(e) {},
    elem: function(e) {},
    point: function(e) {},
    antlerPoint: function(e) {},
    toolPlaceholder: function(e) {},
    hoverTarget: function(e) {}
  };

  Tool.prototype.hover = noop;

  Tool.prototype.unhover = noop;

  Tool.prototype.click = noop;

  Tool.prototype.rightClick = noop;

  Tool.prototype.mousedown = noop;

  Tool.prototype.mouseup = noop;

  Tool.prototype.startDrag = noop;

  Tool.prototype.continueDrag = noop;

  Tool.prototype.stopDrag = noop;

  /*
  
    Cursor tool
  
    Default tool that performs selection and transformation.
  
  
        #
        #   #
        #      #
        #         #
        #            #
        #               #
        #      #  #  #  #  #
        #   #
        ##
        #
  */


  tools.cursor = new Tool({
    offsetX: 1,
    offsetY: 1,
    cssid: 'cursor',
    id: 'cursor',
    tearDown: function() {
      var elem, _i, _len, _ref3, _results;
      _ref3 = ui.elements;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        elem = _ref3[_i];
        if (!ui.selection.elements.all.has(elem)) {
          _results.push(elem.hidePoints());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    initialDragPosn: void 0,
    activateModifier: function(modifier) {
      var op;
      switch (modifier) {
        case "shift":
          switch (this.draggingType) {
            case "elem":
            case "hoverTarget":
            case "point":
              op = this.initialDragPosn;
              if (op != null) {
                ui.snap.presets.every45(op);
              }
              return this.recalculateLastDrag();
          }
          break;
        case "alt":
          switch (this.draggingType) {
            case "elem":
              return 3;
          }
      }
    },
    deactivateModifier: function(modifier) {
      switch (modifier) {
        case "shift":
          switch (this.draggingType) {
            case "elem":
            case "hoverTarget":
              ui.snap.toNothing();
              return this.recalculateLastDrag();
          }
          break;
        case "alt":
          switch (this.draggingType) {
            case "elem":
              return 3;
          }
      }
    },
    hover: {
      background: function(e) {
        var elem, _i, _len, _ref3;
        _ref3 = ui.elements;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          if (typeof elem.hidePoints === "function") {
            elem.hidePoints();
          }
        }
        return ui.unhighlightHoverTargets();
      },
      elem: function(e) {
        return e.elem.hover();
        /*
        if not ui.selection.elements.all.has e.elem
          e.elem.hover()
        
          if e.elem.group?
            e.elem.group.map (elem) -> elem.showPoints()
        
        ui.unhighlightHoverTargets()
        */

      },
      point: function(e) {
        if (!ui.selection.elements.all.has(e.elem)) {
          e.elem.unhoverPoints();
          e.elem.showPoints();
          return ui.unhighlightHoverTargets();
        }
      },
      antlerPoint: function(e) {},
      hoverTarget: function(e) {
        if (!ui.selection.elements.all.has(e.elem)) {
          e.elem.unhoverPoints();
          e.elem.showPoints();
          return e.hoverTarget.highlight();
        }
      }
    },
    unhover: {
      background: function(e) {},
      elem: function(e) {
        return e.elem.unhover();
      },
      point: function(e) {
        return e.elem.hidePoints();
      },
      antlerPoint: function(e) {},
      hoverTarget: function(e) {
        if (e.currentHover !== e.elem.rep) {
          e.elem.unhoverPoints();
          e.elem.hidePoints();
        }
        return e.hoverTarget.unhighlight();
      }
    },
    click: {
      background: function(e) {
        if (!e.modifierKeys) {
          ui.selection.elements.deselectAll();
        }
        return ui.selection.points.deselectAll();
      },
      elem: function(e) {
        var elem, selected;
        elem = e.elem;
        selected = ui.selection.elements.all.has(elem);
        ui.selection.points.deselectAll();
        if (e.shiftKey) {
          if (selected) {
            ui.selection.elements.deselect(elem);
            elem.showPoints();
            elem.hover();
          } else {
            if (elem.group != null) {
              ui.selectMore(elem.group.elements);
            } else {
              ui.selection.elements.selectMore(elem);
              elem.unhover();
              elem.removePoints();
            }
          }
        } else {
          if (!selected) {
            if (elem.group != null) {
              ui.selection.elements.select(elem.group.elements);
              elem.group.map(function(elem) {
                return elem.removePoints();
              });
            } else {
              ui.selection.elements.select(elem);
              elem.unhover();
              elem.removePoints();
            }
          }
        }
        return ui.unhighlightHoverTargets();
      },
      point: function(e) {
        if (e.shiftKey) {
          return ui.selection.points.selectMore(e.point);
        } else {
          return ui.selection.points.select(e.point);
        }
      },
      antlerPoint: function(e) {},
      hoverTarget: function(e) {
        ui.selection.points.selectMore(e.hoverTarget.a);
        return ui.selection.points.selectMore(e.hoverTarget.b);
      }
    },
    doubleclick: {
      elem: function(e) {
        trackEvent("Text", "Doubleclick edit");
        if (e.elem instanceof Text) {
          return e.elem.selectAll();
        }
      }
    },
    startDrag: {
      background: function(e) {
        return ui.dragSelection.start(new Posn(e));
      },
      elem: function(e) {
        var elem, _i, _len, _ref3;
        e.elem.unhover();
        ui.selection.points.deselectAll();
        ui.unhighlightHoverTargets();
        if (!ui.selection.elements.all.has(e.elem)) {
          if (e.elem.group != null) {
            ui.selection.elements.select(e.elem.group.elements);
          } else {
            ui.selection.elements.select(e.elem);
          }
        }
        _ref3 = ui.selection.elements.all;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          elem.removePoints();
        }
        ui.selection.elements.all.map(function(elem) {
          return elem.commit();
        });
        return this.guidePointA = ui.transformer.center();
      },
      antlerPoint: function(e) {},
      point: function(e) {
        var _ref3;
        if ((_ref3 = e.point.antlers) != null) {
          _ref3.show();
        }
        e.point.owner.removeHoverTargets();
        ui.selection.points.select(e.point);
        if (ui.selection.elements.all.has(e.elem && ui.hotkeys.modifiersDown.has("alt"))) {
          return e.elem.clone().appendTo('#main');
        }
      },
      transformerHandle: function(e) {},
      hoverTarget: function(e) {
        if (!ui.selection.elements.all.has(e.elem)) {
          e.hoverTarget.active();
          ui.selection.elements.deselectAll();
          ui.selection.points.deselectAll();
          return this.guidePointA = ui.transformer.center();
        }
      }
    },
    snapChange: {
      x: 0,
      y: 0
    },
    changeAccum: {
      x: 0,
      y: 0
    },
    continueDrag: {
      background: function(e) {
        return ui.dragSelection.move(new Posn(e.clientX, e.clientY));
      },
      elem: function(e) {
        var ac, bl, nbl;
        e.elem.removePoints();
        ac = this.snapChange;
        if (ac.x !== 0 && ac.y !== 0) {
          ui.selection.nudge(-ac.x, -ac.y);
        }
        ui.selection.nudge(e.changeX + this.changeAccum.x, e.changeY + this.changeAccum.y, false);
        if (ui.grid.visible()) {
          bl = ui.transformer.bl;
          nbl = ui.snap.snapPointToGrid(bl.clone());
          this.snapChange = {
            x: nbl.x - bl.x,
            y: bl.y - nbl.y
          };
          if (this.snapChange.x === -e.changeX) {
            this.changeAccum.x += e.changeX;
          } else {
            this.changeAccum.x = 0;
          }
          if (this.snapChange.y === -e.changeY) {
            this.changeAccum.y += e.changeY;
          } else {
            this.changeAccum.y = 0;
          }
          return ui.selection.nudge(this.snapChange.x, this.snapChange.y, false);
        }
      },
      point: function(e) {
        var _ref3;
        if (ui.selection.elements.all.has(e.elem)) {
          return this.continueDrag.elem(e);
        }
        e.point.nudge(e.changeX, e.changeY);
        if ((_ref3 = e.point.antlers) != null) {
          _ref3.refresh();
        }
        e.elem.woohoo();
        return e.elem.commit();
      },
      antlerPoint: function(e) {
        e.point.nudge(e.changeX, e.changeY);
        return e.elem.commit();
      },
      transformerHandle: function(e) {
        return ui.transformer.drag(e);
      },
      hoverTarget: function(e) {
        if (ui.selection.elements.all.has(e.elem)) {
          return this.continueDrag.elem.call(tools.cursor, e);
        } else {
          return e.hoverTarget.nudge(e.changeX, e.changeY);
        }
      }
    },
    stopDrag: {
      background: function(e) {
        return ui.dragSelection.end(function(b) {
          return ui.selection.elements.selectWithinBounds(b);
        });
      },
      elem: function(e) {
        var elem, nudge, _i, _len, _ref3;
        _ref3 = ui.selection.elements.all;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          elem.redrawHoverTargets();
          elem.commit();
        }
        nudge = new Posn(e).subtract(ui.cursor.lastDown);
        nudge.setZoom(ui.canvas.zoom);
        if (this.duping) {
          archive.addExistenceEvent(this.duping.rep);
        } else {
          archive.addMapEvent("nudge", ui.selection.elements.zIndexes(), {
            x: nudge.x,
            y: -nudge.y
          });
        }
        return this.changeAccum = {
          x: 0,
          y: 0
        };
      },
      point: function(e) {
        var nudge;
        e.elem.redrawHoverTargets();
        e.elem.clearCachedObjects();
        nudge = new Posn(e).subtract(ui.cursor.lastDown);
        nudge.setZoom(ui.canvas.zoom);
        return archive.addMapEvent("nudge", ui.selection.points.zIndexes(), {
          x: nudge.x,
          y: -nudge.y
        });
      },
      antlerPoint: function(e) {
        var nudge;
        e.elem.redrawHoverTargets();
        nudge = new Posn(e).subtract(ui.cursor.lastDown);
        nudge.setZoom(ui.canvas.zoom);
        return archive.addMapEvent("nudge", ui.selection.points.zIndexes(), {
          x: nudge.x,
          y: -nudge.y,
          antler: (e.point.role === -1 ? "p3" : "p2")
        });
      },
      transformerHandle: function(e) {
        var elem, _i, _len, _ref3;
        ui.utilities.transform.refresh();
        _ref3 = ui.selection.elements.all;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          elem.redrawHoverTargets();
        }
        archive.addMapEvent("scale", ui.selection.elements.zIndexes(), {
          x: ui.transformer.accumX,
          y: ui.transformer.accumY,
          origin: ui.transformer.origin
        });
        return ui.transformer.resetAccum();
      },
      hoverTarget: function(e) {
        var eventData, nudge, zi;
        e.elem.redrawHoverTargets();
        e.elem.clearCachedObjects();
        ui.selection.points.selectMore(e.hoverTarget.a);
        ui.selection.points.selectMore(e.hoverTarget.b);
        nudge = new Posn(e).subtract(ui.cursor.lastDown);
        eventData = {};
        zi = e.elem.zIndex();
        eventData[zi] = [];
        eventData[zi].push(e.hoverTarget.a.at, e.hoverTarget.b.at);
        return archive.addMapEvent("nudge", eventData, {
          x: nudge.x,
          y: -nudge.y
        });
      }
    }
  });

  /*
  
    Paw tool
  
    Pan around.
  */


  tools.paw = new Tool({
    offsetX: 8,
    offsetY: 8,
    id: 'paw',
    cssid: 'paw',
    setup: function() {
      if (isNaN(ui.canvas.normal.x)) {
        ui.canvas.normal.x = 0;
      }
      if (isNaN(ui.canvas.normal.y)) {
        return ui.canvas.normal.y = 0;
      }
    },
    tearDown: function() {},
    continueDrag: {
      all: function(e) {
        return ui.canvas.nudge(e.changeX * ui.canvas.zoom, e.changeY * ui.canvas.zoom);
      }
    },
    mousedown: {
      all: function() {
        return dom.toolCursorPlaceholder.setAttribute('tool', 'paw-clutch');
      }
    },
    mouseup: {
      all: function() {
        return dom.toolCursorPlaceholder.setAttribute('tool', 'paw');
      }
    }
  });

  /*
  
    Pen tool
  
    Polygon/path-drawing tool
  
  
              #
              #
  */


  tools.pen = new Tool({
    offsetX: 5,
    offsetY: 0,
    cssid: 'pen',
    id: 'pen',
    ignoreDoubleclick: true,
    tearDown: function() {
      if (this.drawing) {
        ui.selection.elements.select(this.drawing);
        this.drawing.redrawHoverTargets();
        this.drawing.points.map(function(p) {
          if (typeof p.hideHandles === "function") {
            p.hideHandles();
          }
          return p.hide();
        });
        this.drawing = false;
      }
      return this.clearPoints();
    },
    drawing: false,
    firstPoint: null,
    lastPoint: null,
    currentPoint: null,
    clearPoints: function() {
      this.firstPoint = null;
      this.currentPoint = null;
      return this.lastPoint = null;
    },
    beginNewShape: function(e) {
      var shape;
      if ((ui.uistate.get('strokeWidth') > 0) && (ui.stroke.toString() === "none")) {
        ui.stroke.absorb(ui.colors.black);
      }
      shape = new Path({
        stroke: ui.stroke,
        fill: ui.fill,
        'stroke-width': ui.uistate.get('strokeWidth'),
        d: "M" + e.canvasX + "," + e.canvasY
      });
      shape.appendTo('#main');
      shape.commit().showPoints();
      archive.addExistenceEvent(shape.rep);
      this.drawing = shape;
      this.firstPoint = shape.points.first;
      return this.currentPoint = this.firstPoint;
    },
    endShape: function() {
      this.drawing.points.close().hide();
      this.drawing.commit();
      this.drawing.redrawHoverTargets();
      this.drawing.points.first.antlers.basep3 = null;
      this.drawing = false;
      return this.clearPoints();
    },
    addStraightPoint: function(x, y) {
      var last, point, succp2, _ref3;
      last = this.drawing.points.last;
      succp2 = last.antlers.succp2;
      if (((_ref3 = this.drawing.points.last.antlers) != null ? _ref3.succp2 : void 0) != null) {
        if (last instanceof CurvePoint && succp2.x !== last.x && succp2.y !== last.y) {
          point = new SmoothTo(x, y, x, y, this.drawing, last);
        } else {
          point = new CurveTo(last.antlers.succp2.x, last.antlers.succp2.y, x, y, x, y, this.drawing, last);
        }
      } else {
        point = new LineTo(x, y, this.drawing);
      }
      this.drawing.points.push(point);
      if (typeof last.hideHandles === "function") {
        last.hideHandles();
      }
      this.drawing.hidePoints();
      point.draw();
      archive.addPointExistenceEvent(this.drawing.zIndex(), point);
      this.drawing.commit().showPoints();
      return this.currentPoint = point;
    },
    addCurvePoint: function(x, y) {
      var last, point, x2, y2, _ref3;
      x2 = x;
      y2 = y;
      last = this.drawing.points.last;
      if (typeof last.hideHandles === "function") {
        last.hideHandles();
      }
      point = new CurveTo(last.x, last.y, x, y, x, y, this.drawing, this.drawing.points.last);
      this.drawing.points.push(point);
      if (((_ref3 = last.antlers) != null ? _ref3.succp2 : void 0) != null) {
        point.x2 = point.prec.antlers.succp2.x;
        point.y2 = point.prec.antlers.succp2.y;
      }
      if (typeof last.hideHandles === "function") {
        last.hideHandles();
      }
      this.drawing.hidePoints();
      point.draw();
      archive.addPointExistenceEvent(this.drawing.zIndex(), point);
      this.drawing.commit().showPoints();
      return this.currentPoint = point;
    },
    updateCurvePoint: function(e) {
      this.currentPoint.antlers.importNewSuccp2(new Posn(e.canvasX, e.canvasY));
      if (this.drawing.points.closed) {
        this.currentPoint.antlers.show();
        this.currentPoint.antlers.succp.persist();
      }
      this.currentPoint.antlers.lockAngle = true;
      this.currentPoint.antlers.show();
      this.currentPoint.antlers.refresh();
      return this.drawing.commit();
    },
    leaveShape: function(e) {
      return this.drawing = false;
    },
    hover: {
      point: function(e) {
        var undo,
          _this = this;
        if (this.drawing) {
          switch (e.point) {
            case this.lastPoint:
              e.point.actionHint();
              undo = e.point.antlers.hideTemp(2);
              return this.unhover.point = function() {
                undo();
                e.point.hideActionHint();
                return _this.unhover.point = function() {};
              };
            case this.firstPoint:
              e.point.actionHint();
              return this.unhover.point = function() {
                e.point.hideActionHint();
                return _this.unhover.point = function() {};
              };
          }
        }
      }
    },
    unhover: {},
    click: {
      background_elem: function(e) {
        if (!this.drawing) {
          return this.beginNewShape(e);
        } else {
          return this.addStraightPoint(e.canvasX, e.canvasY);
        }
      },
      point: function(e) {
        switch (e.point) {
          case this.lastPoint:
            return e.point.antlers.killSuccp2();
          case this.firstPoint:
            this.drawing.points.close();
            this.addStraightPoint(e.point.x, e.point.y);
            this.drawing.points.last.antlers.importNewSuccp2(this.drawing.points.first.antlers.succp2);
            this.drawing.points.last.antlers.lockAngle = true;
            return this.endShape();
          default:
            return this.click.background_elem.call(this, e);
        }
      }
    },
    mousedown: {
      all: function() {
        if ((this.currentPoint != null) && this.snapTo45) {
          return ui.snap.presets.every45((this.currentPoint != null ? this.currentPoint : this.lastPoint), "canvas");
        }
      }
    },
    activateModifier: function(modifier) {
      switch (modifier) {
        case "shift":
          this.snapTo45 = true;
          if ((this.currentPoint != null) || (this.lastPoint != null)) {
            return ui.snap.presets.every45((this.currentPoint != null ? this.currentPoint : this.lastPoint), "canvas");
          }
      }
    },
    deactivateModifier: function(modifier) {
      switch (modifier) {
        case "shift":
          this.snapTo45 = false;
          return ui.snap.toNothing();
      }
    },
    snapTo45: false,
    startDrag: {
      point: function(e) {
        if (e.point === this.firstPoint) {
          this.drawing.points.close();
          return this.addCurvePoint(e.point.x, e.point.y);
        } else {
          return this.startDrag.all(e);
        }
      },
      all: function(e) {
        if (this.drawing) {
          return this.addCurvePoint(e.canvasX, e.canvasY);
        } else {
          return this.beginNewShape(e);
        }
      }
    },
    continueDrag: {
      all: function(e, change) {
        if (this.drawing) {
          return this.updateCurvePoint(e);
        }
      }
    },
    stopDrag: {
      all: function(e) {
        if (this.drawing.points.closed) {
          this.currentPoint.deselect().hide();
          this.endShape();
        }
        this.lastPoint = this.currentPoint;
        return this.currentPoint = null;
      }
    }
  });

  /*
  
    Crayon plz
  */


  tools.crayon = new Tool({
    offsetX: 5,
    offsetY: 0,
    cssid: 'crayon',
    id: 'crayon',
    drawing: false,
    setup: function() {},
    tearDown: function() {},
    frequency: 0,
    eventCounter: 0,
    alternatingCounter: 2,
    beginNewLine: function(e) {
      var line;
      line = new Path({
        stroke: ui.stroke,
        fill: ui.fill,
        'stroke-width': ui.uistate.get('strokeWidth'),
        d: "M" + e.canvasX + "," + e.canvasY
      });
      line.appendTo('#main');
      line.commit().showPoints();
      this.line = line;
      return this.currentPoint = this.line.points.first;
    },
    determineControlPoint: function(which) {
      var angleBB, angleDesired, compareA, compareB, desiredHandle, lB33A, lBBA, lastBaseTo33, lastBaseToNewBase, lenBB, lenDesired, stashed, _ref3, _ref4;
      switch (which) {
        case "p2":
          _ref3 = [this.lastPoint, this.currentPoint, this.stashed33], compareA = _ref3[0], compareB = _ref3[1], stashed = _ref3[2];
          break;
        case "p3":
          _ref4 = [this.currentPoint, this.lastPoint, this.stashed66], compareA = _ref4[0], compareB = _ref4[1], stashed = _ref4[2];
      }
      lastBaseToNewBase = new LineSegment(compareA, compareB);
      lastBaseTo33 = new LineSegment(compareA, stashed);
      lBBA = lastBaseToNewBase.angle360();
      lB33A = lastBaseTo33.angle360();
      angleBB = lB33A - lBBA;
      angleDesired = lBBA + angleBB * 2;
      lenBB = lastBaseToNewBase.length;
      lenDesired = lenBB / 3;
      desiredHandle = new Posn(compareA);
      desiredHandle.nudge(0, -lenDesired);
      desiredHandle.rotate(angleDesired + 180, compareA);
      if (isNaN(desiredHandle.x)) {
        desiredHandle.x = compareB.x;
      }
      if (isNaN(desiredHandle.y)) {
        desiredHandle.y = compareB.y;
      }
      return desiredHandle;
    },
    stashedBaseP3: void 0,
    addPoint: function(e) {
      switch (this.alternatingCounter) {
        case 1:
          this.lastPoint = this.currentPoint;
          if (e != null) {
            this.currentPoint = new CurveTo(e.canvasX, e.canvasY, e.canvasX, e.canvasY, e.canvasX, e.canvasY, this.line);
          }
          this.alternatingCounter = 2;
          if (this.stashed33 == null) {
            return;
          }
          this.lastPoint.antlers.succp2 = this.determineControlPoint('p2');
          this.currentPoint.antlers.basep3 = this.determineControlPoint('p3');
          this.lastPoint.succ = this.currentPoint;
          this.lastPoint.antlers.flatten();
          this.lastPoint.antlers.commit();
          this.currentPoint.antlers.commit();
          this.line.points.push(this.currentPoint);
          this.currentPoint.draw();
          this.line.points.hide();
          return this.line.commit();
        case 2:
          this.stashed33 = e.canvasPosnZoomed;
          return this.alternatingCounter = 3;
        case 3:
          this.stashed66 = e.canvasPosnZoomed;
          return this.alternatingCounter = 1;
      }
    },
    click: {
      all: function() {}
    },
    startDrag: {
      all: function(e) {
        return this.beginNewLine(e);
      }
    },
    continueDrag: {
      all: function(e) {
        if (this.eventCounter === this.frequency) {
          this.addPoint(e);
          return this.eventCounter = 0;
        } else {
          return this.eventCounter += 1;
        }
      }
    },
    stopDrag: {
      all: function() {
        this.line.redrawHoverTargets();
        archive.addExistenceEvent(this.line.rep);
        return this.line = void 0;
      }
    }
  });

  /*
  
  
     o
      \
       \
        \
         \
          \
           \
            \
             \
              o
  */


  tools.line = new Tool({
    drawing: false,
    cssid: 'crosshair',
    id: 'line',
    offsetX: 7,
    offsetY: 7,
    activateModifier: function(modifier) {
      var op;
      switch (modifier) {
        case "shift":
          op = this.initialDragPosn;
          if (op != null) {
            return ui.snap.presets.every45(op, "canvas");
          }
      }
    },
    deactivateModifier: function(modifier) {
      switch (modifier) {
        case "shift":
          return ui.snap.toNothing();
      }
    },
    tearDown: function() {
      return this.drawing = false;
    },
    startDrag: {
      all: function(e) {
        this.beginNewLine(e);
        return this.initialDragPosn = e.canvasPosnZoomed;
      }
    },
    beginNewLine: function(e) {
      var p;
      p = e.canvasPosnZoomed;
      this.drawing = new Path({
        stroke: ui.stroke,
        fill: ui.fill,
        'stroke-width': ui.uistate.get('strokeWidth'),
        d: "M" + e.canvasX + "," + e.canvasY + " L" + e.canvasX + "," + e.canvasY
      });
      this.drawing.appendTo('#main');
      return this.drawing.commit();
    },
    continueDrag: {
      all: function(e) {
        var p;
        p = e.canvasPosnZoomed;
        this.drawing.points.last.x = p.x;
        this.drawing.points.last.y = p.y;
        return this.drawing.commit();
      }
    },
    stopDrag: {
      all: function() {
        this.drawing.redrawHoverTargets();
        this.drawing.commit();
        return ui.selection.elements.select(this.drawing);
      }
    }
  });

  /*
  
    Arbitrary Shape Tool
  
    A subclass of Tool that performs a simple action: draw a hard-coded shape
    from the startDrag point to the endDrag point.
  
    Basically this is an abstraction. It's used by the Ellipse and Rectangle tools.
  */


  ArbitraryShapeTool = (function(_super) {
    __extends(ArbitraryShapeTool, _super);

    function ArbitraryShapeTool(attrs) {
      ArbitraryShapeTool.__super__.constructor.call(this, attrs);
    }

    ArbitraryShapeTool.prototype.drawing = false;

    ArbitraryShapeTool.prototype.cssid = 'crosshair';

    ArbitraryShapeTool.prototype.offsetX = 7;

    ArbitraryShapeTool.prototype.offsetY = 7;

    ArbitraryShapeTool.prototype.ignoreDoubleclick = true;

    ArbitraryShapeTool.prototype.started = null;

    ArbitraryShapeTool.prototype.template = null;

    ArbitraryShapeTool.prototype.tearDown = function() {
      return this.drawing = false;
    };

    ArbitraryShapeTool.prototype.startDrag = {
      all: function(e) {
        this.started = e.canvasPosnZoomed;
        this.drawing = new Path({
          stroke: ui.stroke.clone(),
          fill: ui.fill.clone(),
          'stroke-width': ui.uistate.get('strokeWidth'),
          d: this.template
        });
        this.drawing.virgin = this.virgin();
        this.drawing.hide();
        this.drawing.appendTo("#main");
        return this.drawing.commit();
      }
    };

    ArbitraryShapeTool.prototype.continueDrag = {
      all: function(e) {
        var ftb;
        ftb = new Bounds(e.canvasPosnZoomed, this.started);
        if (e.shiftKey) {
          ftb = new Bounds(this.started, e.canvasPosnZoomed.squareUpAgainst(this.started));
        }
        if (e.altKey) {
          ftb.centerOn(this.started);
          ftb.scale(2, 2, this.started);
        }
        this.drawing.show();
        this.drawing.fitToBounds(ftb);
        return this.drawing.commit();
      }
    };

    ArbitraryShapeTool.prototype.stopDrag = {
      all: function() {
        this.drawing.cleanUpPoints();
        archive.addExistenceEvent(this.drawing.rep);
        this.drawing.redrawHoverTargets();
        ui.selection.elements.select(this.drawing);
        return this.drawing = false;
      }
    };

    return ArbitraryShapeTool;

  })(Tool);

  /*
  
    Ellipse
  */


  tools.ellipse = new ArbitraryShapeTool({
    id: "ellipse",
    template: "M0-0.1c0.055228,0,0.1,0.045,0.1,0.1S0.055,0.1,0,0.1S-0.1,0.055-0.1,0S-0.055-0.1,0-0.1z",
    virgin: function() {
      return new Ellipse({
        cx: 0.0,
        cy: 0.0,
        rx: 0.1,
        ry: 0.1
      });
    }
  });

  /*
  
    Ellipse
  */


  tools.rectangle = new ArbitraryShapeTool({
    id: "rectangle",
    template: "M-0.1,-0.1 L0.1,-0.1 L0.1,0.1 L-0.1,0.1 L-0.1,-0.1z",
    virgin: function() {
      return new Rect({
        x: -0.1,
        y: -0.1,
        width: 0.2,
        height: 0.2
      });
    }
  });

  /*
  
    Type tool
  */


  tools.type = new Tool({
    cssid: 'type',
    id: 'type',
    typingInto: void 0,
    tearDown: function() {
      return this.typingInto = void 0;
    },
    addNode: function(e) {
      if (this.typingInto != null) {
        this.typingInto.displayMode();
        archive.addExistenceEvent(this.typingInto.rep);
        return this.typingInto = void 0;
      } else {
        ui.selection.elements.deselectAll();
        this.typingInto = new Text({
          x: e.canvasPosnZoomed.x,
          y: e.canvasPosnZoomed.y,
          fill: ui.fill,
          stroke: ui.stroke
        });
        this.typingInto.appendTo('#main');
        return this.typingInto.selectAll();
      }
    },
    click: {
      elem: function(e) {
        if (e.elem.type === "text") {
          e.elem.editableMode();
          return e.elem.textEditable.focus();
        } else {
          return this.click.all.call(tools.type, e);
        }
      },
      all: function(e) {
        return this.addNode(e);
      }
    },
    startDrag: {
      elem: function(e) {
        console.log(e.elem);
        if (e.elem.type === "text") {
          e.elem.editableMode();
          return e.elem.textEditable.focus();
        }
      }
    },
    stopDrag: {
      all: function(e) {
        var _ref3;
        if (((_ref3 = e.elem) != null ? _ref3.type : void 0) !== "text") {
          return this.addNode(e);
        }
      }
    }
  });

  /*
  
    Rotate
  */


  tools.rotate = new Tool({
    cssid: 'crosshair',
    id: 'rotate',
    offsetX: 7,
    offsetY: 7,
    setup: function() {
      var _this = this;
      this.$rndo = $("#r-nd-o");
      ui.transformer.onRotatingMode();
      this.setCenter(ui.transformer.center());
      return ui.selection.elements.on('changed', function() {
        return _this.$rndo.hide();
      });
    },
    tearDown: function() {
      this.setCenter(void 0);
      return ui.transformer.offRotatingMode();
    },
    lastAngle: void 0,
    setCenter: function(center) {
      this.center = center;
      if (ui.selection.elements.all.length === 0) {
        return;
      }
      if (this.center != null) {
        return this.$rndo.show().css({
          left: (this.center.x - 6).px(),
          top: (this.center.y - 6).px()
        });
      } else {
        return this.$rndo.hide();
      }
    },
    click: {
      all: function(e) {
        return this.setCenter(new Posn(e.canvasX, e.canvasY));
      }
    },
    startDrag: {
      all: function(e) {
        if (this.center === void 0) {
          this.setCenter(ui.transformer.center());
        }
        return this.lastAngle = new Posn(e.canvasX, e.canvasY);
      }
    },
    continueDrag: {
      all: function(e) {
        var change, currentAngle;
        currentAngle = new Posn(e.canvasX, e.canvasY).angle360(this.center);
        change = currentAngle - this.lastAngle;
        if (!isNaN(change)) {
          ui.selection.rotate(change, this.center);
        }
        return this.lastAngle = currentAngle;
      }
    },
    stopDrag: {
      all: function(e) {
        this.lastAngle = void 0;
        ui.selection.elements.all.map(function(p) {
          return p.redrawHoverTargets();
        });
        archive.addMapEvent("rotate", ui.selection.elements.zIndexes(), {
          angle: ui.transformer.accumA,
          origin: ui.transformer.origin
        });
        return ui.transformer.resetAccum();
      }
    }
  });

  /*
  
    Zoom tool
  */


  tools.zoom = new Tool({
    offsetX: 5,
    offsetY: 5,
    cssid: 'zoom',
    id: 'zoom',
    ignoreDoubleclick: true,
    click: {
      all: function(e) {
        if (ui.hotkeys.modifiersDown.has("alt")) {
          ui.canvas.zoom100();
        } else {
          ui.canvas.zoomIn();
        }
        ui.window.centerOn(new Posn(e.canvasX, e.canvasY));
        return ui.refreshAfterZoom();
      }
    },
    rightClick: {
      all: function(e) {
        if (ui.hotkeys.modifiersDown.has("alt")) {
          ui.canvas.zoom100();
        } else {
          ui.canvas.zoomOut();
        }
        ui.window.centerOn(new Posn(e.canvasX, e.canvasY));
        return ui.refreshAfterZoom();
      }
    },
    startDrag: {
      all: function(e) {
        return ui.dragSelection.start(new Posn(e));
      }
    },
    continueDrag: {
      all: function(e) {
        return ui.dragSelection.move(new Posn(e));
      }
    },
    stopDrag: {
      all: function(e) {
        var elem, _i, _len, _ref3, _results;
        if (ui.hotkeys.modifiersDown.has("alt")) {
          ui.dragSelection.end(function() {
            return ui.canvas.zoom100();
          });
        } else if (e.which === 1) {
          ui.dragSelection.end(function(r) {
            return ui.canvas.zoomToFit(r);
          });
        } else if (e.which === 3) {
          ui.dragSelection.end(function() {
            return ui.canvas.zoomOut();
          });
        }
        _ref3 = ui.elements;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          _results.push(elem.refreshUI());
        }
        return _results;
      }
    }
  });

  /*
  
    Eyedropper
  */


  tools.eyedropper = new Tool({
    offsetX: 1,
    offsetY: 15,
    cssid: 'eyedropper',
    id: 'eyedropper',
    click: {
      elem_hoverTarget_point: function(e) {
        var elem, _i, _len, _ref3, _results;
        ui.utilities.color.sample(e.elem);
        _ref3 = ui.selection.elements.all;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          _results.push(elem.eyedropper(e.elem));
        }
        return _results;
      },
      background: function(e) {
        var elem, _i, _len, _ref3, _results;
        _ref3 = ui.selection.elements.all;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          elem = _ref3[_i];
          elem.data.fill = ui.colors.white;
          elem.data.stroke = ui.colors["null"];
          _results.push(elem.commit());
        }
        return _results;
      }
    }
  });

  /*
  
    A modular frontend for the file storage service API.
    Communicates with the backend version in Meowset.
  
    Basically just does AJAX calls.
  */


  window.services = {};

  Service = (function() {
    function Service(attrs) {
      var i, x,
        _this = this;
      for (i in attrs) {
        if (!__hasProp.call(attrs, i)) continue;
        x = attrs[i];
        this[i] = x;
      }
      if (this.setup != null) {
        setup.push(function() {
          return _this.setup();
        });
      }
    }

    Service.prototype.fileSystem = {
      contents: {},
      is_dir: true,
      path: "/"
    };

    Service.prototype.open = function() {
      return ui.gallery.open(this);
    };

    Service.prototype.getSVGs = function(ok) {
      var _this = this;
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/svgs",
        type: "GET",
        dataType: "json",
        data: {
          session_token: ui.account.session_token
        },
        success: function(response) {
          return ok(response.map(function(f) {
            var fl;
            fl = new File().fromService(_this)(f.key);
            fl.modified = f.last_modified;
            fl.thumbnail = f.thumbnail;
            return fl;
          }));
        }
      });
    };

    Service.prototype.getSaveLocations = function(at, success) {
      var all, dir, files, folders, path, traversed, _i, _len;
      path = at.split("/").slice(1);
      traversed = this.fileSystem.contents;
      if (path[0] !== "") {
        for (_i = 0, _len = path.length; _i < _len; _i++) {
          dir = path[_i];
          dir = path[0];
          if (traversed[dir] != null) {
            traversed = traversed[dir].contents;
            if (Object.keys(traversed).length !== 0) {
              path = path.slice(1);
            } else {
              break;
            }
          }
        }
      }
      if (path.length === 0) {
        if (traversed.empty) {
          folders = [];
          files = [];
        } else {
          all = objectValues(traversed);
          folders = all.filter(function(x) {
            return x.is_dir;
          });
          files = all.filter(function(x) {
            return !x.is_dir;
          });
        }
        return success(folders, files);
      } else {
        return $.ajax({
          url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/metadata",
          type: "GET",
          dataType: "json",
          data: {
            session_token: ui.account.session_token,
            path: at,
            pluck: "save_locations",
            contentsonly: true
          },
          success: function(response) {
            var file, folder, _j, _k, _len1, _len2;
            folders = response.filter(function(x) {
              return x.is_dir;
            });
            files = response.filter(function(x) {
              return !x.is_dir;
            });
            if (folders.length + files.length === 0) {
              traversed.empty = true;
            } else {
              for (_j = 0, _len1 = folders.length; _j < _len1; _j++) {
                folder = folders[_j];
                traversed[folder.path.match(/\/[^\/]*$/)[0].substring(1)] = {
                  contents: {},
                  is_dir: true,
                  path: "" + folder.path
                };
              }
            }
            for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
              file = files[_k];
              traversed[file.path.match(/\/[^\/]*$/)[0].substring(1)] = {
                is_dir: false,
                path: "" + file.path
              };
            }
            return success(folders, files);
          }
        });
      }
    };

    Service.prototype.get = function(key, success) {
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/get",
        type: "GET",
        dataType: "json",
        data: {
          session_token: ui.account.session_token,
          path: key
        },
        success: function(response) {
          return success(response);
        }
      });
    };

    Service.prototype.put = function(key, contents, success) {
      if (success == null) {
        success = function() {};
      }
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/put",
        type: "POST",
        dataType: "json",
        data: {
          contents: contents,
          session_token: ui.account.session_token,
          fn: key
        },
        success: function(response) {
          return success(response);
        }
      });
    };

    Service.prototype.contents = function(path, success) {
      if (success == null) {
        success = function() {};
      }
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/metadata",
        type: "GET",
        dataType: "json",
        data: {
          contentsonly: true,
          session_token: ui.account.session_token,
          path: path
        },
        success: function(response) {
          return success(response);
        }
      });
    };

    Service.prototype.defaultName = function(path, success) {
      if (success == null) {
        success = function() {};
      }
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/default-name",
        type: "GET",
        dataType: "json",
        data: {
          session_token: ui.account.session_token,
          path: path
        },
        success: function(response) {
          return success(response.name);
        }
      });
    };

    Service.prototype.putHistory = function(key, contents, success) {
      if (success == null) {
        success = function() {};
      }
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/" + this.module + "/put-history",
        type: "POST",
        dataType: "json",
        data: {
          contents: contents,
          session_token: ui.account.session_token,
          fn: key
        },
        success: function(response) {
          return success(response);
        }
      });
    };

    return Service;

  })();

  /*
  
    Storing files in localStorage!
    SVG files are so lightweight that for now we'll just do this as a nice
    2.5mb local storage solution, since only Google has the balls to implement
    the FileSystem API.
  */


  services.local = new Service({
    name: "local",
    setup: function() {
      var contents, f, title, _results;
      if (localStorage.getItem("local-files") === null) {
        localStorage.setItem("local-files", "[]");
        localStorage.removeItem("file-content");
        localStorage.removeItem("file-metadata");
        _results = [];
        for (title in demoFiles) {
          contents = demoFiles[title];
          _results.push(f = new LocalFile("" + title + ".svg").set(contents).put());
        }
        return _results;
      }
    },
    activate: function() {},
    lastKey: void 0,
    getSVGs: function(ok) {
      var files, name, _i, _len, _ref3;
      if (ok == null) {
        ok = function() {};
      }
      files = [];
      _ref3 = this.files();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        name = _ref3[_i];
        files.push(new LocalFile(name));
      }
      return ok(files);
    },
    getSaveLocations: function(path, ok) {
      if (ok == null) {
        ok = function() {};
      }
      return ok({}, this.files().map(function(f) {
        return {
          path: "/" + f
        };
      }));
    },
    get: function(key, ok) {
      var archiveData, file;
      file = localStorage.getItem("local-" + key);
      archiveData = localStorage.getItem("local-" + key + "-archive");
      if (file !== null) {
        return ok({
          contents: file,
          archive: archiveData
        });
      } else {

      }
    },
    put: function(name, contents, ok) {
      var files;
      if (name == null) {
        name = ui.file.name;
      }
      if (contents == null) {
        contents = io.makeFile();
      }
      if (ok == null) {
        ok = function() {};
      }
      name = name.replace(/^\//gi, '');
      localStorage.setItem("local-" + name, contents);
      localStorage.setItem("local-" + name + "-archive", archive.toString());
      files = this.files();
      if (!files.has(name)) {
        files.push(name);
      }
      this.files(files);
      return ok();
    },
    "delete": function(name) {
      var files;
      localStorage.removeItem("local-" + name);
      localStorage.removeItem("local-" + name + "-archive");
      files = this.files();
      files = files.remove(name);
      return this.files(files);
    },
    deleteAll: function() {
      var _this = this;
      return this.files().map(function(name) {
        return _this["delete"](name);
      });
    },
    files: function(updated) {
      if (updated != null) {
        localStorage.setItem("local-files", JSON.stringify(updated));
        return updated;
      } else {
        return JSON.parse(localStorage.getItem("local-files"));
      }
    },
    nextDefaultName: function() {
      var files, nums, untitleds, x;
      files = this.files();
      untitleds = files.filter(function(f) {
        return f.substring(0, 9) === "untitled-";
      });
      nums = untitleds.map(function(name) {
        return name.match(/\d+/gi)[0];
      }).map(function(num) {
        return parseInt(num, 10);
      });
      if (untitleds.length === 0) {
        if (!files.has("untitled.svg")) {
          return "untitled.svg";
        }
      }
      x = 1;
      while (true) {
        if (nums.has(x)) {
          x += 1;
        } else {
          return "untitled-" + x + ".svg";
        }
      }
    },
    clearAllLocalHistory: function() {
      var file, _i, _len, _ref3, _results;
      _ref3 = this.files();
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        file = _ref3[_i];
        _results.push(localStorage.removeItem("local-" + file + "-archive"));
      }
      return _results;
    }
  });

  setup.push(function() {
    return services.local.setup();
  });

  /*
  
    Permalink file service
    Works closely with local file service
  */


  services.permalink = new Service({
    name: "permalink",
    open: function() {
      return services.local.open();
    },
    get: function(public_key, success) {
      return $.getJSON("" + SETTINGS.MEOWSET.ENDPOINT + "/files/permalinks/get", {
        public_key: public_key
      }, function(response) {
        success({
          contents: response.content,
          file_name: response.file_name,
          readonly: response.readonly
        });
        return trackEvent("Permalinks", "Open", public_key);
      });
    },
    put: function(public_key, contents, success, emails) {
      var data, thumb;
      if (public_key == null) {
        public_key = void 0;
      }
      if (contents == null) {
        contents = io.makeFile();
      }
      if (success == null) {
        success = (function() {});
      }
      if (emails == null) {
        emails = "";
      }
      thumb = io.makePNGURI(ui.elements, 400);
      data = {
        file_name: ui.file.name,
        svg: contents,
        thumb: thumb,
        emails: emails
      };
      if (public_key != null) {
        data.public_key = public_key;
      }
      if (ui.account.session_token != null) {
        data['session_token'] = ui.account.session_token;
      }
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/files/permalinks/put",
        type: "POST",
        dataType: "json",
        data: data,
        success: function(response) {
          if (public_key == null) {
            new PermalinkFile(response.public_key).use();
            switch (public_key) {
              case "":
                trackEvent("Permalinks", "Create", response.public_key);
                break;
              default:
                trackEvent("Permalinks", "Save", response.public_key);
            }
          } else {
            console.log("saved");
          }
          return typeof success === "function" ? success() : void 0;
        }
      });
    }
  });

  /*
  
    Dropbox, baby
  */


  services.dropbox = new Service({
    name: "Dropbox",
    module: "poletto",
    tease: function() {
      return ui.menu.items.dropboxConnect.show();
    },
    activate: function() {
      ui.menu.items.dropboxConnect.hide();
      if (!ui.account.services.has("dropbox")) {
        return ui.account.services.push("dropbox");
      }
    },
    disable: function() {
      return ui.menu.items.dropboxConnect.disable();
    },
    enable: function() {
      return ui.menu.items.dropboxConnect.enable();
    }
  });

  /*
  
    Helper geometry layer
  */


  annotations = {
    uiMainColor: '#4982E0',
    drawLine: function(a, b, stroke) {
      var line;
      if (stroke == null) {
        stroke = this.uiMainColor;
      }
      if (!dom.main) {
        return;
      }
      line = new Line({
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y,
        fill: 'none',
        stroke: stroke
      });
      line.commit();
      line.appendTo('svg#annotations', false);
      return line;
    },
    drawDot: function(p, fill, r) {
      var dot;
      if (fill == null) {
        fill = this.uiMainColor;
      }
      if (r == null) {
        r = 3;
      }
      if (!dom.main) {
        return;
      }
      dot = new Circle({
        cx: p.x,
        cy: p.y,
        r: r,
        fill: fill,
        stroke: 'none'
      });
      dot.commit();
      dot.appendTo('svg#annotations', false);
      return dot;
    },
    drawDots: function(posns, color, r) {
      var _this = this;
      return posns.forEach(function(posn) {
        return _this.drawDot(posn, color, r);
      });
    },
    clear: function() {
      return $("#annotations").empty();
    }
  };

  ui.annotations = annotations;

  /*
  */


  grid = {
    frequency: {
      x: 20,
      y: 20
    },
    dots: [],
    posns: [],
    visible: function() {
      return this.dots.length;
    },
    toggle: function() {
      if (this.visible()) {
        return this.clear();
      } else {
        return this.draw();
      }
    },
    clear: function() {
      dom.$grid.empty();
      this.dots = null;
      return this.dots = [];
    },
    draw: function() {
      var dot, height, posn, width, x, y, _i, _j, _ref3, _ref4, _ref5,
        _this = this;
      this.clear();
      _ref3 = [ui.canvas.width, ui.canvas.height], width = _ref3[0], height = _ref3[1];
      for (y = _i = 0, _ref4 = height / this.frequency.y; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; y = 0 <= _ref4 ? ++_i : --_i) {
        for (x = _j = 0, _ref5 = width / this.frequency.x; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; x = 0 <= _ref5 ? ++_j : --_j) {
          posn = new Posn(x * this.frequency.x, y * this.frequency.y);
          dot = this.dot(posn);
          dot.appendTo("svg#grid", false);
          this.dots.push(dot);
          this.posns.push(posn);
        }
      }
      return async(function() {
        return _this.refreshRadii();
      });
    },
    dot: function(p) {
      return new Circle({
        cx: p.x,
        cy: p.y,
        r: 1,
        dontTrack: true,
        fill: new Color(0, 0, 0, 0.6),
        stroke: 'none'
      });
    },
    refreshRadii: function() {
      if (!this.visible()) {
        return;
      }
      dom.$grid.hide();
      this.dots.map(function(dot) {
        dot.attr({
          r: 1 / ui.canvas.zoom
        });
        return dot.commit();
      });
      return dom.$grid.show();
    }
  };

  ui.grid = grid;

  /*
  
    The logged-in account
  
      strings
        email:         user's email address
        session_token: secret token used to verify their logged-in session
  
      lists
        services: which services they have access to
                  default:
                    'local'
                  possibly also:
                    'dropbox'
                    (more to come)
  
        active:     if they should get full account features
        subscribed: if they actually have an active card on file
  */


  ui.account = {
    email: "",
    session_token: "",
    services: ['local'],
    valueOf: function() {
      return this.email || "anon";
    },
    uiAnonymous: function() {
      services.dropbox.tease().disable();
      ui.menu.items.shareAsLink.enable();
      ui.menu.items.downloadSVG.enable();
      ui.menu.menus.login.show();
      return ui.menu.menus.register.show();
    },
    uiLoggedIn: function() {
      services.dropbox.tease().enable();
      ui.menu.items.shareAsLink.enable();
      ui.menu.items.downloadSVG.enable();
      ui.menu.menus.login.groupHide();
      return ui.menu.menus.account.text(this.email).groupShow();
    },
    checkSession: function() {
      var _this = this;
      this.session_token = localStorage.getItem("session_token");
      if (this.session_token) {
        return $.ajax({
          url: "" + SETTINGS.MEOWSET.ENDPOINT + "/user/persist-session",
          type: "POST",
          dataType: "json",
          data: {
            session_token: this.session_token
          },
          success: function(response) {
            if (response.anon != null) {
              _this.uiAnonymous();
            } else {
              _this.processLogin(response);
            }
            return trackEvent("User", "Persist session");
          },
          error: function() {
            return _this.uiAnonymous();
          }
        });
      } else {
        return this.uiAnonymous();
      }
    },
    login: function(email, passwd) {
      var _this = this;
      $("#login-mg input").each(function() {
        return $(this).disable();
      });
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/user/login",
        type: "POST",
        dataType: "json",
        data: {
          email: email,
          passwd: passwd
        },
        success: function(response) {
          _this.processLogin(response);
          if ((response.trial_remaining != null) > 0) {
            ui.menu.menus.account.openDropdown();
          }
          $("#login-mg input").each(function() {
            return $(this).enable();
          });
          return trackEvent("User", "Login");
        },
        error: function(data) {
          data = JSON.parse(data.responseText);
          $("#submit-login").error(data.error);
          return trackEvent("User", "Login error", data.error);
        },
        complete: function() {
          return $("#login-mg input").each(function() {
            return $(this).enable();
          });
        }
      });
    },
    processLogin: function(response) {
      var s, _i, _len, _ref3, _results;
      $.extend(this, response);
      localStorage.setItem("session_token", this.session_token);
      ui.menu.menus.login.groupHide();
      ui.menu.menus.register.groupHide();
      ui.menu.menus.account.show().text(this.email);
      ui.menu.closeAllDropdowns();
      this.uiLoggedIn();
      if (response.services != null) {
        _ref3 = response.services;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          s = _ref3[_i];
          _results.push(services[s].activate());
        }
        return _results;
      } else {
        return services.dropbox.tease();
      }
    },
    logout: function() {
      var _this = this;
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/user/logout",
        type: "POST",
        dataType: "json",
        data: {
          session_token: this.session_token
        },
        success: function(response) {
          _this.session_token = void 0;
          localStorage.removeItem("session_token");
          trackEvent("User", "Logout");
          _this.uiAnonymous();
          ui.menu.menus.account.groupHide();
          ui.menu.menus.login.groupShow();
          return ui.menu.menus.register.groupShow();
        }
      });
    },
    checkServices: function() {
      return $.getJSON("" + SETTINGS.MEOWSET.ENDPOINT + "/user/check-services", {
        session_token: this.session_token
      }, function(data) {
        if (data.dropbox) {
          return services.dropbox.activate();
        }
      });
    },
    create: function(name, email, passwd) {
      var _this = this;
      return $.ajax({
        url: "" + SETTINGS.MEOWSET.ENDPOINT + "/user/register",
        type: "POST",
        dataType: "json",
        data: {
          name: name,
          email: email,
          passwd: passwd
        },
        success: function(data) {
          trackEvent("User", "Create", "(" + name + " , " + email + ")");
          _this.login(email, passwd);
          return ui.menu.closeAllDropdowns();
        },
        error: function(data) {
          data = JSON.parse(data.responseText);
          return $("#submit-registration").error(data.error);
        }
      });
    }
  };

  setup.push(function() {
    ui.account.checkSession();
    return ui.refreshUtilities();
  });

  url = {
    actions: {
      p: function(public_key) {
        ui.canvas.hide();
        return services.permalink.get(public_key, function(response) {
          var permalink;
          ui.canvas.show();
          io.parseAndAppend(response.contents);
          permalink = new PermalinkFile(public_key);
          permalink.use();
          permalink.readonly = response.readonly;
          return ui.canvas.centerOn(ui.window.center());
        });
      },
      url: function(targetURL) {
        return ui.menu.items.openURL.openURL(targetURL);
      }
    },
    parse: function() {
      var key, param, parameters, url_parameters, val, _base, _i, _len, _results;
      url_parameters = document.location.search.replace(/\/$/, "");
      parameters = url_parameters.substring(1).split("&");
      _results = [];
      for (_i = 0, _len = parameters.length; _i < _len; _i++) {
        param = parameters[_i];
        param = param.split("=");
        key = param[0];
        val = param[1];
        _results.push(typeof (_base = this.actions)[key] === "function" ? _base[key](val) : void 0);
      }
      return _results;
    }
  };

  setup.push(function() {
    return url.parse();
  });

  /*
  
    Managing the persistent file state we save in the browser.
  
  
    This is like a psuedo-file. It saves and shows you whatever you had open last time
    right away with localStorage. This just makes the experience feel faster and eliminates
    the amount of time people will have to look at a blank screen.
  
    The only time this doesn't happen is with permalinks. It's unlikely you will already
    have had the same permalink open right before clicking on one (does that make sense?)
  
    Since local files load instantenly, the only real lag is with files from Dropbox.
    (And Google Drive/SkyDrive in the future)
  
    Doesn't matter: before anyone gets clicking on their file the true file should
    have loaded even if it's from Dropbox.
  */


  ui.browserFile = {
    save: function(force) {
      if (force == null) {
        force = false;
      }
      if (ui.afk.active && (!force)) {
        return;
      }
      if (ui.file == null) {
        new LocalFile(services.local.nextDefaultName()).use();
      }
      if (ui.file.service === services.permalink) {
        return;
      }
      localStorage.setItem("file-metadata", ui.file.toString());
      localStorage.setItem("file-content", io.makeFile());
      return localStorage.setItem("file-archive", archive.toString());
    },
    load: function() {
      var fileArchive, fileContent, fileMetadata, service;
      fileContent = localStorage.getItem("file-content");
      fileArchive = localStorage.getItem("file-archive");
      if (fileContent != null) {
        io.parseAndAppend(localStorage.getItem("file-content"));
        fileMetadata = JSON.parse(localStorage.getItem("file-metadata")) || {};
        if (fileMetadata.name == null) {
          fileMetadata.name = "untitled.svg";
        }
        service = fileMetadata.service.toLowerCase();
        new File().fromService(services[service])(fileMetadata.key).use();
        if (fileArchive != null) {
          return archive.loadFromString(fileArchive, false);
        }
      } else {
        new LocalFile(services.local.nextDefaultName()).use();
        return ui.file.save();
      }
    }
  };

  setup.push(function() {
    if (!(ui.file != null)) {
      ui.browserFile.load();
    }
    return setInterval(function() {
      return ui.browserFile.save();
    }, 1000);
  });

}).call(this);
